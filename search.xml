<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Tomcat set Windows cmd title</title>
    <url>/en/tomcat-set-title/</url>
    <content><![CDATA[<p>This article describes how to set the title of the Windows command prompt window when starting Tomcat.</p>
<span id="more"></span>
<p>When you open multiple tomcat windows, it is difficult to distinguish which window is which project. Setting the window name can help distinguish.</p>
<p>Enter the bin directory of tomcat, such as <code>T:\apache-tomcat-9.0.60-windows-x64\apache-tomcat-9.0.60\bin</code>, find the <code>catalina.bat</code> file, and open it with a text editor.</p>
<p>You can see in the bottom of the description, there is a parameter called <code>TITLE</code>, and the default is <code>Tomcat</code>. You can modify it according to your needs. It can have spaces.</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="comment">rem   TITLE           (Optional) Specify the title of Tomcat window. The default</span></span><br><span class="line"><span class="comment">rem                   TITLE is Tomcat if it&#x27;s not specified.</span></span><br><span class="line"><span class="comment">rem                   Example (all one line)</span></span><br><span class="line"><span class="comment">rem                   set TITLE=Tomcat.Cluster#1.Server#1 [%DATE% %TIME%]</span></span><br></pre></td></tr></table></figure>
<p>Search for <code>TITLE</code> in the file, and find the following section. Fill in your name after <code>set TITLE</code>.</p>
<figure class="highlight dos"><table><tr><td class="code"><pre><span class="line">:doStart</span><br><span class="line"><span class="built_in">shift</span></span><br><span class="line"><span class="comment">rem Set the title of the window</span></span><br><span class="line"><span class="comment">rem if &quot;%TITLE%&quot; == &quot;&quot; set TITLE=Tomcat</span></span><br><span class="line"><span class="keyword">if</span> &quot;<span class="variable">%TITLE%</span>&quot; == &quot;&quot; <span class="built_in">set</span> <span class="built_in">TITLE</span>=YOURNAME YOURSUBNAME</span><br><span class="line"><span class="built_in">set</span> _EXECJAVA=<span class="built_in">start</span> &quot;<span class="variable">%TITLE%</span>&quot; <span class="variable">%_RUNJAVA%</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> &quot;&quot;%<span class="number">1</span>&quot;&quot; == &quot;&quot;-security&quot;&quot; <span class="keyword">goto</span> execCmd</span><br><span class="line"><span class="built_in">shift</span></span><br><span class="line"><span class="built_in">echo</span> Using Security Manager</span><br><span class="line"><span class="built_in">set</span> &quot;SECURITY_POLICY_FILE=<span class="variable">%CATALINA_BASE%</span>\conf\catalina.policy&quot;</span><br><span class="line"><span class="keyword">goto</span> execCmd</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Technology</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-冒泡排序</title>
    <url>/zh-CN/Algorithms-bubble-sort/</url>
    <content><![CDATA[<p>算     法：冒泡排序算法<br>
时间复杂度：$O(n^2)$</p>
<ul>
<li>
<p>冒泡排序算法概述</p>
</li>
<li>
<p>冒泡排序伪代码</p>
</li>
<li>
<p>冒泡排序实现</p>
</li>
</ul>
<span id="more"></span>
<h1>冒泡排序算法概述</h1>
<p>冒泡排序通常是我们在学习编程的过程中遇到排序问题，最先接触到的算法，它的算法过程就是每一趟排序都会通过交换不满足排序状态的相邻两个数来达到每一趟排序都让一个元素“冒泡”到正确位置，直到最后一趟“冒泡”过程完成，也就完成了排序。</p>
<h2 id="冒泡排序算法描述">冒泡排序算法描述</h2>
<ol>
<li>第$i$趟“冒泡”过程从序列尾部遍历至第$i$个元素;</li>
<li>对于每一趟“冒泡”过程，比较每个正在遍历的元素与前一个元素的大小关系，如不满足，则交换2者位置;</li>
<li>持续1-2步骤直至对于每个位置都进行一趟“冒泡”过程为止。</li>
</ol>
<h2 id="冒泡排序示例">冒泡排序示例</h2>
<p>未排序：   5 31 16 7 9 10 3<br>
第一趟： [<strong>3</strong>] 5 31 16 7 9 10<br>
第二趟： [<strong>3 5</strong>] 7 31 16 9 10<br>
第三趟： [<strong>3 5 7</strong>] 9 31 16 10<br>
第四趟： [<strong>3 5 7 9</strong>] 10 31 16<br>
第五趟： [<strong>3 5 7 9 10</strong>] 16 31<br>
第六趟： [<strong>3 5 7 9 10 16</strong>] 31<br>
第七趟： [<strong>3 5 7 9 10 16 31</strong>]</p>
<p>冒泡排序的动态演示：</p>
<p><a href="https://visualgo.net/zh/sorting">VisuAlgo-排序（冒泡排序，选择排序，插入排序，归并排序，快速排序，基数排序，基数排序）</a></p>
<h1>冒泡排序伪代码</h1>
<p>（引用自《算法导论》）<br>
BUBBLESORT(A)</p>
<figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i = <span class="number">1</span> <span class="keyword">to</span> A.length - <span class="number">1</span></span><br><span class="line">  <span class="keyword">for</span> j = A.length <span class="keyword">downto</span> i + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> A[j] &lt; A[j - <span class="number">1</span>]</span><br><span class="line">      exchange A[j] <span class="keyword">with</span> A[j - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h1>冒泡排序实现</h1>
<h2 id="C">C</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bubbleSort</span><span class="params">(arrType* a, <span class="type">int</span> arrLength)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; arrLength - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = arrLength - <span class="number">1</span>; j &gt; i; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt; a[j - <span class="number">1</span>]) &#123;</span><br><span class="line">               t = a[j];</span><br><span class="line">               a[j] = a[j - <span class="number">1</span>];</span><br><span class="line">               a[j - <span class="number">1</span>] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Pascal">Pascal</h2>
<figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">bubblesort</span>;</span>   </span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">  i, j, t : integer;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">1</span> <span class="keyword">to</span> arrLength - <span class="number">1</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">for</span> j := arrLength <span class="keyword">downto</span> i + <span class="number">1</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> a[j] &lt; a[j - <span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">begin</span></span><br><span class="line">                t := a[j];</span><br><span class="line">                a[j] := a[j - <span class="number">1</span>];</span><br><span class="line">                a[j - <span class="number">1</span>] := t;</span><br><span class="line">            <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<h1>参考资料</h1>
<ul>
<li>《算法导论》（第三版）</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-二分搜索算法</title>
    <url>/zh-CN/Algorithms-binary-search/</url>
    <content><![CDATA[<p>算法：二分搜索算法（折半查找算法）<br>
时间复杂度：$O(log ; n)$</p>
<ul>
<li>二分搜索算法概述</li>
<li>二分搜索算法伪代码</li>
<li>二分搜索算法实现</li>
</ul>
<span id="more"></span>
<h1>二分搜索算法概述</h1>
<p>二分搜索算法，也称折半查找算法，即在一个有序数组中查找某一个特定元素。整个搜索过程从中间开始，如果要查找的元素即中间元素，那么搜索过程结束；反之根据中间元素与要查找元素的关系在数组对应的那一半查找，例如查找元素大于中间元素，则在整个数组较大元素的那一半查找，反复进行这个过程，直到找到元素，或者数组为空，查找不到元素。</p>
<p>这里有一张非常形象的算法描述图：</p>
<p><img src="https://idea-instructions.com/binary-search.png" alt="Binary Search"></p>
<h2 id="二分搜索算法描述">二分搜索算法描述</h2>
<p>给定一个数组 $A_0, A_1… A_{n-1}$， $A_0 \le A_1 \le \cdot \le A_{n - 1}$，待查找元素为<code>searchnum</code>：</p>
<ol>
<li>用<code>left</code>，<code>right</code>分别表示左右端点，即要查找的范围；</li>
<li>用<code>middle</code>表示中间点，$middle = \lfloor (left + right) / 2 \rfloor$；</li>
<li>若<code>left &gt; right</code>，搜索失败；</li>
<li>若 $A_{middle}$ &gt;<code> searchnum</code>，<code>right = middle - 1</code>，返回3；</li>
<li>若 $A_{middle}$ &lt; <code>searchnum</code>，<code>left = middle + 1</code>，返回3；</li>
<li>若 $A_{middle}$ = <code>searchnum</code>，搜索结束，返回<code>middle</code>。</li>
</ol>
<h1>二分搜索算法伪代码</h1>
<div class="tabs" id="pseudo-code"><ul class="nav-tabs"><li class="tab active"><a href="#pseudo-code-1">迭代版本</a></li><li class="tab"><a href="#pseudo-code-2">递归版本</a></li></ul><div class="tab-content"><div class="tab-pane active" id="pseudo-code-1"><p>BINARY-SEARCH-WHILE(A, searchnum, left, right)</p>
<figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> left &lt;= right</span><br><span class="line">  middle = (left + right) <span class="keyword">div</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">case</span></span><br><span class="line">    A_middle &lt; searchnum : left = middle + <span class="number">1</span></span><br><span class="line">    A_middle &gt; searchnum : right = middle - <span class="number">1</span></span><br><span class="line">    A_middle = searchnum : return middle</span><br><span class="line">return FAILED</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="pseudo-code-2"><p>BINARY-SEARCH-RECURSION(A, searchnum, left, right)</p>
<figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> left &lt;= right</span><br><span class="line">  middle = (left + right) <span class="keyword">div</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">case</span></span><br><span class="line">    A_middle &lt; searchnum :</span><br><span class="line">      return (A, searchnum, middle + <span class="number">1</span>, right)</span><br><span class="line">    A_middle &gt; searchnum :</span><br><span class="line">      return (A, searchnum, left, middle - <span class="number">1</span>)</span><br><span class="line">    A_middle = searchnum :</span><br><span class="line">      return middle</span><br></pre></td></tr></table></figure></div></div></div>
<h1>二分查找算法实现</h1>
<div class="tabs" id="binarysearch-realize"><ul class="nav-tabs"><li class="tab active"><a href="#binarysearch-realize-1">C 迭代</a></li><li class="tab"><a href="#binarysearch-realize-2">C 递归</a></li><li class="tab"><a href="#binarysearch-realize-3">Pascal 迭代</a></li><li class="tab"><a href="#binarysearch-realize-4">Pascal 递归</a></li></ul><div class="tab-content"><div class="tab-pane active" id="binarysearch-realize-1"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(arrType * a, arrType searchnum, <span class="type">int</span> left, <span class="type">int</span> right)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> middle;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        middle = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[middle] &gt; searchnum)</span><br><span class="line">            right = middle - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[middle] &lt; searchnum)</span><br><span class="line">            left = middle + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[middle] == searchnum)</span><br><span class="line">            <span class="keyword">return</span> middle;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="binarysearch-realize-2"><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(arrType * a, arrType searchnum, <span class="type">int</span> left, <span class="type">int</span> right)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> middle;</span><br><span class="line">    <span class="keyword">if</span> (left &lt;= right) &#123;</span><br><span class="line">        middle = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[middle] &gt; searchnum)</span><br><span class="line">            <span class="keyword">return</span> binarySearch(a, searchnum, left, middle - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[middle] &lt; searchnum)</span><br><span class="line">            <span class="keyword">return</span> binarySearch(a, searchnum, middle + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[middle] == searchnum)</span><br><span class="line">            <span class="keyword">return</span> middle;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="binarysearch-realize-3"><figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 外部定义全局变量：</span></span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    a : <span class="keyword">array</span>[<span class="number">1</span>..n] <span class="keyword">of</span> integer;</span><br><span class="line">    searchnum, result :integer;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">binarySearch</span><span class="params">(left, right :integer)</span>;</span></span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    middle : integer;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            middle := (left + right) <span class="keyword">div</span> <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (a[middle] &gt; searchnum) <span class="keyword">then</span></span><br><span class="line">                right := middle  - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (a[middle] &lt; searchnum) <span class="keyword">then</span></span><br><span class="line">                left := middle + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">begin</span></span><br><span class="line">                    result := middle;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">end</span>;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">if</span> left &gt; right <span class="keyword">then</span></span><br><span class="line">        result := -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="binarysearch-realize-4"><figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 外部定义全局变量：</span></span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    a : <span class="keyword">array</span>[<span class="number">1</span>..n] <span class="keyword">of</span> integer;</span><br><span class="line">    searchnum, result :integer;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">binarySearch</span><span class="params">(left, right :integer)</span>;</span></span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    middle : integer;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> left &lt;= right <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            middle := (left + right) <span class="keyword">div</span> <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (a[middle] &gt; searchnum) <span class="keyword">then</span></span><br><span class="line">                binarySearch(left, middle - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (a[middle] &lt; searchnum) <span class="keyword">then</span></span><br><span class="line">                binarySearch(middle + <span class="number">1</span>, right)</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                result := middle;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        result := -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure></div></div></div>
<h1>参考资料</h1>
<ol>
<li>Yan, Weimin., Wu, Weimin. 数据结构: C语言版. China: 清华大学出版社, 1997.《数据结构基础（C语言版）》第二版</li>
<li><a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95">二分搜索算法 - 维基百科，自由的百科全书</a></li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
        <tag>Search</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-辗转相除法（欧几里得算法）</title>
    <url>/zh-CN/Algorithms-gcd-euclid/</url>
    <content><![CDATA[<p>算法：辗转相除法（欧几里得算法）</p>
<ul>
<li>
<p>GCD递归定理</p>
</li>
<li>
<p>辗转相除法算法概述</p>
</li>
<li>
<p>辗转相除法伪代码</p>
</li>
<li>
<p>辗转相除法代码实现</p>
</li>
</ul>
<span id="more"></span>
<p>对于两个数的最大公约数的求解，在我们的笔算过程中，通常是使用一个短除法，本质上其实也就是进行一个质因数分解的过程，但对于一个较大的数来说，将其进行质因数分解是一件非常耗时的过程，这显然不是一个好的做法，因此基于数论基础，我们有了辗转相除法，也叫做欧几里得算法。</p>
<p>该算法的一个更容易理解的几何解释是，假设有一块 $a*b$ 的地面需要铺设正方形砖块，问应该如何取砖块的长度。在此选取过程中，我们每次取该矩形剩余部分的短边作为砖块边长，铺设至无法再铺设为止，如此循环，当某砖块长度恰好能够铺满地面不留余地，则该长度为所取长度，也就是 $a$ 和 $b$ 的最大公约数<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。</p>
<h1>GCD递归定理</h1>
<p>在叙述该算法之前，先了解辗转相除法的实现前提也就是GCD递归定理：</p>
<blockquote>
<p>对任意非负整数$a$和任意正整数$b$,<br>
$$<br>
gcd(a,b) = gcd(b,a \quad mod \quad b)<br>
$$</p>
</blockquote>
<h1>辗转相除法算法概述</h1>
<p>基于上面的GCD递归定理，我们便可以知道可以采用递归的方式，对两个整数的最大公约数进行相对较为高效的计算。</p>
<h2 id="算法描述：">算法描述：</h2>
<ol>
<li>求两个数的余数；</li>
<li>若余数为0，则较小数即为最大公约数；否则执行3；</li>
<li>用较小的数替换较大的数，用余数替换较小的数；</li>
<li>返回1。</li>
</ol>
<h2 id="算法示例">算法示例</h2>
<p>$$<br>
gcd(30,21) = gcd(21,9) = gcd(9,3) = gcd(3,0) = 3<br>
$$</p>
<h1>辗转相除法伪代码表示</h1>
<p>下面我们采用递归方式实现辗转相除法<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>。</p>
<p>GCD(a, b)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> b == <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> a</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="keyword">return</span> GCD(b, a mod b)</span><br></pre></td></tr></table></figure>
<h1>辗转相除法实现</h1>
<h2 id="C">C</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> gcd(b, a % b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="pascal">pascal</h2>
<figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gcd</span><span class="params">(a, b : integer)</span> :</span>integer;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> b = <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">        gcd := a</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        gcd := gcd(b, a <span class="keyword">mod</span> b);</span><br></pre></td></tr></table></figure>
<h1>参考资料</h1>
<ul>
<li>《Free Pascal 语言与基础算法》</li>
</ul>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>The Secret Rules of Modern Living: Algorithms (2015) <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>《算法导论》（第三版） <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
        <tag>Number theory</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-插入排序</title>
    <url>/zh-CN/Algorithms-insertion-sort/</url>
    <content><![CDATA[<p>算     法：插入排序算法<br>
时间复杂度：$O(n^2)$</p>
<ul>
<li>插入排序算法描述</li>
<li>插入排序伪代码</li>
<li>插入排序实现</li>
</ul>
<span id="more"></span>
<h1>插入排序算法概述</h1>
<p>插入排序的原理是构建有序序列，对于给定的一个无序序列，从前往后遍历，在该元素之前的序列中从后往前扫描，寻找正确位置，这样对于每一个正在排序的元素，前面的序列总是有序的，当遍历完整个序列，即完成排序。《算法导论》给了一个更通俗更容易理解的形象的描述。我们都玩过扑克牌，大多数人拿扑克牌的时候都有这么个习惯，那就是将扑克牌按照一定的顺序排列好，而插入排序就好比你不断从桌上一堆无序排中拿起最上面的那张，然后放入自己手中已有的牌中，而每一次放的过程你都会按照某个顺序将这张新拿到的牌插入正确的位置，这样你手中的牌一直是有序的，而你抽取牌所在的牌堆是无序的。</p>
<h2 id="算法描述">算法描述</h2>
<p>下面以非降序排序为例：</p>
<ol>
<li>从第一个元素开始，该元素视为已经被排序；</li>
<li>取出下一个元素记为<code>key</code>，在前面已排序的有序序列中从后往前扫描；</li>
<li>如果扫描过程中的元素大于<code>key</code>，将该元素移至下一个位置；</li>
<li>重复3，直至找到已排序的元素小于或等于<code>key</code>的位置；</li>
<li>将<code>key</code>插入到该位置；</li>
<li>重复2-5，直到整个序列遍历完即得到一个原地排序好的序列。</li>
</ol>
<h2 id="执行过程图解">执行过程图解</h2>
<p>以斜体数字如 <u>1</u> 表示<code>key</code>，以粗体数字如 <strong>‘1’</strong> 表示已排序序列，为了更直观，用中括号括起来，普通数字如‘1’表示未排序乱序序列，简要表示排序流程如下：</p>
<ul>
<li>5 2 4 6 1 3</li>
<li>[<strong>5</strong>] <u>2</u> 4 6 1 3</li>
<li>[<strong>2 5</strong>] <u>4</u> 6 1 3</li>
<li>[<strong>2 4 5</strong>] <u>6</u> 1 3</li>
<li>[<strong>2 4 5 6</strong>] <u>1</u> 3</li>
<li>[<strong>1 2 4 5 6</strong>] <u>3</u></li>
<li>[<strong>1 2 3 4 5 6</strong>]</li>
</ul>
<p>插入排序的动态演示：</p>
<p><a href="https://visualgo.net/zh/sorting">VisuAlgo-排序（冒泡排序，选择排序，插入排序，归并排序，快速排序，基数排序，基数排序）</a></p>
<h1>插入排序伪代码</h1>
<p>（伪代码引用《算法导论》给出的例子）<br>
INSERTION-SORT(A)</p>
<figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> j = <span class="number">2</span> <span class="keyword">to</span> A.length</span><br><span class="line">  key = A[j]</span><br><span class="line">  <span class="comment">// Insert A[j] into the sorted sequence A[1..j - 1].</span></span><br><span class="line">  i = j - <span class="number">1</span></span><br><span class="line">  <span class="keyword">while</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> A[i] &gt; key</span><br><span class="line">    A[i + <span class="number">1</span>] = A[i]</span><br><span class="line">    i = i - <span class="number">1</span></span><br><span class="line">  A[i + <span class="number">1</span>] = key</span><br></pre></td></tr></table></figure>
<h1>插入排序实现</h1>
<p>为了更直观，我们将所有元素从1号元素开始计数，将0号元素视为无穷小，即数组长度为<code>arrLength + 1</code>，序列存储于<code>arr[1..arrLength]</code>。</p>
<h2 id="C">C</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insertionSort</span><span class="params">(arrType* arr, <span class="type">int</span> arrLength)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i, j;</span><br><span class="line">  arrType key;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (j = <span class="number">2</span>; j &lt;= arrLength; j++) &#123;</span><br><span class="line">    key = arr[j];</span><br><span class="line"></span><br><span class="line">    i = j - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; arr[i] &gt; key) &#123;</span><br><span class="line">      arr[i + <span class="number">1</span>] = arr[i];</span><br><span class="line">      i--;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[i + <span class="number">1</span>] = key;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Pascal">Pascal</h2>
<figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">insertsort</span>;</span>   </span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">  i,j,key:integer;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  arr[<span class="number">0</span>] := -maxint;</span><br><span class="line">  <span class="keyword">for</span> j := <span class="number">2</span> <span class="keyword">to</span> n <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">begin</span></span><br><span class="line">    i := j - <span class="number">1</span>;</span><br><span class="line">    key := arr[j];</span><br><span class="line">    <span class="keyword">while</span> arr[i] &gt; key <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">      arr[i + <span class="number">1</span>] := arr[i];</span><br><span class="line">      i := i - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    arr[i + <span class="number">1</span>] := key;</span><br><span class="line">  <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;  </span><br></pre></td></tr></table></figure>
<h1>参考资料</h1>
<ul>
<li>《算法导论》（原书第3版)</li>
<li><a href="https://zh.wikipedia.org/wiki/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F">插入排序-维基百科，自由的百科全书</a></li>
<li>《Free Pascal 语言与基础算法》</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title>Blog-调整NexT主题Mist外观侧边栏在左</title>
    <url>/zh-CN/Blog-adjust-sidebar-nextmist-left/</url>
    <content><![CDATA[<p>在NexT主题的Mist外观下，侧边栏默认在右，而打开主题配置文件<code>_config.yml</code>查看，只有在<code>Pisces</code>，<code>Gemini</code>这两种外观下才可以通过<code>_config.yml</code>直接修改选择左侧或是右侧。而本人习惯把音乐播放器以及输入法放置于桌面右下角，故侧边栏在右并不方便 。于是在寻找了一些教程后 ，做出了修改，并做此记录和分享。</p>
<span id="more"></span>
<p>在此过程中需要修改如下几个文件：</p>
<ul>
<li>sidebar.styl</li>
<li>sidebar-toggle.styl</li>
<li>back-to-top.styl</li>
<li>motion.js</li>
</ul>
<p>2019.3.25 更新 增加bug修正部分</p>
<h1>sidebar.styl</h1>
<p>路径：<code>.\themes\next\source\css\_common\components\sidebar\</code><br>
将此文件的第3行<code>right</code>改为<code>left</code></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h1>sidebar-toggle.styl</h1>
<p>路径：<code>.\themes\next\source\css\_common\components\sidebar\</code><br>
同样将第3行冒号前的<code>right</code>改为<code>left</code></p>
<figure class="highlight nsis"><table><tr><td class="code"><pre><span class="line"><span class="literal">left</span>: <span class="variable">$b2t</span>-position-<span class="literal">right</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h1>back-to-top.styl</h1>
<p>路径：<code>.\themes\next\source\css\_common\components\</code><br>
将第5行冒号前的<code>right</code>改为<code>left</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">left</span>: $b2t-position-right;</span><br></pre></td></tr></table></figure>
<h1>motion.js</h1>
<p>路径：<code>.\themes\next\source\js\src\motion.js</code><br>
利用搜索功能找到改文档中的<code>paddingRight</code>字段，将<code>paddingRight</code>改为<code>paddingLeft</code>(共两处)。</p>
<h1>重新部署</h1>
<p>重新部署即可完成侧边栏在左的设置。</p>
<h1>修正缩小窗口时的bug</h1>
<p>自己没注意过这个问题，感谢评论区Jode_He指出和分享。仅使用上面的方案情况下，如果侧边栏的设置是展开状态，在浏览器窗口缩小时会导致侧边栏仍然存在且占据相当大的位置。做以下调整。</p>
<p>找到<code>./themes/source/js/src/motion.js</code>文件，在<code>$(document).ready(function ()&#123;&#125;)</code>内添加内容：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="variable language_">document</span>).<span class="title function_">ready</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="variable language_">window</span>.<span class="property">onload</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	    <span class="keyword">var</span> bwol=<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">offsetWidth</span>;</span><br><span class="line">	    <span class="keyword">if</span>(bwol &lt; <span class="number">975</span>)&#123;</span><br><span class="line">		$(<span class="string">&#x27;aside#sidebar&#x27;</span>).<span class="title function_">css</span>(<span class="string">&quot;display&quot;</span>,<span class="string">&quot;none&quot;</span>);</span><br><span class="line">		$(<span class="string">&#x27;body&#x27;</span>).<span class="title function_">css</span>(<span class="string">&quot;paddingLeft&quot;</span>,<span class="string">&quot;0px&quot;</span>);</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="variable language_">window</span>.<span class="property">onresize</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	    <span class="keyword">var</span> bwos=<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">offsetWidth</span>;</span><br><span class="line">	    bwos &lt; <span class="number">975</span> &amp;&amp; $(<span class="string">&#x27;body&#x27;</span>).<span class="title function_">velocity</span>(<span class="string">&#x27;stop&#x27;</span>).<span class="title function_">velocity</span>(&#123;<span class="attr">paddingLeft</span>: <span class="number">0</span>&#125;,<span class="number">0</span>);</span><br><span class="line">	    <span class="keyword">if</span>($(<span class="string">&#x27;aside#sidebar&#x27;</span>).<span class="title function_">css</span>(<span class="string">&#x27;display&#x27;</span>) != <span class="string">&#x27;none&#x27;</span> &amp;&amp; $(<span class="string">&#x27;aside#sidebar&#x27;</span>).<span class="title function_">css</span>(<span class="string">&#x27;width&#x27;</span>)!=<span class="string">&#x27;0px&#x27;</span>)</span><br><span class="line">		$(<span class="string">&#x27;body&#x27;</span>).<span class="title function_">velocity</span>(<span class="string">&#x27;stop&#x27;</span>).<span class="title function_">velocity</span>(&#123;<span class="attr">paddingLeft</span>: <span class="number">350</span>&#125;,<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	   <span class="title class_">NexT</span>.<span class="property">motion</span> = &#123;&#125;;</span><br><span class="line">	   </span><br><span class="line">	   ...</span><br></pre></td></tr></table></figure>
<h1>参考资料</h1>
<ul>
<li><a href="http://mashirosorata.vicp.io/HEXO-NEXT%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE.html">HEXO+NEXT主题个性化配置|SORA</a></li>
</ul>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title>Blog-为博客绑定自定义二级域名</title>
    <url>/zh-CN/Blog-bind-subdomain-to-blog/</url>
    <content><![CDATA[<p>本文记录为博客绑定自定义二级域名过程以及踩到的坑。网上普遍找到的博客搭建教程以绑定顶级域名居多，个人感觉一个博客绑定一个顶级域名也太浪费了些，故寻找绑定二级域名的方法，并记录遇到的问题和解决方式。</p>
<span id="more"></span>
<p>需要了解域名的相关基础知识，可查看参考资料1。</p>
<h1>添加 CNAME文件</h1>
<p><strong>方式一：通过仓库设定添加 <code>CNAME</code> 文件</strong></p>
<ol>
<li>
<p>打开博客所在仓库，选择 <code>Setting</code>；</p>
</li>
<li>
<p>找到 GitHub Pages 设定条目，在 Custom domain 下输入你的二级域名，例如 <a href="http://blog.example.com">blog.example.com</a>，点击保存，该操作将发布源的根目录下创建一个 <code>CNAME</code> 文件；</p>
</li>
</ol>
<p><strong>方式二：手动添加 <code>CNAME</code> 文件</strong></p>
<ol>
<li>
<p>在仓库根目录下添加一个名为 <code>CNAME</code> 的文件，该文件名必须全部大写；</p>
</li>
<li>
<p>在该文件内写入你的二级域名，如 <a href="http://blog.example.com">blog.example.com</a>；</p>
</li>
</ol>
<p><strong>方式三：在本地手动添加 <code>CNAME</code>文件</strong></p>
<ol>
<li>
<p>在本地的博客目录<code>.\source\</code> 路径下创建一个 <code>CNAME</code> 文件；</p>
</li>
<li>
<p>在该文件内写入你的二级域名，如 <a href="http://blog.example.com">blog.example.com</a>；</p>
</li>
</ol>
<h1>添加 DNS 记录</h1>
<ol>
<li>
<p>打开域名服务商后台 DNS 管理；</p>
</li>
<li>
<p>添加一条 <code>CNAME</code> 记录，主机名即刚刚设定的二级域名，比如上面的 <a href="http://blog.example.com">blog.example.com</a> 即为 blog ，地址填写原来的 github 博客地址。</p>
</li>
</ol>
<h1>故障处理</h1>
<p>网上搜索到的零星教程配置完成了，但会发现在本地使用 <code>hexo d -g</code> 推送更新时产生错误，无法征程推送，在官方文档中找到了解决方案。</p>
<p>产生错误的原因在于本地构建博客推送的方式在静态博客渲染页面提交可能覆盖掉了 <code>CNAME</code> 文件。使用以下命令提交 <code>CNAME</code> 文件以免被覆盖：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add CNAME</span><br><span class="line">git commit -m  <span class="string">&quot;add CNAME file&quot;</span> </span><br></pre></td></tr></table></figure>
<p>再次尝试，问题应该已经解决，同时在仓库的设置页应该会显示一个提示 ”Your site is published at <a href="http://blog.example.com">http://blog.example.com</a> &quot; 。</p>
<p>设置页还提供了 HTTPS 选项，勾选该选项，可强制使用 HTTPS 协议访问，访问站点将变为 &quot;<a href="https://blog.example.com">https://blog.example.com</a> &quot; ，同时浏览器地址栏将不会提示该站点可能不安全。</p>
<p>至此，当访问 Github 提供的二级域名 <a href="http://user.github.io">user.github.io</a> 时将切换为自定义域名访问。</p>
<h1>参考资料</h1>
<ul>
<li>
<p><a href="http://winterttr.me/2015/10/23/from-dns-to-github-custom-domain/">从 DNS 到 github pages 自定义域名 – 漫谈域名那些事 | Life &amp; Note</a></p>
</li>
<li>
<p><a href="https://help.github.com/en/github/working-with-github-pages/managing-a-custom-domain-for-your-github-pages-site">Managing a custom domain for your GitHub Pages site - Github Help</a></p>
</li>
<li>
<p><a href="https://help.github.com/en/github/working-with-github-pages/troubleshooting-custom-domains-and-github-pages">Troubleshooting custom domains and GitHub Pages - Github Help</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>Blog-修改站点主题以及站点配置文件</title>
    <url>/zh-CN/Blog-change-blog-theme/</url>
    <content><![CDATA[<p>觉得官方的主题不太好看，Github上，Hexo官网上都有许多可供选择的主题，我这里使用<a href="http://theme-next.iissnan.com/">NexT</a>主题，本文介绍了修改主题的方法以及站点配置文件<code>_config.yml</code>的一些相关配置。</p>
<span id="more"></span>
<h1>改变主题</h1>
<h2 id="下载主题">下载主题</h2>
<p>新版本的NexT有两种下载方式：</p>
<ol>
<li>将需要的主题从Github下载（clone）到你的站点目录中</li>
<li>使用 npm 安装</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next&lt;</span></span><br></pre></td></tr></table></figure>
<p>#安装主题<br>
npm install hexo-theme-next@latest</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 修改站点配置文件</span><br><span class="line"></span><br><span class="line">修改你的站点配置文件`_config.yml`，找到如下字段，将`theme`后面的主题修改为`next`</span><br><span class="line"></span><br><span class="line">```yaml</span><br><span class="line"># Extensions</span><br><span class="line">## Plugins: https:<span class="comment">//hexo.io/plugins/</span></span><br><span class="line">## Themes: https:<span class="comment">//hexo.io/themes/</span></span><br><span class="line">theme: next</span><br></pre></td></tr></table></figure>
<h1>站点配置文件的设置</h1>
<h2 id="设置个人头像">设置个人头像</h2>
<p>个人头像将显示在侧边栏中。在<code>.\source</code>下创建一个<code>images</code>文件夹，将想要设置为头像的图片放于此文件夹中。修改<code>_config.yml</code>，在其中添加如下代码：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Head portrait</span></span><br><span class="line"><span class="attr">avatar:</span> <span class="string">/images/cat.jpg</span></span><br></pre></td></tr></table></figure>
<h2 id="设置站点的基本信息">设置站点的基本信息</h2>
<p>在<code>_config.yml</code>中找到如下字段，配置个人站点的基本信息，下面的出现位置举例基于NexT主题。</p>
 <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">（此处为站点名称，即左上角的名称）</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">（站点描述，将出现在侧边栏头像下方）</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">（作者，将出现在侧边栏头像下方，如果没有修改主题配置文件，同时会出现在网页下方）</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">（界面语言，简体字为zh-Hans）</span></span><br></pre></td></tr></table></figure>
<h1>设置置顶文章</h1>
<p>找到文件<code>node_modules\hexo-generator-index\lib\generator.js</code>，将文件内容修改为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> pagination = <span class="built_in">require</span>(<span class="string">&#x27;hexo-pagination&#x27;</span>);</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span>(<span class="params">locals</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> config = <span class="variable language_">this</span>.<span class="property">config</span>;</span><br><span class="line">  <span class="keyword">var</span> posts = locals.<span class="property">posts</span>;</span><br><span class="line">    posts.<span class="property">data</span> = posts.<span class="property">data</span>.<span class="title function_">sort</span>(<span class="keyword">function</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a.<span class="property">top</span> &amp;&amp; b.<span class="property">top</span>) &#123; <span class="comment">// 两篇文章top都有定义</span></span><br><span class="line">            <span class="keyword">if</span>(a.<span class="property">top</span> == b.<span class="property">top</span>) <span class="keyword">return</span> b.<span class="property">date</span> - a.<span class="property">date</span>; <span class="comment">// 若top值一样则按照文章日期降序排</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> b.<span class="property">top</span> - a.<span class="property">top</span>; <span class="comment">// 否则按照top值降序排</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a.<span class="property">top</span> &amp;&amp; !b.<span class="property">top</span>) &#123; <span class="comment">// 以下是只有一篇文章top有定义，那么将有top的排在前面</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!a.<span class="property">top</span> &amp;&amp; b.<span class="property">top</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> b.<span class="property">date</span> - a.<span class="property">date</span>; <span class="comment">// 都没定义按照文章日期降序排</span></span><br><span class="line">    &#125;);</span><br><span class="line">  <span class="keyword">var</span> paginationDir = config.<span class="property">pagination_dir</span> || <span class="string">&#x27;page&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">pagination</span>(<span class="string">&#x27;&#x27;</span>, posts, &#123;</span><br><span class="line">    <span class="attr">perPage</span>: config.<span class="property">index_generator</span>.<span class="property">per_page</span>,</span><br><span class="line">    <span class="attr">layout</span>: [<span class="string">&#x27;index&#x27;</span>, <span class="string">&#x27;archive&#x27;</span>],</span><br><span class="line">    <span class="attr">format</span>: paginationDir + <span class="string">&#x27;/%d/&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">      <span class="attr">__index</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>发布时需要置顶的文章在前面格式处配置，top值越大越前面:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line"><span class="section">top: 7</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure>
<h1>修改文章链接格式</h1>
<p>修改<code>permalink</code>样式可以改变自动生成的博文链接样式：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## If your site is put in a subdirectory, set url as &#x27;http://yoursite.com/child&#x27; and root as &#x27;/child/&#x27;</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">http://yoursite.com</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:title/</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br></pre></td></tr></table></figure>
<h1>参考资料</h1>
<ul>
<li><a href="http://theme-next.iissnan.com/getting-started.html">开始使用-NexT使用文档</a></li>
<li><a href="http://shenzekun.cn/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html">hexo的next主题个性化教程：打造酷炫网站|Moorez</a></li>
<li><a href="https://theme-next.js.org/docs/getting-started/">Getting Started | NexT</a></li>
</ul>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>NexT</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Blog-Hexo搭建</title>
    <url>/zh-CN/Blog-hexo-build/</url>
    <content><![CDATA[<p>在查找一些技术资料的时候总会看到一些漂亮的博客，喜欢文字，也想自己搭建起一个博客来。尽管在网上搜索到了许多Github+Hexo的博客搭建教程，但仍然也遇到了不少问题，几经折腾，终于可以使用，于是决定先写一篇我在Win10下的搭建过程作为记录和分享。（也可以参考<a href="https://hexo.io/zh-cn/docs/index.html">官方文档</a>，官方文档也写得挺详细。）</p>
<span id="more"></span>
<h1>环境准备</h1>
<ol>
<li>Node.js环境</li>
<li>Git</li>
</ol>
<h2 id="Node-js环境">Node.js环境</h2>
<p>在<a href="https://nodejs.org/en/">官网</a>下载与电脑系统相匹配的Node.js并安装。</p>
<p>也可以前往Nodejs的<a href="http://nodejs.cn/">中文网</a></p>
<h2 id="Git">Git</h2>
<p>前往<a href="https://git-scm.com/">官网</a>下载与你的电脑相对应版本的Git。安装完成后，你将会看到Git Bash在你的右键菜单中。</p>
<p>前往<a href="https://github.com/">Github官网</a>注册Github帐号，完成后创建一个仓库（New repository）。仓库名为<code>yourgitname.github.io</code></p>
<p>将电脑中的Git与Github帐号设置一致。</p>
<h3 id="Coding">Coding</h3>
<p>在<a href="https://coding.net/">Coding</a> 注册账号，新建项目，之后创建Coding-pages分支，并设置为默认分支，在左侧开启coding-page服务.</p>
<h2 id="安装HEXO">安装HEXO</h2>
<p>在电脑中新建一个文件夹，进入文件夹，右键，选择命令行或者直接选择<code>Git Bash Here</code> ，打开命令行窗口。</p>
<h3 id="使用npm安装Hexo">使用npm安装Hexo</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm install -g hexo-cli</span></span><br></pre></td></tr></table></figure>
<h1>开始搭建Blog</h1>
<h2 id="新建一个网站">新建一个网站</h2>
<p>安装完成后，初始化文件夹，无参数默认当前路径</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">初始化目录</span></span><br><span class="line">hexo init [foldername]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入目录</span></span><br><span class="line">cd [foldername]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装依赖</span></span><br><span class="line">npm install</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装部署插件</span></span><br><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<h2 id="新建一篇文章">新建一篇文章</h2>
<p>如果没有设置layout，默认为<code>default_layout</code> 参数（也就是<code>post</code>）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo new [layout] &lt;title&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="生成静态文件">生成静态文件</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo generate</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">可以简写为</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo g</span></span><br></pre></td></tr></table></figure>
<h2 id="启动服务器">启动服务器</h2>
<p>默认访问网址为<a href="http://localhost:4000/">http://localhost:4000/</a>，这时候别人是看不到你的网站的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo server</span></span><br></pre></td></tr></table></figure>
<h1>与Github关联</h1>
<h2 id="修改站点配置文件">修改站点配置文件</h2>
<p>打开<code>_config.yml</code> 文件，修改deploy</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/Yourgitname/your_reperoryname.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line">  <span class="comment"># ssh形式</span></span><br><span class="line">  <span class="comment">#repo : git@github.com:yourgitname/yourreperoryname.github.io.git</span></span><br><span class="line">  <span class="comment">#此处为之前创建仓库的仓库地址，在创建完成后有一个界面可以复制，或者直接复制网址加上.git</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@git.coding.net:codingname/projectname.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">coding-pages</span></span><br></pre></td></tr></table></figure>
<h2 id="部署网站">部署网站</h2>
<p>部署成功后，就可以通过yourgitname.github.io这个地址看到自己的博客了。Coding <a href="http://xn--youcodingname-vz2vi60dlha643uep5c.coding.me/projectname">的地址则是youcodingname.coding.me/projectname</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo deploy</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">可以简写为</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo d</span></span><br></pre></td></tr></table></figure>
<h2 id="Markdown-编辑器推荐">Markdown 编辑器推荐</h2>
<p>文件采用 Markdown 标记方式来实现文章的格式化，推荐两个编辑器：</p>
<ul>
<li>
<p><a href="https://www.typora.io/">Typora</a> (支持更多的导出格式)</p>
</li>
<li>
<p><a href="https://marktext.app/">Mark Text</a>（支持多标签页方式打开文件，可绿色安装不写注册表）</p>
</li>
</ul>
<h1>参考资料</h1>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/26625249">GitHub+Hexo搭建个人网站详细教程</a></li>
<li><a href="https://github.com/niices/blog/issues/7">Hexo部署个人博客到Github Page和Coding Page并绑定域名#7·niices/blog</a></li>
<li><a href="https://hexo.io/zh-cn/docs/setup.html">建站|Hexo</a></li>
</ul>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Blog-NexT主题配置文件配置</title>
    <url>/zh-CN/Blog-themes-config/</url>
    <content><![CDATA[<p>本文整理了NexT主题下通过配置主题<code>_config.yml</code>进行的相关配置。本文之前是针对v5早期版本写的，现对部分内容进行更新，删除线部分都是针对v5版本的，如果您使的仍然是 v5 版本，请参考删除线内的内容或者折叠起来的内容。本文目前还未完全部的更新，所以存在部分内容仍然是针对旧版的 NexT 的情况。</p>
<span id="more"></span>
<h1>修改配置文件</h1>
<p><s>进入路径<code>.\themes\next\</code>，修改主题下的配置文件<code>_config.yml</code></s></p>
<div class="note default"><p>该方式是早期版本的修改配置文件方式。</p>
</div>
<p>需要注意的是，YAML语言对格式的要求较为严格，如generate时出错可以使用<a href="http://nodeca.github.io/js-yaml/">YAML parser for JavaScript-JS-YAML</a>对自己的配置文件格式进行检查。或者可以查看<a href="http://www.ruanyifeng.com/blog/2016/07/yaml.html">YAML语言教程-阮一峰的网络日志</a>了解相关语法。</p>
<h1>选择外观</h1>
<p>NexT主题提供了不同的外观，默认是<code>Muse</code>，本站为<code>Gemini</code>。找到如下<code>Schemes</code>字段，去掉想实现的外观前的注释号</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Schemes</span></span><br><span class="line"><span class="comment">#scheme: Muse</span></span><br><span class="line"><span class="comment">#scheme: Mist</span></span><br><span class="line"><span class="comment">#scheme: Pisces</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Gemini</span></span><br></pre></td></tr></table></figure>
<h1>菜单和小图标</h1>
<p>菜单选项可以通过<code>_config.yml</code>中<code>menu</code>字段中的各项来控制，增加和删减菜单选项。菜单的小图标可以通过更改符号<code>||</code>后面的值来修改，后面的描述分别对应的是<a href="https://fontawesome.com/icons?d=gallery&m=free">Font Awesome</a>列出的小图标。</p>
<p><code>menu_icons</code>字段控制是否显示菜单小图标，默认为<code>false</code>。<code>badges</code>字段控制是否显示菜单小图标上的数字，即统计量，默认为<code>false</code>。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span></span><br><span class="line">  <span class="comment">#about: /about/ || user</span></span><br><span class="line">  <span class="comment">#tags: /tags/ || tags</span></span><br><span class="line">  <span class="comment">#categories: /categories/ || th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">archives</span></span><br><span class="line">  <span class="comment">#schedule: /schedule/ || calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || sitemap</span></span><br><span class="line">  <span class="comment">#commonweal: /404/ || heartbeat</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Enable/Disable menu icons. </span></span><br><span class="line"><span class="attr">menu_icons:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">badges:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h1>站点小图标</h1>
<p>修改站点小图标，默认为NexT图标，在<a herf="https://www.favicon-generator.org">Favicon &amp; App Icon Generator</a>可以上传自己的图片生成不同大小的图标。进入路径~~<code>./themes/next/source/images</code>~~<code>/source/images</code>，将原本NexT的图标替换为自己的图片，并在<code>_config.yml</code>中的如下字段将图片名称做相应的修改。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">favicon:</span></span><br><span class="line">  <span class="attr">small:</span> <span class="string">/images/favicon-16x16-next.png</span></span><br><span class="line">  <span class="attr">medium:</span> <span class="string">/images/favicon-32x32-next.png</span></span><br><span class="line">  <span class="attr">apple_touch_icon:</span> <span class="string">/images/apple-touch-icon-next.png</span></span><br></pre></td></tr></table></figure>
<h1>页脚设置</h1>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="attr">since:</span> <span class="number">2018</span></span><br><span class="line">  <span class="attr">icon:</span> <span class="string">heartbeat</span></span><br><span class="line">  <span class="attr">copyright:</span></span><br><span class="line">  <span class="attr">powered:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h2 id="显示建站年份">显示建站年份</h2>
<p>将<code>since</code>前的注释号去掉，并修改建站年份。</p>
<h2 id="修改页脚小图标">修改页脚小图标</h2>
<p><code>icon</code>后填写 <a href="https://fontawesome.com/icons?d=gallery&m=free">Font Awesome</a> 中自己喜欢的小图标，默认为心形。</p>
<h2 id="修改页脚作者名">修改页脚作者名</h2>
<p>修改<code>copyright</code>的值，默认为站点配置文件中的<code>author</code>的值。</p>
<h2 id="不显示“由Hexo强力驱动”">不显示“由Hexo强力驱动”</h2>
<p>将<code>powered</code>的值设置为<code>false</code>，默认为<code>true</code>。</p>
<h2 id="不显示NexT版本">不显示NexT版本</h2>
<p>将如下字段的值改为<code>false</code>，默认为<code>true</code>。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span></span><br><span class="line">  <span class="comment"># Theme &amp; scheme info link (Theme - NexT.scheme).</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Version info of NexT after scheme info (vX.X.X).</span></span><br><span class="line">  <span class="attr">version:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h1>侧边栏设置</h1>
<h2 id="设置侧边栏展开方式">设置侧边栏展开方式</h2>
<p>搜索字段<code>sidebar</code>，下面有这么几个选项：</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">#<span class="built_in">display</span>:post</span><br><span class="line">#<span class="built_in">display</span>:always</span><br><span class="line">#<span class="built_in">display</span>:hide</span><br><span class="line">#<span class="built_in">display</span>:<span class="built_in">remove</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>post</code> 表示在文章页面自动展开</li>
<li><code>always</code> 表示在所有页面自动展开</li>
<li><code>hide</code> 表示只有在点击侧边栏展开时才展开</li>
<li><code>remove</code> 表示不显示侧边栏及其图标<br>
需要哪种模式就将前面的注释符号<code>#</code>去掉。</li>
</ul>
<p>Mist 外观下侧边栏修改为左端参见：<a href = "https://fish-404.github.io/Blog-adjust-sidebar-nextmist-left/">Blog-调整NexT主题Mist外观侧边栏在左|在逃的貓</a></p>
<h2 id="设置侧边栏社交链接">设置侧边栏社交链接</h2>
<p>找到<code>social</code>字段，设置在侧边栏要显示的社交链接，记得要把<code>social</code>前的注释号去掉。<code>||</code>后面的是<a href="https://fontawesome.com/icons?d=gallery&m=free">Font Awesome</a>中的小图标，图标的显示设定在<code>social_icons</code>中设定。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="attr">E-Mail:</span> <span class="string">mailto:youremail</span> <span class="string">address</span> <span class="string">here||</span> <span class="string">envelope</span></span><br><span class="line"><span class="attr">social_icons:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">icons_only:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">transition:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h2 id="设置侧边栏背景">设置侧边栏背景</h2>
<p>找到<code>./themes/next/source/css/_custom</code>中的<code>custom.styl</code>文件，添入以下代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#sidebar</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">&quot;images/photo.jpg&quot;</span>);</span><br><span class="line">    <span class="attribute">background-size</span>: cover;</span><br><span class="line">    <span class="attribute">background-position</span>: center;</span><br><span class="line">    <span class="attribute">background-repeat</span>: no-repeat; </span><br><span class="line">    <span class="selector-tag">p</span>,<span class="selector-tag">span</span>,<span class="selector-tag">a</span> &#123;<span class="attribute">color</span>: <span class="number">#000000</span>;&#125;     <span class="comment">/* set the text color */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>修改背景为背景图片</p>
<p>代码如上所示，在路径中创建一个<code>images</code>文件夹，将背景图放置在文件夹中，为防止遮挡文字效果，可适当调整透明度。</p>
</li>
<li>
<p>修改背景为其他底色</p>
<p>添加一个<code>bacckground-color</code>选项，设置为需要的颜色。</p>
</li>
</ul>
<p><strong>小技巧</strong>：</p>
<p>可以在浏览器中按下<code>F12</code>开启开发者模式（本人使用的是Firefox），点击选取侧边栏部分查看代码，可以在此添加和修改各个选项实时查看效果，确定后再添加至代码中。</p>
<h1>开启数学公式显示</h1>
<p>在NexT主题下的配置文件<code>_config.yml</code>中找到<code>Third Party Services Settings</code>，找到 <code>MathJax Support</code>，将<code>enable</code>值修改为<code>true</code>:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># MathJax Support</span></span><br><span class="line"><span class="attr">mathjax:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">cdn:</span> <span class="string">//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML</span></span><br></pre></td></tr></table></figure>
<h1>添加评论系统</h1>
<details>
<summary>
早期的 Valine 评论系统(目前已不支持)
</summary>
<p>个人比较喜欢不需要登陆也能进行评论的系统，在浏览了一番资料后发现<code>Valine</code>简洁易用，正合我意。当前使用的<code>NexT</code>主题的配置文件中已经包含了<code>Valine</code>的设定，在<code>_config.yml</code>中找到<code>Third Party Services Settings</code>，在其中找到<code>Valine</code>，如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Valine.</span></span><br><span class="line"><span class="comment"># You can get your appid and appkey from https://leancloud.cn</span></span><br><span class="line"><span class="comment"># more info please open https://valine.js.org</span></span><br><span class="line"><span class="attr">valine:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">appid:</span>  <span class="comment"># your leancloud application appid</span></span><br><span class="line">  <span class="attr">appkey:</span>  <span class="comment"># your leancloud application appkey</span></span><br><span class="line">  <span class="attr">notify:</span> <span class="literal">true</span> <span class="comment"># mail notifier , https://github.com/xCss/Valine/wiki</span></span><br><span class="line">  <span class="attr">verify:</span> <span class="literal">true</span> <span class="comment"># Verification code</span></span><br><span class="line">  <span class="attr">placeholder:</span> <span class="comment"># comment box placeholder</span></span><br><span class="line">  <span class="attr">avatar:</span>  <span class="comment"># gravatar style</span></span><br><span class="line">  <span class="attr">guest_info:</span> <span class="string">nick,mail,link</span> <span class="comment"># custom comment header</span></span><br><span class="line">  <span class="attr">pageSize:</span> <span class="number">7</span> <span class="comment"># pagination size</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>enable</code>改为<code>true</code>；</li>
<li><code>appid</code>和<code>appkey</code>需要通过在 <a href="https://leancloud.cn/">LeanCloud(CN)</a> 或 <a href="https://console.leancloud.app/apps">LeanCloud(国际)</a> 创建一个应用获得，创建办法是先注册一个<code>LeanCloud</code>用户，创建一个应用，为这个应用取个名字，在应用侧边栏<code>设置</code>选项中找到<code>应用Key</code>选项，将提供的<code>App ID</code>与<code>App Key</code>复制到此配置文件中；</li>
<li><code>notify</code>将开启邮件通知，需要在<code>LeanCloud</code>中修改相关邮件设置，开启<code>notify</code>后，<code>verify</code>也将开启；</li>
<li><code>verify</code>设置评论是否需要验证码；</li>
<li><code>placeholder</code>设置评论框默认的显示语句，可自定义；</li>
<li><code>avatar</code>: 设置头像，<code>Valine</code>使用的是<code>Gravatar</code>来配置头像，（<a href="http://cn.gravatar.com/">Gravatar-全球公认的头像</a>），如果有<code>Gravatar</code>账号，在评论时使用注册<code>Gravatar</code>时留下的邮箱，评论时就将出现<code>Gravatar</code>设置的头像。该字段有多个选项，在并不与<code>Gravatar</code>关联的情况下可以选择其他头像(详情可参见 <a href="https://valine.js.org/avatar.html">头像配置|Valine</a> )：
<ul>
<li><code>''</code> ：Gravatar官方头像</li>
<li><code>mp</code> ：神秘人，一个灰白人头像</li>
<li><code>identicon</code> ：抽象几何图形</li>
<li><code>monsterid</code> ：小怪物</li>
<li><code>wavatar</code> ：用不同面孔和背景组合生成的头像</li>
<li><code>retro</code> ：八位像素复古头像</li>
<li><code>robohash</code> ：一种具有不同颜色、面部等的机器人</li>
<li><code>hide</code> ：不显示头像</li>
</ul>
</li>
<li><code>guest_info</code>：配置可供评论读者填写的个人信息选项；</li>
<li><code>pageSize</code> ：每页显示的评论数量。</li>
</ul>
</details>
<h2 id="Disqus">Disqus</h2>
<p>在 <a href="https://disqus.com/">Disqus</a> 点击 Get Started, 如果你是用第三方账号，选择 Publisher 直接登录也可以。跳过选择计划的页面，点击下面的 Get Started。注册完账号，按照提示信息填写即可。注意在选择平台的时候选择 “I don’t see my platform listed, install manually with Universal Code.” 完成后启用即可。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">disqus:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">shortname:</span> <span class="string">your-short-disqus-name</span></span><br><span class="line">  <span class="attr">count:</span> <span class="literal">true</span> <span class="comment"># 如果为 true，博客顶部会显示计数</span></span><br></pre></td></tr></table></figure>
<h2 id="畅言">畅言</h2>
<p>注册账号，按照提示信息填写即可。填写完成后，</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">changyan:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">appid:</span> <span class="comment"># 填写 APPID</span></span><br><span class="line">  <span class="attr">appkey:</span> <span class="comment"># 填写 APP SECRET</span></span><br><span class="line">  <span class="attr">count:</span> <span class="literal">true</span> <span class="comment"># 如果为 true，博客顶部会显示计数</span></span><br></pre></td></tr></table></figure>
<h2 id="来必力">来必力</h2>
<p>注册完成后，在后台的 Code Managing 里面看到类似下面这段代码，把第2行的 <code>data-uid</code>后面引号内的内容全部复制，填写到 NexT 的 <code>livere_uid</code> 即可。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- LiveRe City install code --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;lv-container&quot;</span> <span class="attr">data-id</span>=<span class="string">&quot;city&quot;</span> <span class="attr">data-uid</span>=<span class="string">&quot;example-id&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">   (<span class="keyword">function</span>(<span class="params">d, s</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">       <span class="keyword">var</span> j, e = d.<span class="title function_">getElementsByTagName</span>(s)[<span class="number">0</span>];</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">       <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="title class_">LivereTower</span> === <span class="string">&#x27;function&#x27;</span>) &#123; <span class="keyword">return</span>; &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">       j = d.<span class="title function_">createElement</span>(s);</span></span><br><span class="line"><span class="language-javascript">       j.<span class="property">src</span> = <span class="string">&#x27;https://cdn-city.livere.com/js/embed.dist.js&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">       j.<span class="property">async</span> = <span class="literal">true</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">       e.<span class="property">parentNode</span>.<span class="title function_">insertBefore</span>(j, e);</span></span><br><span class="line"><span class="language-javascript">   &#125;)(<span class="variable language_">document</span>, <span class="string">&#x27;script&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">noscript</span>&gt;</span>Please activate JavaScript for write a comment in LiveRe<span class="tag">&lt;/<span class="name">noscript</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- completed City install code --&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">livere_uid:</span> <span class="string">your_uid</span></span><br></pre></td></tr></table></figure>
<h2 id="Utterances">Utterances</h2>
<p>这个评论系统要求你的仓库必须是公开的，如果你是采用类似我的方式，源文件不公开，在一个仓库，通过其他的比如 Netlify 部署，那可能你还需要再搞一个通过 github page 部署的，就是相当于部署两份。</p>
<p>你需要先安装一下<a href="https://github.com/apps/utterances">GitHub Apps - utterances</a>。选择授权你的仓库。<br>
然后再配置相关参数，具体的参数可以看 Utteranc 的介绍，我只尝试了 pathname 的参数。<br>
值得注意的是，同样基于 Github issue 的评论系统 Gittalk，如果你是基于 Netlify 部署，又基于 github 部署，但是主站是 Netlify，似乎是行不通的，如果你是这种情况，建议你使用 Utterances。或者再看下源码研究下。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Utterances</span></span><br><span class="line"><span class="comment"># For more information: https://utteranc.es</span></span><br><span class="line"><span class="attr">utterances:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">user-name/repo-name</span> <span class="comment"># Github repository owner and name</span></span><br><span class="line">  <span class="comment"># Available values: pathname | url | title | og:title</span></span><br><span class="line">  <span class="attr">issue_term:</span> <span class="string">pathname</span></span><br><span class="line">  <span class="comment"># Available values: github-light | github-dark | preferred-color-scheme | github-dark-orange | icy-dark | dark-blue | photon-dark | boxy-light</span></span><br><span class="line">  <span class="attr">theme:</span> <span class="string">github-light</span></span><br></pre></td></tr></table></figure>
<h1>添加顶部加载提示</h1>
<p>在<code>_config.yml</code>文件中找到<code>pace</code>字段，设置为<code>true</code>，在下面的样式中进行选择，建议可以修改后先不提交，使用<code>hexo s</code>预览效果，觉得合适再提交，本站使用的是<code>pace-theme-bounce</code>右上角有一个蓝色的弹跳小球，随着博文的加载，弹跳小球将逐渐消失。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Progress bar in the top during page loading.</span></span><br><span class="line"><span class="attr">pace:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># Themes list:</span></span><br><span class="line"><span class="comment">#pace-theme-big-counter</span></span><br><span class="line"><span class="comment">#pace-theme-bounce</span></span><br><span class="line"><span class="comment">#pace-theme-barber-shop</span></span><br><span class="line"><span class="comment">#pace-theme-center-atom</span></span><br><span class="line"><span class="comment">#pace-theme-center-circle</span></span><br><span class="line"><span class="comment">#pace-theme-center-radar</span></span><br><span class="line"><span class="comment">#pace-theme-center-simple</span></span><br><span class="line"><span class="comment">#pace-theme-corner-indicator</span></span><br><span class="line"><span class="comment">#pace-theme-fill-left</span></span><br><span class="line"><span class="comment">#pace-theme-flash</span></span><br><span class="line"><span class="comment">#pace-theme-loading-bar</span></span><br><span class="line"><span class="comment">#pace-theme-mac-osx</span></span><br><span class="line"><span class="comment">#pace-theme-minimal</span></span><br><span class="line"><span class="comment"># For example</span></span><br><span class="line"><span class="comment"># pace_theme: pace-theme-center-simple</span></span><br><span class="line"><span class="attr">pace_theme:</span> <span class="string">pace-theme-bounce</span></span><br></pre></td></tr></table></figure>
<h1>添加网易云音乐插件</h1>
<p>新建一个歌单，在网页版中点击生成外链播放器，此时可以选择大小，以及是否自动播放，将生成的代码插入到侧边栏的配置文件中<code>themes/next/layout/_macro/sidebar.swig</code>，插入位置应该在<code>&lt;aside&gt;,&lt;/aside&gt;</code>之内，否则音乐播放器是在页面末尾实现：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;music163player&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">frameborder</span>=<span class="string">&quot;no&quot;</span> <span class="attr">border</span>=<span class="string">&quot;0&quot;</span> <span class="attr">marginwidth</span>=<span class="string">&quot;0&quot;</span> <span class="attr">marginheight</span>=<span class="string">&quot;0&quot;</span> <span class="attr">width</span>=<span class="string">330</span> <span class="attr">height</span>=<span class="string">110</span> <span class="attr">src</span>=<span class="string">&quot;//music.163.com/outchain/player?type=0&amp;id=2339687903&amp;auto=0&amp;height=90&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1>修改文末标签“#”图样</h1>
<details>
<summary>
早期版的修改方式。
</summary>
<p>打开文件<code>themes\next\layout\_macro\post.swig</code>，找到<code>rel=&quot;tag&quot;&gt;#</code>，将<code>#</code>用<code>&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;</code>进行替换。</p>
</details>
<h1>添加字数统计</h1>
<p>执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-wordcount --save</span><br></pre></td></tr></table></figure>
<p>在<code>themes\next\_config.yml</code>文件中查找<code>wordcount</code>，在下面的配置中选择配置项：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Post wordcount display settings</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/willin/hexo-wordcount</span></span><br><span class="line"><span class="attr">post_wordcount:</span></span><br><span class="line">  <span class="attr">item_text:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">wordcount:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">min2read:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">totalcount:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">separated_meta:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h1>添加站内搜索</h1>
<details>
<summary>
旧版本的 NexT 主题添加站内搜索
</summary>
<p>在<code>themes\next\_config.yml</code>文件中查找<code>local_search</code>，在下面的配置中启用和配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Local search</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/flashlab/hexo-generator-search</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># if auto, trigger search by changing input</span></span><br><span class="line">  <span class="comment"># if manual, trigger search by pressing enter key or search button</span></span><br><span class="line">  <span class="attr">trigger:</span> <span class="string">auto</span></span><br><span class="line">  <span class="comment"># show top n results per article, show all results by setting to -1</span></span><br><span class="line">  <span class="attr">top_n_per_article:</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
</details>
<ol>
<li>安装插件</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>添加 Hexo 配置</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">content:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>配置 NexT 主题</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Local Search</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/next-theme/hexo-generator-searchdb</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Show top n results per article, show all results by setting to -1</span></span><br><span class="line">  <span class="attr">top_n_per_article:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># Unescape html strings to the readable one.</span></span><br><span class="line">  <span class="attr">unescape:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Preload the search data when the page loads.</span></span><br><span class="line">  <span class="attr">preload:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h1>添加404页面</h1>
<p>使用以下语句创建 404 页面。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page 404</span><br></pre></td></tr></table></figure>
<p>该命令会在 source 目录下创建 <a href="http://404.md">404.md</a> 文件，编辑该文件，添加你需要的内容。</p>
<p>如果你使用的是 Netlify 部署，需要在 Netlify 的配置文件中添加 404 的配置，类似以下字段：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[[redirects]]</span></span><br><span class="line"><span class="attr">from</span> = <span class="string">&quot;/*&quot;</span></span><br><span class="line"><span class="attr">to</span> = <span class="string">&quot;/404&quot;</span></span><br><span class="line"><span class="attr">status</span> = <span class="number">404</span></span><br></pre></td></tr></table></figure>
<h1>参考资料</h1>
<ul>
<li><a href="http://theme-next.iissnan.com/getting-started.html">开始使用-NexT使用文档</a></li>
<li><a href="https://github.com/iissnan/hexo-theme-next/wiki/%E5%BC%80%E5%90%AF%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E6%98%BE%E7%A4%BA">开启数学公式显示· iissnan/hexo-theme-next Wiki · GitHub</a></li>
<li><a href="https://valine.js.org/">介绍|Valine</a></li>
<li><a href="http://shenzekun.cn/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html">hexo的next主题个性化教程：打造酷炫网站|Moorez</a></li>
<li><a href="http://mashirosorata.vicp.io/HEXO-NEXT%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE.html">HEXO+NEXT主题个性化配置|SORA</a></li>
<li><a href="https://theme-next.js.org/docs/third-party-services/search-services#Local-Search">Search Services | NexT</a></li>
<li><a href="https://theme-next.js.org/docs/theme-settings/custom-pages.html?highlight=404#Custom-404-Page">Custom Pages | NexT</a></li>
<li><a href="https://answers.netlify.com/t/custom-404-page-handling/76745/7">Custom 404 page handling - Support - Netlify Support Forums</a></li>
<li><a href="https://theme-next.js.org/docs/third-party-services/comments.html">Comment Systems | NexT</a></li>
<li><a href="https://utteranc.es/">utterances</a></li>
</ul>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言中的宏及与函数的比较</title>
    <url>/zh-CN/C-marco-and-function/</url>
    <content><![CDATA[<p>本文介绍C语言中的宏定义，并比较宏与函数的异同。</p>
<span id="more"></span>
<p>编译一个C程序的第一个步骤称为预处理(preprocessing)阶段。在此阶段下，由<code>#define</code>指令定义的符号将被替换。</p>
<h1>简单的宏</h1>
<p>简单的宏（对象式宏）的定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> name stuff</span></span><br></pre></td></tr></table></figure>
<p>使用该指令，可以将任何文本替换到程序中，预处理器遇到一个宏定义时，会将<code>name</code>用<code>stuff</code>进行替换。<code>stuff</code>可以包括标识符、关键字、数值常量、字符常量、字符串字面量、操作符和排列。</p>
<p>通常，我们会在以下两种情况下用宏来为常量命名，替代字符或字符串字面量：</p>
<ul>
<li>常量被不止一次地使用</li>
<li>常量日后可能需要修改</li>
</ul>
<p>可以用<code>#undef name</code>指令移除一个宏定义。</p>
<h2 id="使用-define为常量命名的优点">使用<code>#define</code>为常量命名的优点</h2>
<ul>
<li>
<p><strong>程序更易读</strong></p>
<p>帮助读者理解常量的意义，免于受大量「魔法数」的困惑。</p>
</li>
<li>
<p><strong>程序更易修改</strong></p>
<p>仅需要改变一个宏定义，就可以改变程序中出现的所有常量值。对比「硬编码」常量，若在大型程序中多处出现，修改时很可能漏掉某处。</p>
</li>
<li>
<p><strong>避免前后不一致或键盘输入错误</strong></p>
<p>例如数值常量$\pi$的值。</p>
</li>
<li>
<p><strong>可以对C语法进行修改</strong></p>
<p>对于习惯使用其他编程语言的程序员可以使用宏定义来修改语法。但，修改语法并不是个好主意，会使程序难被其他程序员理解，并且可能造成混淆，使可读性下降。<em>避免用<code>#define</code>创建新语言。</em></p>
</li>
<li>
<p><strong>对类型重命名</strong></p>
</li>
<li>
<p><strong>控制条件编译</strong></p>
</li>
</ul>
<h2 id="指令的规则">指令的规则</h2>
<p>以下规则也适用于其他预处理指令。</p>
<ul>
<li>
<p><strong>指令以<code>#</code>开始</strong></p>
<p><code>#</code>符号不需要出现在一行的行首，只要之前有空白字符就行。在<code>#</code>后是指令名，接着是指令所需要的其他信息。</p>
</li>
<li>
<p><strong>指令总是在第一个换行符处结束，除非明确指明要延续</strong></p>
<p>如果想要在下一行延续指令，必须在当前行末尾使用<code>\</code>字符。</p>
<p>利用相邻字符串常量被自动链接为一个字符串的特性，可以使用如下声明来调试一个存在许多涉及一组变量的不同计算过程的程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG_PRINT printf(<span class="string">&quot;File %s line %d:&quot;</span> \ </span></span><br><span class="line">						<span class="string">&quot;x = %d, y = %d, z = %d&quot;</span>, \ </span><br><span class="line">						__FILE__, __LINE__, \ </span><br><span class="line">						x, y, z)</span><br></pre></td></tr></table></figure>
<p><em>注意</em>：为避免出错，不要在末尾放置分号。</p>
<p>使用此调试语句示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">x *= <span class="number">2</span>;</span><br><span class="line">y += x; </span><br><span class="line">z = x * y;</span><br><span class="line">DEBUG_PRINT;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><strong>指令可以出现在程序中的任何地方</strong></p>
<p>我们常将<code>#define</code>指令放在文件的开始。</p>
</li>
<li>
<p><strong>注释可以与指令放在同一行</strong></p>
<p>在宏定义后面加一个注释来解释宏的含义是一种好习惯。</p>
</li>
</ul>
<h1>带参数的宏</h1>
<p><code>#define</code>机制允许将参数替换到文本中，称为带参数的宏/函数式宏/定义宏：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> name(paramter-list) stuff</span></span><br></pre></td></tr></table></figure>
<p>为了区分带参数宏和函数，通常使用大写来命名宏。</p>
<p>带参数宏常用于执行简单的函数，如：</p>
<ol>
<li>
<p>求两数最大值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(x, y) ((x)&gt;(y)?(x):(y)</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>判断奇偶性</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IS_EVEN(n) ((n) % 2 == 0）</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>交换两个数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SWAP(x, y, t) ((t) = (x), (x) = (y), (y) = (t)</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>带参数的宏不仅适用于模拟函数调用，也经常用作需要重复书写的代码段，如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MALLOC(n, type)\</span></span><br><span class="line"><span class="meta">		((type *)malloc((n) * sizeof(type)))</span></span><br></pre></td></tr></table></figure>
<h2 id="带参数宏与函数的比较">带参数宏与函数的比较</h2>
<h3 id="执行速度">执行速度</h3>
<p>程序执行时调用/返回函数通常会有额外开销，包括存储上下文信息、复制参数值等。</p>
<p>调用宏则没有这些运行开销。</p>
<h3 id="代码长度">代码长度</h3>
<p>每一处宏调用都会导致插入宏的替换列表，由此导致程序源代码增加，编译后的代码也变大。</p>
<p>函数调用的函数代码仅出现于一个地方：每次使用函数，调用同一份代码。</p>
<p><em>如果相同的代码需要出现在程序的几个地方，更好的方法是实现为一个函数。避免用<code>#define</code>指令定义可以用函数实现的长序列代码。</em></p>
<h3 id="参数求值">参数求值</h3>
<p>参数每次用于宏定义时，都将重新求值。因此宏可能会不止一次地计算它的参数，由于多次求值，具有副作用的参数可能会产生不可预料的结果。</p>
<p>参数在函数被调用前只求值一次，在函数中多次使用参数不会导致多种求值过程。</p>
<p>考虑上面的求两数最值的一种使用情况：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">x = <span class="number">5</span>;</span><br><span class="line">y = <span class="number">8</span>;</span><br><span class="line">z = MAX(x++, y++);</span><br></pre></td></tr></table></figure>
<p>宏替换后产生以下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">z = ((x++) &gt; (y++) ? (x++) : (y++));</span><br></pre></td></tr></table></figure>
<p>较小的值增加了一次，而较大的值却增加了两次，第一次在比较时，第二次在执行后面的表达式时，因此此时得到的结果是<code>x = 6, y = 10, z = 9</code>。</p>
<h3 id="操作符优先级">操作符优先级</h3>
<p>宏参数的求值是在所有周围表达式的上下文环境里，邻近操作符的优先级可能会产生不可预料的结果</p>
<p>函数只在函数调用时求值一次，结果值传递给函数，表达式的求值结果更容易预测。</p>
<p>考虑以下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SQUARE(x)</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, SQUARE(a + <span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<p>宏定义后产生的代码为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a + <span class="number">1</span> * a + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>表达式没有按照预想的次序求值。</p>
<p><strong>注意</strong>：<em>所有用于对数值表达式进行的宏定义都应该在宏定义每个参数周围加上括号，且在整个宏定义的两边也加上括号。</em></p>
<h3 id="参数类型">参数类型</h3>
<p>宏与类型无关，只要对参数的操作何发，可以用于任何类型参数。</p>
<p>函数与类型有关，函数类型不同，需要使用不同函数，即使执行任务相同。</p>
<p>例如上面举例的<code>MAX</code>宏，可以接受多种类型数：<code>int</code>, <code>long</code>, <code>float</code>, <code>double</code>等。</p>
<p>例如上面举例的<code>MALLOC</code>宏，<code>type</code>参数是一种类型，无法作为函数参数进行传递。</p>
<h1>参考资料</h1>
<ul>
<li>《C语言程序设计现代方法（第2版）》</li>
<li>《C和指针》</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>Program</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言中的转义序列</title>
    <url>/zh-CN/C-program-escape-sequence/</url>
    <content><![CDATA[<p>前些天有师弟问起关于C语言中转义序列的问题，尤其提到了<code>\?</code>这个转义字符，因为记得<code>??</code>似乎是三元字符集的开头，应该也算是特殊字符，但记得并不太清楚，于是搜寻了些资料，和转义序列的问题一并作整理和记录。</p>
<span id="more"></span>
<h1>转义序列 (escape sequence)</h1>
<p>首先，我们知道，在C语言中，字符常量使用单引号括起来表示，但并不是所有的字符都可以直接由键盘输入而表示出来，比如换行符，也就无法用这样的方式来书写。通常来说有这样两种无法用这种方式表示的字符，一是非打印字符，如换行符，一是特殊字符，键盘上并没有直接的键位可以录入。这时候就需要用到转义序列来表示，字符转义序列和数字转义序列。</p>
<h2 id="字符转义序列-charatcter-escape">字符转义序列 (charatcter escape)</h2>
<p>字符转义序列即我们常见的如<code>\n</code>表示换行符这样，下面给出字符转义序列表：</p>
<table>
<thead>
<tr>
<th>转义序列</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>\'</code></td>
<td style="text-align:left">单引号</td>
</tr>
<tr>
<td><code>\&quot;</code></td>
<td style="text-align:left">双引号</td>
</tr>
<tr>
<td><code>\?</code></td>
<td style="text-align:left">问号</td>
</tr>
<tr>
<td><code>\</code></td>
<td style="text-align:left">反斜杠</td>
</tr>
<tr>
<td><code>\a</code></td>
<td style="text-align:left">响铃</td>
</tr>
<tr>
<td><code>\b</code></td>
<td style="text-align:left">退格</td>
</tr>
<tr>
<td><code>\f</code></td>
<td style="text-align:left">换页</td>
</tr>
<tr>
<td><code>\n</code></td>
<td style="text-align:left">换行</td>
</tr>
<tr>
<td><code>\r</code></td>
<td style="text-align:left">回车</td>
</tr>
<tr>
<td><code>\t</code></td>
<td style="text-align:left">水平制表符</td>
</tr>
<tr>
<td><code>\v</code></td>
<td style="text-align:left">垂直制表符</td>
</tr>
</tbody>
</table>
<p>这里我们看到前四个都是符号，而除了问号以外，其他三个符号因为在C语言中有其他的作用，为了避免两者混淆，我们需要用转义序列来表示，那么为什么问号也需要呢，这就是我们后面要提到的三元字符序列，这里先按下不表。</p>
<h2 id="数字转义序列-numberic-escape">数字转义序列 (numberic escape)</h2>
<p>虽然字符转义序列已经可以表示出一些无法打印的字符，但并仍然没法包含所有无法打印的 ASCII 字符，而我们通过查阅 <a href="http://www.asciitable.com/">ASCII 字符集</a>中字符编号，就可以使用数字转义序列来表示这些字符，就好比我们每个人都有一个身份证号，用身份证号就可以表示我们这个人的身份一样。</p>
<h3 id="八进制转义序列">八进制转义序列</h3>
<p>$\verb||NUMBER_{(8)}$</p>
<ul>
<li>NUMBER 为一不超过三位数字的八进制数;</li>
<li>NUMBER 需表示为无符号字符，最大值通常是$337_{(8)}$;</li>
<li>转义序列中的八进制数不一定要用 0 开头.</li>
</ul>
<h3 id="十六进制转义序列">十六进制转义序列</h3>
<p>$\verb|\x|NUMBER_{(16)}$</p>
<ul>
<li>NUMBER 为一十六进制数;</li>
<li>NUBMBER 需表示为无符号字符（若字符长度为 8 位，则不能超过 FF）;</li>
<li>字符 x 必须为小写;</li>
<li>NUMBER 不限大小写;<br>
当作为字符常量使用时，转义序列必须用一对单引号括起来，而采用数字转义序列的方式来表示某个字符常量可能会使代码的可读性降低，可以使用<code>#define</code>宏定义的方式进行命名：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ESC <span class="string">&#x27;\33&#x27;</span> <span class="comment">/* ASCII escape character */</span></span></span><br></pre></td></tr></table></figure>
<h1>三字符序列 (trigraph sequence)</h1>
<p>前面我们提到了问号这个特殊字符也需要一个转义序列是由于三字符序列的存在。在欧洲的某些老式键盘提供的使欧洲语言所使用的古老字符，键盘上缺少 C 语言需要的字符，因此引入了三字符来解决这一问题。</p>
<p>三字符序列是一种三字符码，所有的三字符都以<code>??</code>开始，下面是三字符序列表：</p>
<table>
<thead>
<tr>
<th>三字符序列</th>
<th style="text-align:left">等价的 ASCII码</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>??=</code></td>
<td style="text-align:left">#</td>
</tr>
<tr>
<td><code>??(</code></td>
<td style="text-align:left">[</td>
</tr>
<tr>
<td><code>??/</code></td>
<td style="text-align:left">\</td>
</tr>
<tr>
<td><code>??'</code></td>
<td style="text-align:left">^</td>
</tr>
<tr>
<td><code>??&lt;</code></td>
<td style="text-align:left">{</td>
</tr>
<tr>
<td><code>??!</code></td>
<td style="text-align:left">}</td>
</tr>
<tr>
<td><code>??&gt;</code></td>
<td style="text-align:left">~</td>
</tr>
</tbody>
</table>
<p>例如，我们在学习编程时学习的第一个程序 Hello, world 就可以用三字符写成下面的形式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">??=include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main(<span class="type">void</span>)</span><br><span class="line">??&lt;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, world??/n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> ??&gt;</span><br></pre></td></tr></table></figure>
<p>遵循 C89 或 C99 标准的编译器都必须能接受三字符，所以上面这段程序是能够通过编译并执行的，混杂三字符和正常字符表示也是可以的。这也就是说，我们在字符串中放置<code>??</code>，有一定几率会因为三字符而导致问题，因为编译器可能会将其视为三字符的开始标志。如果发生这种情况，我们可以在第二个<code>?</code>字符前面放置<code>\</code>把第二个字符<code>?</code>变成转义序列，即<code>?\?</code>，这样就不会被看作是三字符的开始了，这也是为什么在字符串中直接使用<code>?</code>是可以输出的，但转义序列中却包含<code>\?</code>。不过在我的几次尝试中，发现，编译器通常会在碰到疑似三字符出现的情况下出现 warning，提示你三字符被忽略，如果需要启用三字符，需要添加<code>-trigraphs</code>编译选项，添加了编译选项后就可以正常使用三字符了，虽然通常我们很少用及。</p>
<h1>参考资料</h1>
<ul>
<li>《C语言程序设计现代方法（第 2 版）》</li>
<li><a href="https://zh.cppreference.com/w/c/language/escape">转义序列 - cppreference.com</a></li>
</ul>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>Program</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo NexT 多语言支持</title>
    <url>/zh-CN/Blog-hexo-next-i18n-support/</url>
    <content><![CDATA[<p>本文详述如何配置 Hexo NexT 多语言支持。</p>
<span id="more"></span>
<p>Hexo 的默认 Index 生成插件 <a href="https://github.com/hexojs/hexo-generator-index">hexojs/hexo-generator-index: Index generator plugin for Hexo.</a> 目前不支持生成多语言版本的 Index 。搜索解决方案的时候有发现这个插件 <a href="https://github.com/xcatliu/hexo-generator-index-i18n">xcatliu/hexo-generator-index-i18n: I18n index generator plugin for Hexo</a>，它可以为各个语言生成自己的 Index，但如果需要为默认首页设置默认语言则与官方的 Index 插件不兼容，是在早期版本的基础上开发的，缺少<code>hidden</code>, <code>top</code> 的特性。因此我把这两个插件进行了结合，已经提交 <a href="https://github.com/hexojs/hexo-generator-index/pull/143">PR</a>，未被合并，需要多语言的可以参考以下设置。</p>
<h1>使用本地插件生成 index</h1>
<ol>
<li>新建插件目录</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p plugins/hexo-generator-index</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>复制原来的插件到本地</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> -r node_modules/hexo-generator-index/* plugins/hexo-generator-index/</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>修改 <code>package.json</code> 引用路径</li>
</ol>
<figure class="highlight diff"><figcaption><span>package.json</span></figcaption><table><tr><td class="code"><pre><span class="line">&quot;dependencies&quot;: &#123;</span><br><span class="line"><span class="deletion">-     &quot;hexo-generator-index&quot;: &quot;^4.0.0&quot;,</span></span><br><span class="line">    ……</span><br><span class="line"><span class="addition">+     &quot;hexo-generator-index&quot;: &quot;file:./plugins/hexo-generator-index&quot;,</span></span><br><span class="line">    ……</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>修改插件代码，需要修改两个地方，一个是 <code>index.js</code>， 一个是 <code>lib/generator.js</code></li>
</ol>
<figure class="highlight diff"><figcaption><span>index.js</span></figcaption><table><tr><td class="code"><pre><span class="line">&#x27;use strict&#x27;;</span><br><span class="line"></span><br><span class="line">hexo.config.index_generator = Object.assign(&#123;</span><br><span class="line">  per_page: typeof hexo.config.per_page <span class="comment">=== &#x27;undefined&#x27; ? 10 : hexo.config.per_page,</span></span><br><span class="line">  order_by: &#x27;-date&#x27;,</span><br><span class="line">  layout: [&#x27;index&#x27;, &#x27;archive&#x27;],</span><br><span class="line"><span class="addition">+  single_lang_index: false</span></span><br><span class="line">&#125;, hexo.config.index_generator);</span><br><span class="line"></span><br><span class="line">hexo.extend.generator.register(&#x27;index&#x27;, require(&#x27;./lib/generator&#x27;));</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><figcaption><span>lib/generator.js</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pagination = <span class="built_in">require</span>(<span class="string">&#x27;hexo-pagination&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">generateIndexPage</span>(<span class="params">indexPath, posts, config</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> paginationDir = config.<span class="property">index_generator</span>.<span class="property">pagination_dir</span> || config.<span class="property">pagination_dir</span> || <span class="string">&#x27;page&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">pagination</span>(indexPath, posts, &#123;</span><br><span class="line">    <span class="attr">perPage</span>: config.<span class="property">index_generator</span>.<span class="property">per_page</span>,</span><br><span class="line">    <span class="attr">layout</span>: config.<span class="property">index_generator</span>.<span class="property">layout</span> || [<span class="string">&#x27;index&#x27;</span>, <span class="string">&#x27;archive&#x27;</span>],</span><br><span class="line">    <span class="attr">format</span>: paginationDir + <span class="string">&#x27;/%d/&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">      <span class="attr">__index</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span>(<span class="params">locals</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> config = <span class="variable language_">this</span>.<span class="property">config</span>;</span><br><span class="line">  <span class="keyword">const</span> posts = locals.<span class="property">posts</span>.<span class="title function_">filter</span>(<span class="function"><span class="params">post</span> =&gt;</span> !post.<span class="property">hidden</span>).<span class="title function_">sort</span>(config.<span class="property">index_generator</span>.<span class="property">order_by</span>);</span><br><span class="line"></span><br><span class="line">  posts.<span class="property">data</span>.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> (b.<span class="property">sticky</span> || <span class="number">0</span>) - (a.<span class="property">sticky</span> || <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> indexPath = config.<span class="property">index_generator</span>.<span class="property">path</span> || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">const</span> langs = [].<span class="title function_">concat</span>(config.<span class="property">language</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (langs.<span class="property">length</span> &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">generateIndexPage</span>(indexPath, posts, config);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Generate default index page</span></span><br><span class="line">  <span class="keyword">let</span> indexPages = <span class="title function_">generateIndexPage</span>(</span><br><span class="line">    indexPath,</span><br><span class="line">    config.<span class="property">index_generator</span>.<span class="property">single_lang_index</span> ? posts.<span class="title function_">filter</span>(<span class="function"><span class="params">post</span> =&gt;</span> post.<span class="property">lang</span> === langs[<span class="number">0</span>]) : posts,</span><br><span class="line">    config</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Generate index pages for each language</span></span><br><span class="line">  indexPages = [].<span class="title function_">concat</span>(</span><br><span class="line">    indexPages,</span><br><span class="line">    ...langs.<span class="title function_">map</span>(<span class="function"><span class="params">lang</span> =&gt;</span> <span class="title function_">generateIndexPage</span>(</span><br><span class="line">      path.<span class="title function_">join</span>(lang, indexPath),</span><br><span class="line">      posts.<span class="title function_">filter</span>(<span class="function"><span class="params">post</span> =&gt;</span> post.<span class="property">lang</span> === lang),</span><br><span class="line">      config</span><br><span class="line">    ))</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> indexPages;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>在 <code>_config.yml</code> 中添加多语言配置，<code>single_lang_index</code> 为 true 时，首页只生成第一个语言的文章，默认配置则为 <code>false</code></li>
</ol>
<figure class="highlight nestedtext"><table><tr><td class="code"><pre><span class="line"><span class="attribute">language</span><span class="punctuation">: </span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">zh-CN</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">en</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">permalink</span><span class="punctuation">:</span> <span class="string">:lang/:title/</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">new_post_name</span><span class="punctuation">:</span> <span class="string">:lang/:title.md </span></span><br><span class="line"></span><br><span class="line"><span class="attribute">index_generator</span><span class="punctuation">:</span></span><br><span class="line">  <span class="attribute">path</span><span class="punctuation">:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="attribute">per_page</span><span class="punctuation">:</span> <span class="string">7</span></span><br><span class="line">  <span class="attribute">order_by</span><span class="punctuation">:</span> <span class="string">-date</span></span><br><span class="line">  <span class="attribute">single_lang_index</span><span class="punctuation">:</span> <span class="string">true</span></span><br></pre></td></tr></table></figure>
<ol start="6">
<li>配置<code>_config.next.yml</code></li>
</ol>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line"><span class="params">language_switcher:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<ol start="7">
<li>post 文章结构如下：</li>
</ol>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">└── workspace<span class="symbol">/</span></span><br><span class="line">    └── source<span class="symbol">/</span></span><br><span class="line">        ├── _posts<span class="symbol">/</span></span><br><span class="line">        │   ├── zh-CN<span class="symbol">/</span></span><br><span class="line">        │   │   ├── welcome.md</span><br><span class="line">        │   │   ├── blogpost.md</span><br><span class="line">        │   │   └── ...</span><br><span class="line">        │   └── en<span class="symbol">/</span></span><br><span class="line">        │       ├── welcome.md</span><br><span class="line">        │       ├── blogpost.md</span><br><span class="line">        │       └── ...</span><br></pre></td></tr></table></figure>
<p>配置完成后，就可以对应生成 <code>/</code> 的默认主页，<code>/en</code> 只生成英语文章的 index 页， <code>/zh-CN</code> 只生成中文文章的 index 页。</p>
<h1>修改 NexT 的语言转换器配置</h1>
<p>NexT 的语言转换器默认行为是，转换语言如果是到默认语言，也就是第一个语言的时候，不会带 <code>:lang</code> 路径，这样如果按照上面的 <code>permalink</code>配置会导致切换语言时路径丢失。我们使用 <code>patch-package</code> 来实现变更。</p>
<ol>
<li>安装 <code>patch-package</code></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install patch-package --save-dev</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>修改 <code>node_modules/hexo-theme-next/scripts/helpers/engine.js</code> 文件</li>
</ol>
<figure class="highlight diff"><figcaption><span>engine.js</span></figcaption><table><tr><td class="code"><pre><span class="line">hexo.extend.helper.register(&#x27;i18n_path&#x27;, function(language) &#123;</span><br><span class="line">  const &#123; path, lang &#125; = this.page;</span><br><span class="line">  const base = path.startsWith(lang) ? path.slice(lang.length + 1) : path;</span><br><span class="line"><span class="deletion">- return this.url_for(`$&#123;this.languages.indexOf(language) === 0 ? &#x27;&#x27; : &#x27;/&#x27; + language&#125;/$&#123;base&#125;`);</span></span><br><span class="line"><span class="addition">+ return this.url_for(`$&#123;&#x27;/&#x27; + language&#125;/$&#123;base&#125;`);</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>创建补丁</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npx patch-package hexo-theme-next</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>应用补丁：</li>
</ol>
<figure class="highlight diff"><figcaption><span>packge.json</span></figcaption><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    ……</span><br><span class="line"><span class="addition">+     &quot;postinstall&quot;: &quot;patch-package&quot;</span></span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可实现多语言的索引页和多语言切换了，建议还要加上404页面的配置，以免语言切换时找不到页面。</p>
<p>注：升级主题的时候发现，这样的方式如果 <code>engine.js</code> 有变动，可能导致补丁应用失败，需要重新手动修改，再应用补丁，等我找方法尝试了再写上来 😂</p>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
  </entry>
  <entry>
    <title>计算机中的浮点数表示</title>
    <url>/zh-CN/Computer-Organization-single-precision-float/</url>
    <content><![CDATA[<p>本文介绍小数在计算机中的表现形式，基于IEEE标准。</p>
<span id="more"></span>
<h1>浮点数表示</h1>
<p>浮点数(floating point)：二进制小数点不固定的表达数的记数法。</p>
<p>在许多编程语言中，都提供了一种或者多种浮点数类型。例如 C 语言中提供了双精度浮点类型<code>double</code>，单精度浮点类型<code>float</code>，这两种数据类型都采用浮点数来表示。<strong>浮点数</strong> $\pm m \times n^e$ 是指由符号 (sign) 、指数 (exponent) 、尾数 (fraction) 、基数 (cardinal number) 四部分来表示的小数，数被表示为二进制小数点左边只有一位非零数的形式。在计算机中使用二进制表示数据，因此基数为2。因此计算机中的浮点数可以分成三个部分，符号，尾数和指数。</p>
<ul>
<li>双精度浮点数（64位）</li>
</ul>
<table>
<thead>
<tr>
<th>1位</th>
<th>8位</th>
<th>52位</th>
</tr>
</thead>
<tbody>
<tr>
<td>符号部分</td>
<td>指数部分</td>
<td>尾数部分</td>
</tr>
</tbody>
</table>
<ul>
<li>单精度浮点数（32位）</li>
</ul>
<table>
<thead>
<tr>
<th>1位</th>
<th>8位</th>
<th>23位</th>
</tr>
</thead>
<tbody>
<tr>
<td>符号部分</td>
<td>指数部分</td>
<td>尾数部分</td>
</tr>
</tbody>
</table>
<p>下面以单精度浮点数为例，双精度浮点数表示类似。</p>
<h2 id="符号部分">符号部分</h2>
<p>符号部分的表示使用1-bit ，和二进制整数的符号位表示法类似，符号位在最高位，0为正数，1为负数。</p>
<p>将符号放在最高为，可以快速测试出大于、小于、等于0的情况。</p>
<h2 id="尾数部分">尾数部分</h2>
<p>尾数：位于小数点的位数字段，值在0和1之间。</p>
<p>单精度浮点数中尾数长度是23个二进制数字。尾数部分是被正则化的，即小数点左边有且仅有一位非0数字，在二进制表示方式下，非0即1，因此这个数字只能为1，IEEE 754隐藏了规格化二进制数的前导位1，这样，23-bit 的尾数部分实际上可以表示 24-bit 的精度。</p>
<h2 id="指数部分">指数部分</h2>
<p>指数：位于浮点数的指数字段，表示小数点的位置。</p>
<p>但制数部分如果为负数，使用补码，可能会使得一个负指数显得像是一个大数，因此指数部分使用的是 EXCESS 系统，将中间数字设置为0，负数不需要负号来表示，将最小的负指数表示为$00\cdots00_2$ ，最大的正指数表示为$11\cdots11_2$，这种记数法称为带偏阶的记数法(biased notation)，要从带偏阶的指数中减去偏阶，才能获得真实的值。8-bit 的指数字段可以表示 256 个不同的指数值，但 0000 0000 和 1111 1111 有特殊含义，稍后再提。剩下的 254 个数值，即 1~254，实际的指数值等于该无符号整数减单精度偏阶127所得的值。</p>
<p>这样单精度浮点数表示为：<br>
$$<br>
N =(-1)^s \times （1+Fraction) \times 2 ^{Exponent-Bias}，\quad 1 \le Exponent \le 254, Bias = 127<br>
$$</p>
<h3 id="0000-0000-的情况">0000 0000 的情况</h3>
<p>如果指数字段是0000 0000，则代表指数值-126，且尾数中小数点左边默认数字是0（而不是1），这种情况下，浮点数值为：<br>
$$<br>
N = (-1)^s \times 0.尾数 \times 2 ^{-126}<br>
$$<br>
若指数与尾数均为0，则根据符号位表示 $\pm 0​$。</p>
<p>但为什么不是用$1.尾数 \times 2^{-127} $呢？考虑以下情况，$1.11\cdots11\times 2^{-127}$ 与 $1.11\cdots 10 \times 2 ^{-127}$ 两个数相减的情况，差为$0.00\cdots 01 \times 2 ^{-127}$ ，这个差值将无法使用这种表示法来表示。为了解决这种情况，在表示比$1.00\cdots 00\times 2 ^{-126}$小的数时，我们用0取代被我们忽略的默认小数点左边的1。</p>
<h3 id="1111-1111-的情况">1111 1111 的情况</h3>
<ul>
<li><strong>尾数为0</strong> ：根据符号位表示 $\pm \infty$</li>
<li><strong>尾数非0</strong>：表示 <code>NaN</code> 非数字， (Not a Number)</li>
</ul>
<h2 id="IEEE-754-浮点数的编码">IEEE 754 浮点数的编码</h2>
<table>
<thead>
<tr>
<th>单精度</th>
<th></th>
<th>双精度</th>
<th></th>
<th>表示对象</th>
</tr>
</thead>
<tbody>
<tr>
<td>指数</td>
<td>尾数</td>
<td>指数</td>
<td>尾数</td>
<td></td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>非0</td>
<td>0</td>
<td>非0</td>
<td>$\pm$ 非规格化数</td>
</tr>
<tr>
<td>1-254</td>
<td>任何值</td>
<td>1-2046</td>
<td>任何值</td>
<td>$\pm$浮点数</td>
</tr>
<tr>
<td>255</td>
<td>0</td>
<td>2047</td>
<td>0</td>
<td>$\pm \infty$</td>
</tr>
<tr>
<td>255</td>
<td>非0</td>
<td>2047</td>
<td>非0</td>
<td>NaN</td>
</tr>
</tbody>
</table>
<h1>十进制小数转IEEE浮点数</h1>
<h2 id="方法">方法</h2>
<ol>
<li>将十进制小数表示为二进制小数</li>
<li>正则化处理</li>
<li>根据符号确定符号位</li>
<li>计算指数部分</li>
<li>计算尾数部分</li>
</ol>
<h2 id="举例">举例</h2>
<p>下面我们将$-6 \frac{5}{8}$ 表示为IEEE浮点数：</p>
<ol>
<li>
<p>首先将$-6 \frac{5}{8}$ 表示为二进制数:<br>
$$<br>
-6 \frac{5}{8} = -(1\times 2^2 + 1 \times 2^1 + 0 \times 2^0 + 1\times 2^{-1} + 0 \times 2^{-2} + 1\times 2^{-3}<br>
$$</p>
</li>
<li>
<p>正则化处理得到 $-1.10101 \times 2 ^2$</p>
</li>
<li>
<p>负数，符号位为1</p>
</li>
<li>
<p>计算指数部分：实际指数为2，加上127得到129，二进制表示指数部分为1000 0001</p>
</li>
<li>
<p>计算尾数部分，忽略小数点左边的1，得到尾数部分为 1010 1000 0000 0000 0000 000 。</p>
</li>
</ol>
<h2 id="C语言实现">C语言实现 <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 用于确认单精度浮点数表示方法的C语言程序（摘自《程序是怎样跑起来的》），做了一点小改动 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">float</span> data;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> buff;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">34</span>];</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>, &amp;data);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 把数据复制到 4 字节长度的整数变量 buff 中以逐个提取出每一位</span></span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;buff, &amp;data, <span class="number">4</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 逐一提取出每一位</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">33</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i == <span class="number">1</span> || i == <span class="number">10</span>) </span><br><span class="line">          <span class="comment">// 加入破折号来区分符号部分、指数部分和尾数部分</span></span><br><span class="line">          s[i] = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (buff % <span class="number">2</span> == <span class="number">1</span>) </span><br><span class="line">            s[i] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">         <span class="keyword">else</span> </span><br><span class="line">            s[i] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">          buff /= <span class="number">2</span>;</span><br><span class="line">       &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  s[<span class="number">33</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>IEEE 浮点数转十进制数</h1>
<h2 id="方法-2">方法</h2>
<ol>
<li>由第一位判断符号</li>
<li>由第二位至第九位计算十进制值减去127得到指数值</li>
<li>后23位为尾数值</li>
</ol>
<h2 id="举例-2">举例</h2>
<p>将浮点数 0  1000 0011   0010 1000 0000 0000 0000 000 转为十进制数：</p>
<ol>
<li>符号位为0，该数为正数</li>
<li>指数字段 1000 0011 转为十进制数为 131，得到实际指数值为4</li>
<li>尾数部分为 0010 1000 0000 0000 0000 000，在小数点左边补1，得到1.0010 1</li>
<li>因为实际指数值为4，故将小数点右移4位，得到10010.1</li>
<li>转为十进制得到18.5</li>
</ol>
<h1>参考资料</h1>
<ul>
<li>《计算机系统概论》</li>
<li>《程序是怎样跑起来的》</li>
<li>《计算机组成与设计——硬件/软件接口》</li>
<li><a href="https://zh.wikipedia.org/wiki/IEEE_754#%E7%89%B9%E6%AE%8A%E5%80%BC">IEEE 754 - 维基百科，自由的百科全书</a></li>
<li><a href="https://stackoverflow.com/questions/52141648/understanding-exponent-00000000-and-11111111-in-ieee">floating point - Understanding exponent 00000000 and 11111111 in IEEE - Stack Overflow</a></li>
</ul>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><a href="https://gist.github.com/fish-404/a0b438ef508941dfe66fc0c712129a3a#file-expression_float-c">Source Code - Gits</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>计算机组成原理</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构-邻接数组存储的图</title>
    <url>/zh-CN/Data-structures-MGraph/</url>
    <content><![CDATA[<ul>
<li>邻接数组存储的图的表示</li>
<li>邻接数组存储的图的操作接口定义</li>
<li>邻接数组存储的图的操作实现</li>
</ul>
<span id="more"></span>
<h1>邻接数组存储的图的表示</h1>
<p>由于图的任意两个顶点之间都可能存在边（弧），因此在图的存储与表示中，关键是如何表示边（弧）集。<br>
用邻接矩阵也就是一个二维数组存储图的边集，也即关系数组，用一个一维数组存储图的顶点，也即顶点数组。</p>
<p>邻接数组的存储结构类型定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 用于标记是否已访问 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNVISITED	0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VISITED		1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INFINITY INT_MAX	<span class="comment">// 计算机中允许的最大整数值</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;DG, DN, UDG, UDN&#125; GraphKind;	<span class="comment">// 图的四种类型：有向图、有向带权图、无向图、无向带权图</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 邻接数组类型 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	VexType * vexs; <span class="comment">// 顶点数组</span></span><br><span class="line">	<span class="type">int</span>** arcs;	<span class="comment">// 关系数组，无权图用0或1表示是否相邻，带权图则为权值或INFINITY</span></span><br><span class="line">	<span class="type">int</span> n;		<span class="comment">// 顶点数</span></span><br><span class="line">	<span class="type">int</span> e; 		<span class="comment">// 边（弧）数</span></span><br><span class="line">	GraphKind kind;	<span class="comment">// 图的类型</span></span><br><span class="line">	<span class="type">int</span> * tags;	<span class="comment">// 标志数组，用于标记顶点访问与否</span></span><br><span class="line">&#125;MGraph;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 边（弧）信息 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	VexType v, w; <span class="comment">// 边（弧）端点</span></span><br><span class="line">	<span class="type">int</span> info; <span class="comment">// 对于带权图为权值</span></span><br><span class="line">&#125;ArcInfo;</span><br></pre></td></tr></table></figure>
<h2 id="本文中预定义的说明">本文中预定义的说明</h2>
<h3 id="预定义常量和类型">预定义常量和类型</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数结果状态代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE      1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE     0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK        1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR     0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OVERFLOW -1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status; <span class="comment">// 用作函数值类型，表示函数结果状态</span></span><br></pre></td></tr></table></figure>
<h3 id="数据结构（存储结构）的表示">数据结构（存储结构）的表示</h3>
<p>数据结构的表示用类型定义(<code>typedef</code>)描述。数据元素类型约定为ElemType，读者在使用该数据类型时自行定义，如<code>int</code>、<code>char</code>等简单类型。</p>
<h3 id="扩展引用调用">扩展引用调用</h3>
<p>为了便于算法描述，我们使用了 C++ 语言中的引用调用参数传递方式。</p>
<h1>邻接数组存储的图的操作接口定义</h1>
<p>图G的顶点<code>v</code>在顶点数组中的下标<code>k</code>称为<code>k</code>在G中的位序，也称<code>v</code>为G的 <strong>第<code>k</code>顶点</strong>， 简称 <strong>k顶点</strong>。基于邻接数组的图的接口定义如下：</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化含n个顶点且无边的kind类的图G</span></span><br><span class="line"><span class="function">Status <span class="title">InitGraph_M</span><span class="params">(MGraph &amp;G, GraphKind kind, VexType *vexs, <span class="type">int</span> n)</span></span>;</span><br><span class="line"><span class="comment">// 创建n个顶点和e条边的kind类的图G，vexs为顶点信息，arcs为边信息</span></span><br><span class="line"><span class="function">Status <span class="title">CreateGraph_M</span><span class="params">(MGraph &amp;G, GraphKind kind, VexType *vexs, <span class="type">int</span> n, ArcInfo *arcs, <span class="type">int</span> e)</span></span>;</span><br><span class="line"><span class="comment">// 销毁图G</span></span><br><span class="line"><span class="function">Status <span class="title">DestroyGraph_M</span><span class="params">(MGraph &amp;G)</span></span>;</span><br><span class="line"><span class="comment">// 查找顶点v在图G中的位序</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LocateVex_M</span><span class="params">(MGraph G, VexType v)</span></span>;</span><br><span class="line"><span class="comment">// 取图G的k顶点的值到w</span></span><br><span class="line"><span class="function">Status <span class="title">GetVex_M</span><span class="params">(MGraph G, <span class="type">int</span> k, VexType &amp;w)</span></span>;</span><br><span class="line"><span class="comment">// 对图G的k顶点赋值w</span></span><br><span class="line"><span class="function">Status <span class="title">PutVex_M</span><span class="params">(MGraph &amp;G, <span class="type">int</span> k, VexType w)</span></span>;</span><br><span class="line"><span class="comment">// 求图G中k顶点的第一个邻接顶点位序</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FirstAdjVex_M</span><span class="params">(MGraph G, <span class="type">int</span> k)</span></span>;</span><br><span class="line"><span class="comment">// m顶点为k顶点的邻接顶点，求图G中k顶点相对于m顶点的下一个邻接顶点的位序</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">NextAdjVex_M</span><span class="params">(MGraph G, <span class="type">int</span> k, <span class="type">int</span> m)</span></span>;</span><br><span class="line"><span class="comment">// 在图G中增加k顶点到m顶点的边或弧，若为带权图，info为权值，否则为1</span></span><br><span class="line"><span class="function">Status <span class="title">AddArc_M</span><span class="params">(MGraph &amp;G, <span class="type">int</span> k, <span class="type">int</span> m, <span class="type">int</span> info)</span></span>;</span><br><span class="line"><span class="comment">// 在图G中删除k顶点到m顶点的边或弧</span></span><br><span class="line"><span class="function">Status <span class="title">RemoveArc_M</span><span class="params">(MGraph &amp;G, <span class="type">int</span> k, <span class="type">int</span> m)</span></span>;</span><br><span class="line"><span class="comment">// 深度优先遍历图G</span></span><br><span class="line"><span class="function">Status <span class="title">DfsTraverse_M</span><span class="params">(MGraph G, Status(* visit)(<span class="type">int</span>))</span></span>;</span><br><span class="line"><span class="comment">// 广度优先遍历图G</span></span><br><span class="line"><span class="function">Status <span class="title">BFSTraverse_M</span><span class="params">(MGraph G, Status(*visit)(<span class="type">int</span>))</span></span>;</span><br></pre></td></tr></table></figure>
<h1>邻接数组存储的图的操作实现</h1>
<h2 id="初始化图">初始化图</h2>
<p>初始化图的过程如下：</p>
<ol>
<li>按顶点数分配顶点、边集和标志3个数组空间；</li>
<li>将顶点依次存入顶点数组；</li>
<li>初始化标志数组和关系数组。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitGraph_M</span><span class="params">(MGraph &amp;G, GraphKind kind, VexType *vexs, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i, j, info;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">0</span> || (n &gt; <span class="number">0</span> &amp;&amp; <span class="literal">NULL</span> == vexs))</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*根据图的类型赋权值*/</span></span><br><span class="line">	<span class="keyword">if</span> (DG == kind || UDG == kind) 		<span class="comment">// 无权图</span></span><br><span class="line">		info  = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (DN == kind || UDN == kind) <span class="comment">// 有权图</span></span><br><span class="line">		info = INFINITY;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">	G.n = n;  <span class="comment">// 顶点数</span></span><br><span class="line">	G.e = <span class="number">0</span>;  <span class="comment">// 边数</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*若为空图，则已初始化完成*/</span></span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> OK;</span><br><span class="line"></span><br><span class="line">	G.vexs = (VexType*)<span class="built_in">malloc</span>(n * <span class="built_in">sizeof</span>(VexType));</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == G.vexs)</span><br><span class="line">		<span class="keyword">return</span> OVERFLOW;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*建立顶点数组*/</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.n; i++)</span><br><span class="line">		G.vexs[i] = vexs[i];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*分配关系数组的指针数组*/</span></span><br><span class="line">	G.arcs = (<span class="type">int</span>**)<span class="built_in">malloc</span>(n * <span class="built_in">sizeof</span>(<span class="type">int</span>*));</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == G.arcs)</span><br><span class="line">		<span class="keyword">return</span> OVERFLOW;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*分配关系数组的指针数组指向的数组*/</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		G.arcs[i] = (<span class="type">int</span>*)<span class="built_in">malloc</span>(n * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">		<span class="keyword">if</span> (<span class="literal">NULL</span> == G.arcs[i])</span><br><span class="line">			<span class="keyword">return</span> OVERFLOW;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*分配标志数组*/</span></span><br><span class="line">	G.tags = (<span class="type">int</span>*)<span class="built_in">malloc</span>(n * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == G.tags)</span><br><span class="line">		<span class="keyword">return</span> OVERFLOW;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*初始化标志数组和关系数组*/</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		G.tags[i] = UNVISITED;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">			G.arcs[i][j] = info;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建图">创建图</h2>
<p>在图已初始化的情况下根据图的类型和边关系数组创建图。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">CreateGraph_M</span><span class="params">(MGraph &amp;G, GraphKind kind, VexType *vexs, <span class="type">int</span> n, ArcInfo *arcs, <span class="type">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">0</span> || e &lt; <span class="number">0</span> || (n &gt; <span class="number">0</span> &amp;&amp; <span class="literal">NULL</span> == vexs) || (e &gt; <span class="number">0</span> &amp;&amp; <span class="literal">NULL</span> == arcs))</span><br><span class="line">	       <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">	G.kind = kind; <span class="comment">// 图的类型</span></span><br><span class="line">	<span class="keyword">switch</span> (G.kind) &#123;</span><br><span class="line">		<span class="keyword">case</span> UDG : <span class="keyword">return</span> <span class="built_in">CreateUDG_M</span>(G, vexs, n, arcs, e);	<span class="comment">// 创建无向无权图</span></span><br><span class="line">		<span class="keyword">case</span> DG : <span class="keyword">return</span> <span class="built_in">CreateDG_M</span>(G, vexs, n, arcs, e);	<span class="comment">// 创建有向无权图</span></span><br><span class="line">		<span class="keyword">case</span> UDN : <span class="keyword">return</span> <span class="built_in">CreateUDN_M</span>(G, vexs, n, arcs, e);	<span class="comment">// 创建无向带权图</span></span><br><span class="line">		<span class="keyword">case</span> DN : <span class="keyword">return</span> <span class="built_in">CreateDN_M</span>(G, vexs, n, arcs, e);   	<span class="comment">// 创建有向带权图</span></span><br><span class="line">		<span class="keyword">default</span>:  <span class="keyword">return</span> ERROR;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建无向无权图">创建无向无权图</h3>
<p>对每条边分别求得顶点<code>v</code>和<code>w</code>在顶点数组中的下标<code>i</code>和<code>j</code>，然后置<code>G.arcs[i][j]</code>和<code>G.arcs[j][i]</code>的值为1。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">CreateUDG_M</span><span class="params">(MGraph &amp;G, VexType *vexs, <span class="type">int</span> n, ArcInfo *arcs, <span class="type">int</span> e)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i, j, k;</span><br><span class="line">	VexType v, w;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*初始化*/</span></span><br><span class="line">	<span class="keyword">if</span> (OK != InitGraph_M(G, G.kind, vexs, n))</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">	G.e = e; <span class="comment">// 边数</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; G.e; k++) &#123;</span><br><span class="line">		<span class="comment">/*读入边(v,w)*/</span></span><br><span class="line">		v = arcs[k].v;</span><br><span class="line">		w = arcs[k].w;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*确定v和w在顶点数组中的位序i和j*/</span></span><br><span class="line">		i = LocateVex_M(G, v);</span><br><span class="line">		j = LocateVex_M(G, w);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt;<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> ERROR;</span><br><span class="line">		G.arcs[i][j] = G.arcs[j][i] = <span class="number">1</span>;	<span class="comment">// 对关系数组赋值</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建有向无权图">创建有向无权图</h3>
<p>对每条边分别求得顶点<code>v</code>和<code>w</code>在顶点数组中的下标<code>i</code>和<code>j</code>，然后置<code>G.arcs[i][j]</code>的值为1。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">CreateDG_M</span><span class="params">(MGraph &amp;G, VexType *vexs, <span class="type">int</span> n, ArcInfo *arcs, <span class="type">int</span> e)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i, j, k;</span><br><span class="line">	VexType v, w;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*初始化*/</span></span><br><span class="line">	<span class="keyword">if</span> (OK != InitGraph_M(G, G.kind, vexs, n))</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">	G.e = e; <span class="comment">// 边数</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; G.e; k++) &#123;</span><br><span class="line">		<span class="comment">/*读入边(v,w)*/</span></span><br><span class="line">		v = arcs[k].v;</span><br><span class="line">		w = arcs[k].w;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*确定v和w在顶点数组中的位序i和j*/</span></span><br><span class="line">		i = LocateVex_M(G, v);</span><br><span class="line">		j = LocateVex_M(G, w);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> ERROR;</span><br><span class="line">		G.arcs[i][j] = <span class="number">1</span>;	<span class="comment">// 对关系数组赋值</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="无向带权图">无向带权图</h3>
<p>对每条边分别求得顶点<code>v</code>和<code>w</code>在顶点数组中的下标<code>i</code>和<code>j</code>，然后置<code>G.arcs[i][j]</code>和<code>G.arcs[j][i]</code>的值为权值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">CreateUDN_M</span><span class="params">(MGraph &amp;G, VexType *vexs, <span class="type">int</span> n, ArcInfo *arcs, <span class="type">int</span> e)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i, j, k;</span><br><span class="line">	VexType v, w;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*初始化*/</span></span><br><span class="line">	<span class="keyword">if</span> (OK != InitGraph_M(G, G.kind, vexs, n))</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">	G.e = e; <span class="comment">// 边数</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; G.e; k++) &#123;</span><br><span class="line">		<span class="comment">/*读入边(v,w)*/</span></span><br><span class="line">		v = arcs[k].v;</span><br><span class="line">		w = arcs[k].w;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*确定v和w在顶点数组中的位序i和j*/</span></span><br><span class="line">		i = LocateVex_M(G, v);</span><br><span class="line">		j = LocateVex_M(G, w);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt;<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> ERROR;</span><br><span class="line">		G.arcs[i][j] = G.arcs[j][i] = arcs[k].info;	<span class="comment">// 对关系数组赋值</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建有向带权图">创建有向带权图</h3>
<p>对每条边分别求得顶点<code>v</code>和<code>w</code>在顶点数组中的下标<code>i</code>和<code>j</code>，然后置<code>G.arcs[i][j]</code>的值为权值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">CreateDN_M</span><span class="params">(MGraph &amp;G, VexType *vexs, <span class="type">int</span> n, ArcInfo *arcs, <span class="type">int</span> e)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i, j, k;</span><br><span class="line">	VexType v, w;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*初始化*/</span></span><br><span class="line">	<span class="keyword">if</span> (OK != InitGraph_M(G, G.kind, vexs, n))</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">	G.e = e; <span class="comment">// 边数</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; G.e; k++) &#123;</span><br><span class="line">		<span class="comment">/*读入边(v,w)*/</span></span><br><span class="line">		v = arcs[k].v;</span><br><span class="line">		w = arcs[k].w;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*确定v和w在顶点数组中的位序i和j*/</span></span><br><span class="line">		i = LocateVex_M(G, v);</span><br><span class="line">		j = LocateVex_M(G, w);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt;<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> ERROR;</span><br><span class="line">		G.arcs[i][j] = arcs[k].info;	<span class="comment">// 对关系数组赋值</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="销毁图">销毁图</h2>
<p>需要销毁顶点数组，指向关系数组的指针数组，关系数组，标志数组。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DestroyGraph_M</span><span class="params">(MGraph &amp;G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.n; i++)</span><br><span class="line">		<span class="built_in">free</span>(G.arcs[i]);</span><br><span class="line">	<span class="built_in">free</span>(G.arcs);</span><br><span class="line">	<span class="built_in">free</span>(G.vexs);</span><br><span class="line">	<span class="built_in">free</span>(G.tags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查找顶点位序">查找顶点位序</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">LocateVex_M</span><span class="params">(MGraph G, VexType v)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.n; i++)</span><br><span class="line">		<span class="keyword">if</span> (G.vexs[i] == v)</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> OVERFLOW;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="取顶点值">取顶点值</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">GetVex_M</span><span class="params">(MGraph G, <span class="type">int</span> k, VexType &amp;w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (G.n &lt;= <span class="number">0</span> || k &gt; G.n || k &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	w = G.vexs[k];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="置顶点值">置顶点值</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">PutVex_M</span><span class="params">(MGraph &amp;G, <span class="type">int</span> k, VexType w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (G.n &lt;= <span class="number">0</span> || k &gt; G.n || k &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	G.vexs[k] = w;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="求k顶点第一个邻接顶点">求k顶点第一个邻接顶点</h2>
<p>对于无权图，查找关系数组中的第<code>k</code>行第一个非零元素列号；<br>
对于带权图，查找关系数组中的第<code>k</code>行第一个非$\infty$元素列号。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">FirstAdjVex_M</span><span class="params">(MGraph G, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">if</span> (k &lt; <span class="number">0</span> || k &gt;= G.n)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((G.kind == UDG || G.kind == DG) &amp;&amp; G.arcs[k][i] != <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ((G.kind == UDN || G.kind == DN) &amp;&amp; G.arcs[k][i] != INFINITY)</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OVERFLOW;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="求k顶点某邻接顶点的下一个邻接顶点">求k顶点某邻接顶点的下一个邻接顶点</h2>
<p>将上一个操作的从第0列开始查找改为从第m+1列开始查找即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">NextAdjVex_M</span><span class="params">(MGraph G, <span class="type">int</span> k, <span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (G.n &lt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = m + <span class="number">1</span>; i &lt; G.n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((G.kind == UDG || G.kind == DG) &amp;&amp; G.arcs[k][i] != <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ((G.kind == UDN || G.kind == DN) &amp;&amp; G.arcs[k][i] != INFINITY)</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OVERFLOW;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="增加边或弧">增加边或弧</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">AddArc_M</span><span class="params">(MGraph &amp;G, <span class="type">int</span> k, <span class="type">int</span> m, <span class="type">int</span> info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (k &lt; <span class="number">0</span> || k &gt; G.n || m &lt; <span class="number">0</span> || m &gt; G.n)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (G.kind) &#123;</span><br><span class="line">		<span class="keyword">case</span> UDG : <span class="comment">// 无向无权图</span></span><br><span class="line">			<span class="keyword">if</span> (G.arcs[k][m] != <span class="number">0</span> || G.arcs[m][k] != <span class="number">0</span>) <span class="comment">// 边已存在</span></span><br><span class="line">				<span class="keyword">return</span> ERROR;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				G.arcs[k][m] = G.arcs[m][k] = info;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> DG : <span class="comment">// 有向无权图</span></span><br><span class="line">			<span class="keyword">if</span> (G.arcs[k][m] != <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">return</span> ERROR;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				G.arcs[k][m] = info;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> UDN : <span class="comment">// 无向带权图</span></span><br><span class="line">			<span class="keyword">if</span> (G.arcs[k][m] != INFINITY || G.arcs[m][k] != INFINITY)</span><br><span class="line">				<span class="keyword">return</span> ERROR;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				G.arcs[k][m] = G.arcs[m][k] = info;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> DN : <span class="comment">// 有向带权图</span></span><br><span class="line">			<span class="keyword">if</span> (G.arcs[k][m] != INFINITY)</span><br><span class="line">				<span class="keyword">return</span> ERROR;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				G.arcs[k][m] = info;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		deault :</span><br><span class="line">			<span class="keyword">return</span> ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除边或弧">删除边或弧</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">RemoveArc_M</span><span class="params">(MGraph &amp;G, <span class="type">int</span> k, <span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (k &lt; <span class="number">0</span> || k &gt; G.n || m &lt; <span class="number">0</span> || m &gt; G.n)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (G.kind) &#123;</span><br><span class="line">		<span class="keyword">case</span> UDG : <span class="comment">// 无向无权图</span></span><br><span class="line">			<span class="keyword">if</span> (G.arcs[k][m] == <span class="number">0</span> || G.arcs[m][k] == <span class="number">0</span>) <span class="comment">// 边已存在</span></span><br><span class="line">				<span class="keyword">return</span> ERROR;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				G.arcs[k][m] = G.arcs[m][k] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> DG : <span class="comment">// 有向无权图</span></span><br><span class="line">			<span class="keyword">if</span> (G.arcs[k][m] == <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">return</span> ERROR;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				G.arcs[k][m] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> UDN : <span class="comment">// 无向带权图</span></span><br><span class="line">			<span class="keyword">if</span> (G.arcs[k][m] == INFINITY || G.arcs[m][k] == INFINITY)</span><br><span class="line">				<span class="keyword">return</span> ERROR;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				G.arcs[k][m] = G.arcs[m][k] = INFINITY;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> DN : <span class="comment">// 有向带权图</span></span><br><span class="line">			<span class="keyword">if</span> (G.arcs[k][m] == INFINITY)</span><br><span class="line">				<span class="keyword">return</span> ERROR;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				G.arcs[k][m] = INFINITY;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		deault :</span><br><span class="line">			<span class="keyword">return</span> ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="深度优先遍历">深度优先遍历</h2>
<p>对于连通图：</p>
<ol>
<li>从指定顶点$v$出发，先访问该顶点；</li>
<li>对$v$顶点的所有邻接顶点$w_i$依次检查；</li>
<li>若$w_i$未被访问，则以$w_i$为新起点递归进行深度优先遍历。</li>
</ol>
<p>对于非连通图，这样的过程仅能访问到开始顶点所在的连通分量，故需要依次检查图中的所有顶点，若未访问，则以其为新起点进行深度优先遍历，直到所有顶点都被访问为止。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DFS_M</span><span class="params">(MGraph G, <span class="type">int</span> k, Status (*visit)(<span class="type">int</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ERROR == <span class="built_in">visit</span>(k))</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">	G.tags[k] = VISITED;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="built_in">FirstAdjVex_M</span>(G, k); i &gt;= <span class="number">0</span>; i = <span class="built_in">NextAdjVex_M</span>(G, k, i)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (UNVISITED == G.tags[i]) &#123;</span><br><span class="line">			<span class="keyword">if</span> (ERROR == <span class="built_in">DFS_M</span>(G, i, visit))</span><br><span class="line">					<span class="keyword">return</span> ERROR;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DFSTraverse_M</span><span class="params">(MGraph G, Status (*visit)(<span class="type">int</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*初始化标志数组*/</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.n; i++)</span><br><span class="line">		G.tags[i] = UNVISITED;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (UNVISITED == G.tags[i])</span><br><span class="line">			<span class="keyword">if</span> (ERROR == <span class="built_in">DFS_M</span>(G, i, visit))</span><br><span class="line">				<span class="keyword">return</span> ERROR;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="广度优先遍历图">广度优先遍历图</h2>
<ol>
<li>将所有顶点的访问标志初始化为<code>UNVISITED</code>；</li>
<li>依次检查所有顶点，若未被访问过，则：
<ul>
<li>访问该顶点，入队；</li>
<li>队列非空，队头元素出队，判断其所有邻接顶点是否被访问过；</li>
<li>若未被访问过，访问该顶点，入队；</li>
<li>重复以上操作直至队列为空。</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">BFSTraverse_M</span><span class="params">(MGraph G, Status (*visit)(<span class="type">int</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i, j, k;</span><br><span class="line">	SqQueue Q;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">InitQueue_Sq</span>(Q, G.n);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.n; i++)</span><br><span class="line">		G.tags[i] = UNVISITED;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (UNVISITED == G.tags[i]) &#123;</span><br><span class="line">			<span class="keyword">if</span> (ERROR == <span class="built_in">visit</span>(i))</span><br><span class="line">				<span class="keyword">return</span> ERROR;</span><br><span class="line">			G.tags[i] = VISITED;</span><br><span class="line">			<span class="built_in">EnQueue_Sq</span>(Q, i);</span><br><span class="line">			<span class="keyword">while</span> (OK == <span class="built_in">DeQueue_Sq</span>(Q, k)) &#123;</span><br><span class="line">				<span class="keyword">for</span> (j = <span class="built_in">FirstAdjVex_M</span>(G, k); j &gt;= <span class="number">0</span>; j = <span class="built_in">NextAdjVex_M</span>(G, k, j)) &#123;</span><br><span class="line">					<span class="keyword">if</span> (UNVISITED == G.tags[j]) &#123;</span><br><span class="line">						<span class="keyword">if</span> (ERROR == <span class="built_in">visit</span>(j))</span><br><span class="line">							<span class="keyword">return</span> ERROR;</span><br><span class="line">						G.tags[j] = VISITED;</span><br><span class="line">						<span class="built_in">EnQueue_Sq</span>(Q, j);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>参考资料</h1>
<ul>
<li>《数据结构》（高教版，吴伟民，李小妹）</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
        <tag>Data Structures</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-顺序表</title>
    <url>/zh-CN/Data-structures-SqList/</url>
    <content><![CDATA[<ul>
<li>顺序表的描述与表示</li>
<li>顺序表的操作接口定义</li>
<li>顺序表的操作实现</li>
</ul>
<span id="more"></span>
<h1>顺序表的描述与表示</h1>
<p>首先介绍线性表（Linear List），线性表是一种允许在序列任意位置进行操作的数据结构。采用顺序存储结构表示的线性表称为顺序表。用一组地址连续的存储单元依次存放线性表的数据元素，以存储位置相邻表示位序相继的两个元素之间的前驱和后继关系。</p>
<p>顺序表的类型定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  ElemType* base;     <span class="comment">// 顺序表存储空间的基址</span></span><br><span class="line">  <span class="type">int</span> length;         <span class="comment">// 顺序表当前长度</span></span><br><span class="line">  <span class="type">int</span> size;           <span class="comment">// 顺序表的存储容量</span></span><br><span class="line">  <span class="type">int</span> increment;      <span class="comment">// 顺序表扩容时的增量</span></span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure>
<h2 id="本文中预定义的说明">本文中预定义的说明</h2>
<h3 id="预定义常量和类型">预定义常量和类型</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数结果状态代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE      1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE     0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK        1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR     0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OVERFLOW -1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status; <span class="comment">// 用作函数值类型，表示函数结果状态</span></span><br></pre></td></tr></table></figure>
<h3 id="数据结构（存储结构）的表示">数据结构（存储结构）的表示</h3>
<p>数据结构的表示用类型定义(<code>typedef</code>)描述。数据元素类型约定为ElemType，读者在使用该数据类型时自行定义，如<code>int</code>、<code>char</code>等简单类型。</p>
<h3 id="扩展引用调用">扩展引用调用</h3>
<p>为了便于算法描述，我们使用了 C++ 语言中的引用调用参数传递方式。</p>
<h1>顺序表的操作接口定义</h1>
<p>由于采用了顺序存储结构，如果在顺序表中插入或删除元素，则需要移动操作位置之后的所有元素。实际上，如果需要频繁地插入和删除数据，选择顺序表作为抽象数据结构是一个极大的错误。虽然下面给出了删除和插入接口的定义，但在这种情况下应该竭力避免使用顺序表存储结构。</p>
<p>顺序表的接口定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化顺序表L</span></span><br><span class="line">Status <span class="title function_">InitList_Sq</span><span class="params">(SqList &amp;L, <span class="type">int</span> size, <span class="type">int</span> inc)</span>;</span><br><span class="line"><span class="comment">// 销毁顺序表L</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DestroyList_Sq</span><span class="params">(SqList &amp;L)</span>;</span><br><span class="line"><span class="comment">// 将顺序表L清空</span></span><br><span class="line">Status <span class="title function_">ClearList_Sq</span><span class="params">(SqList &amp;L)</span>;</span><br><span class="line"><span class="comment">// 判断顺序表是否为空，是返回 TRUE, 否则返回 FALSE</span></span><br><span class="line">Status <span class="title function_">ListEmpty_Sq</span><span class="params">(SqList L)</span>;</span><br><span class="line"><span class="comment">// 返回顺序表L中元素个数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ListLength_Sq</span><span class="params">(SqList L)</span>;</span><br><span class="line"><span class="comment">// 用e返回顺序表L中第i个元素的值</span></span><br><span class="line">Status <span class="title function_">GetElem_Sq</span><span class="params">(SqList L, <span class="type">int</span> i, ElemType &amp;e)</span>;</span><br><span class="line"><span class="comment">// 在顺序表L中查找元素e，查找成功返回该元素在表中第一次出现位置，否则返回-1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Search_Sq</span><span class="params">(SqList, ElemType e)</span>;</span><br><span class="line"><span class="comment">// 遍历顺序表L， 依次对每个元素调用visit()</span></span><br><span class="line">Status <span class="title function_">ListTraverse_Sq</span><span class="params">(SqList L, Status( *visit)(ElemType e))</span>;</span><br><span class="line"><span class="comment">// 将顺序表L中第i个元素赋值为e</span></span><br><span class="line">Status <span class="title function_">PutElem_Sq</span><span class="params">(SqList &amp;L, <span class="type">int</span> i, ElemType e)</span>;</span><br><span class="line"><span class="comment">// 在顺序表L表尾添加元素e</span></span><br><span class="line">Status <span class="title function_">Append_Sq</span><span class="params">(SqList &amp;L, ElemType e)</span>;</span><br><span class="line"><span class="comment">// 删除顺序表L表尾元素，并用e返回</span></span><br><span class="line">Status <span class="title function_">DeleteLast_Sq</span><span class="params">(SqList &amp;L, ElemType &amp;e)</span>;</span><br><span class="line"><span class="comment">// 在顺序表第i个元素之前插入新的元素e，表长加1</span></span><br><span class="line">Status <span class="title function_">InsertList_Sq</span><span class="params">(SqList &amp;L, <span class="type">int</span> i, ElemType e)</span>;</span><br><span class="line"><span class="comment">// 删除顺序表的第i个元素，返回到e，表长减1</span></span><br><span class="line">Status <span class="title function_">DelElem_Sq</span><span class="params">(SqList &amp;L, <span class="type">int</span> i, ElemType &amp;e)</span>;</span><br></pre></td></tr></table></figure>
<h1>顺序表接口实现</h1>
<h2 id="初始化顺序表">初始化顺序表</h2>
<ul>
<li>分配存储空间</li>
<li>给定顺序表容量</li>
<li>给定扩容增量</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitList_Sq</span><span class="params">(SqList &amp;L, <span class="type">int</span> size, <span class="type">int</span> inc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  L.base = (ElemType*)<span class="built_in">malloc</span>(size * <span class="built_in">sizeof</span>(ElemType));</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">NULL</span> == L.base)</span><br><span class="line">    <span class="keyword">return</span> OVERFLOW;</span><br><span class="line">  L.size = size;</span><br><span class="line">  L.increment = inc;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="销毁顺序表">销毁顺序表</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DestroyList_Sq</span><span class="params">(SqList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">free</span>(L.base);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="将顺序表清空">将顺序表清空</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ClearList_Sq</span><span class="params">(SqList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  L.length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="判断顺序表是否为空">判断顺序表是否为空</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListEmpty_Sq</span><span class="params">(SqList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (L.length == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="求顺序表元素个数">求顺序表元素个数</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ListLength_Sq</span><span class="params">(SqList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> L.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="求第-i-个元素值">求第 i 个元素值</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">GetElem_Sq</span><span class="params">(SqList L, <span class="type">int</span> i, ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt; L.length)</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">  e = L.base[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="顺序查找">顺序查找</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Search_Sq</span><span class="params">(SqList L, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; L.length &amp;&amp; L.elem[i] != e)</span><br><span class="line">    i++;</span><br><span class="line">  <span class="keyword">if</span> (i &lt; L.length)</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="访问每个元素">访问每个元素</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">status <span class="title">ListTraverse_Sq</span><span class="params">(SqList L, Status(*visit)(ElemType e))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (L == <span class="literal">NULL</span> || L.length &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; L.length; i++) &#123;</span><br><span class="line">      <span class="built_in">visit</span>(L.base[i]);</span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="赋值指定位序元素">赋值指定位序元素</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">PutElem_Sq</span><span class="params">(SqList &amp;L, <span class="type">int</span> i, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (i &gt; L.length || L == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">  L.base[i - <span class="number">1</span>] = e;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="添加表尾元素">添加表尾元素</h2>
<ul>
<li>判断表是否已满
<ul>
<li>若已满，扩容</li>
</ul>
</li>
<li>添加元素</li>
<li>表长 + 1</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Append_Sq</span><span class="params">(SqList &amp;L, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ElemType *newbase;</span><br><span class="line">  <span class="keyword">if</span> (L.length == L.size) &#123;</span><br><span class="line">  	 newbase = (ElemType*)<span class="built_in">realloc</span>(L.base, (L.size + L.increcement) * <span class="built_in">sizeof</span>(ElemType));</span><br><span class="line">     <span class="keyword">if</span> (<span class="literal">NULL</span> == newbase)</span><br><span class="line">         <span class="keyword">return</span> OVERFLOW;</span><br><span class="line">      L.base = newbase;</span><br><span class="line">      L.size += L.increcement;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  L.base[L.length] = e;</span><br><span class="line">  L.length++;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除表尾元素">删除表尾元素</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DeleteLast_Sq</span><span class="params">(SqList &amp;L, ElemType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">0</span> == L.length || <span class="literal">NULL</span> == L)</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">  e = L.base[L.length - <span class="number">1</span>];</span><br><span class="line">  L.length--;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插入元素">插入元素</h2>
<p>时间复杂度：$O(n)$</p>
<ul>
<li>判断参数<code>i</code>是否合法，不合法则返回异常</li>
<li>判断表是否已满，已满则扩容</li>
<li>从最后一个元素遍历至第<code>i</code>个元素位置，全部后移一位</li>
<li>赋值，表长加1</li>
</ul>
<p><em>由于插入元素需要移动数组元素位置，算法效率不高，因此在频繁需要进行插入操作的问题中，应避免使用此结构</em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InsertList_Sq</span><span class="params">(SqList &amp;L, <span class="type">int</span> i, ElemType e)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	<span class="type">int</span> k;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; (L.length + <span class="number">1</span>)) </span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">if</span> (L.&gt;length == L.&gt;size) &#123;</span><br><span class="line">    	 newbase = (ElemType*)<span class="built_in">realloc</span>(L.base, (L.size + L.increcement) * <span class="built_in">sizeof</span>(ElemType));</span><br><span class="line">         <span class="keyword">if</span> (<span class="literal">NULL</span> == newbase)</span><br><span class="line">             <span class="keyword">return</span> OVERFLOW;</span><br><span class="line">          L.base = newbase;</span><br><span class="line">          L.size += L.increcement;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (i &lt; L.length + <span class="number">1</span>)   </span><br><span class="line">        <span class="keyword">for</span> (k = L.length - <span class="number">1</span>; k &gt; i - <span class="number">1</span>; k--)</span><br><span class="line">            L.base[k] = L.base[k - <span class="number">1</span>];</span><br><span class="line">    L.base[i - <span class="number">1</span>] = e;</span><br><span class="line">    L.lenght++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除元素">删除元素</h2>
<p>时间复杂度：$O(n)$</p>
<ul>
<li>判断参数<code>i</code>是否合法</li>
<li>判断表是否非空</li>
<li>取出删除元素</li>
<li>从被删元素位置开始向后遍历至最后一个元素，往前挪动一位</li>
<li>表长 - 1<br>
<em>同样地，删除元素也需要移动数组元素，故如需频繁删除元素，也应避免考虑顺序表</em></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">DelElem_Sq</span><span class="params">(SqList &amp;L, <span class="type">int</span> i, ElemType &amp;e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    </span><br><span class="line"> 	<span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length) </span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">if</span> (L.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; L.lengh) </span><br><span class="line">    	<span class="keyword">for</span> (k = i - <span class="number">1</span>; k &lt; L.length - <span class="number">1</span>; k++) </span><br><span class="line">         	L.base[k] = L.base[k + <span class="number">1</span>];   </span><br><span class="line">        </span><br><span class="line">    L.length--;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>顺序表的优缺点</h1>
<h2 id="优点">优点</h2>
<ul>
<li>无需为表示表中元素之间的逻辑关系而增加额外的存储空间</li>
<li>可以快速地存取表中任一位置的元素</li>
</ul>
<h2 id="缺点">缺点</h2>
<ul>
<li>插入和删除操作需要移动大量元素</li>
<li>当线性表长度变化较大时，难以确定存储空间的容量</li>
<li>造成存储空间的“碎片”</li>
</ul>
<h1>参考资料</h1>
<ul>
<li>《数据结构》（吴伟民，李小妹）</li>
<li>《大话数据结构》</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
        <tag>Data Structures</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-循环顺序队列</title>
    <url>/zh-CN/Data-structures-SqQueue/</url>
    <content><![CDATA[<ul>
<li>循环顺序队列的描述与表示</li>
<li>循环顺序队列的操作接口定义</li>
<li>循环顺序队列的操作实现</li>
</ul>
<span id="more"></span>
<h1>循环顺序队列的描述与表示</h1>
<h2 id="队列">队列</h2>
<p>队列(Queue)是一种只允许在序列两端进行操作的线性结构。和日常生活中排队等待买票的法则相似，排在队头的人先买到票并离开队列，而新来的人则加入队尾等候。因此很容易理解队列仅允许在队头出队，在队尾入队。</p>
<h2 id="循环顺序队列">循环顺序队列</h2>
<p>采用顺序存储结构的队列成为顺序队列，和顺序栈相同，我们也采用动态分配空间的方式来获取这个存储空间。那么何为循环队列呢？为什么我们需要循环队列呢？试想，我们在排队等候买票的时候是不是有这样的场景，前面的人买完票就离开队列，而这时后面的人是不是每个人都要往前挪动一个位置呢？那么如果我们以同样的方法来处理我们的队列，每当一个元素出队的时候，就必须把后面所有的元素往前挪动一个位置，这样必然导致算法效率变低。因此，我们想到了将队列的首位相连，构成了一个循环队列。</p>
<p>循环队列类型定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  ElemType* base;   <span class="comment">// 循环队列存储空间的基址</span></span><br><span class="line">  <span class="type">int</span> front;        <span class="comment">// 队头位标（指向队头元素的位置）</span></span><br><span class="line">  <span class="type">int</span> rear;         <span class="comment">// 队尾位标（指向队尾元素的下一个位置）</span></span><br><span class="line">  <span class="type">int</span> maxSize;      <span class="comment">// 队列的最大长度</span></span><br><span class="line">&#125; SqQueue;</span><br></pre></td></tr></table></figure>
<p>我们采用循环队列解决了元素出队时需要移动全部元素的问题，但是出现了一个新问题，在我们判空的时候我们采用的是判断队头位标和队尾位标是否一致的方式，而放在循环队列里，因为队列已经首尾相接，于是我们会发现这时候如果队列满了，队头位标和队尾位标也是一致的，解决方式有很多，比如：</p>
<ol>
<li>设置标志域标识队列的空或满，使用标志域数组同步记录</li>
<li>设置长度域记录队列中元素个数，判断长度域即可</li>
<li>少用一个元素空间，采用循环加一的方式，如果发现<code>Q.front == (Q.rear + 1) % Q.maxSize</code>则认为队满。</li>
</ol>
<p>以下的实现中我们采用了第三种方式。</p>
<h2 id="本文中预定义的说明">本文中预定义的说明</h2>
<h3 id="预定义常量和类型">预定义常量和类型</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数结果状态代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE      1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE     0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK        1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR     0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OVERFLOW -1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status; <span class="comment">// 用作函数值类型，表示函数结果状态</span></span><br></pre></td></tr></table></figure>
<h3 id="数据结构（存储结构）的表示">数据结构（存储结构）的表示</h3>
<p>数据结构的表示用类型定义(<code>typedef</code>)描述。数据元素类型约定为ElemType，读者在使用该数据类型时自行定义，如<code>int</code>、<code>char</code>等简单类型。</p>
<h3 id="扩展引用调用">扩展引用调用</h3>
<p>为了便于算法描述，我们使用了 C++ 语言中的引用调用参数传递方式。</p>
<h1>循环队列操作接口定义</h1>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造一个空队列 Q，最大队列长度为 size</span></span><br><span class="line">Status <span class="title function_">InitQueue_Sq</span><span class="params">(SqQueue &amp;Q, <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="comment">// 销毁队列 Q，Q不再存在</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DestroyQueue_Sq</span><span class="params">(SqQueue &amp;Q)</span>;</span><br><span class="line"><span class="comment">// 将队列置空</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ClearQueue_Sq</span><span class="params">(SqQueue &amp;Q)</span>;</span><br><span class="line"><span class="comment">// 判断队列是否为空，是返回 TRUE，否则返回 FALSE;</span></span><br><span class="line">Status <span class="title function_">QueueEmpty_Sq</span><span class="params">(Squeue Q)</span>;</span><br><span class="line"><span class="comment">// 返回队列 Q 中元素个数，即队列长度</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">QueueLength_Sq</span><span class="params">(SqQueue Q)</span>;</span><br><span class="line"><span class="comment">// 取队头元素，用 e 返回，并返回 OK，若队列为空，返回 ERROR</span></span><br><span class="line">Status <span class="title function_">GetHead_Sq</span><span class="params">(SqQueue Q, ElemType &amp;e)</span>;</span><br><span class="line"><span class="comment">// 元素 e 入队，即在队尾插入元素 e</span></span><br><span class="line">Status <span class="title function_">EnQueue_Sq</span><span class="params">(SqQueue &amp;Q, ElemType &amp;e)</span>;</span><br><span class="line"><span class="comment">// 队头元素出队，并用 e 返回</span></span><br><span class="line">Status <span class="title function_">DeQueue_Sq</span><span class="params">(SqQueue &amp;Q, ElemType &amp;e)</span>;</span><br></pre></td></tr></table></figure>
<h1>循环队列接口实现</h1>
<h2 id="初始化循环队列">初始化循环队列</h2>
<ul>
<li>分配存储空间</li>
<li>置队列为空</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">InitQueue_Sq</span><span class="params">(SqQueue &amp;Q, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">  Q.base = (ElemType*)<span class="built_in">malloc</span>(size * <span class="keyword">sizeof</span>(ElemType));</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">NULL</span> == Q.base)</span><br><span class="line">    <span class="keyword">return</span> OVERFLOW;</span><br><span class="line">  Q.maxSize = size;</span><br><span class="line">  Q.front = <span class="number">0</span>;</span><br><span class="line">  Q.rear = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="销毁队列">销毁队列</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DestroyQueue_Sq</span><span class="params">(SqQueue &amp;Q)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">free</span>(Q.base);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="将队列置空">将队列置空</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ClearQueue_Sq</span><span class="params">(SqQueue &amp;Q)</span></span><br><span class="line">&#123;</span><br><span class="line">  Q.front = <span class="number">0</span>;</span><br><span class="line">  Q.rear = <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="判断队列是否为空">判断队列是否为空</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">QueueEmpty_Sq</span><span class="params">(SqQueue Q)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (Q.front == Q.rear)</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="返回队列长度">返回队列长度</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">QueueLength_Sq</span><span class="params">(Squeue Q)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (Q.rear - Q.front + Q.maxSize) % Q.maxSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="取队头元素">取队头元素</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">GetHead_Sq</span><span class="params">(SqQueue Q, ElemType &amp;e)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (QueueEmpty_Sq(Q))</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">  e = Q.base[Q.front];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="入队">入队</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">EnQueue_Sq</span><span class="params">(SqQueue &amp;Q, ElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ((Q.rear + <span class="number">1</span>) % Q.maxSize == Q.front)</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">  Q.base[Q.rear] = e;</span><br><span class="line">  Q.rear = (Q.rear + <span class="number">1</span>) % Q.maxSize;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span>  OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="出队">出队</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">DeQueue_Sq</span><span class="params">(SqQueue &amp;Q, ElemType &amp;e)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (Q.front == Q.rear)</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">  e = Q.base[Q.front];</span><br><span class="line">  Q.front = (Q.front + <span class="number">1</span>) % Q.maxSize;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>小结</h1>
<p>队列的方式也成为排队。我们前面举例了排队排票的例子，而队列的产生实际上是由于随机前来的购票乘客数量和售票处的处理速度不相符，通过排队起到缓冲作用。程序中也是类似的，为了协调好数据输入和处理时间的关系，采用类似于排队的机制。再内从上，实现这种机制的方式就是队列。当我们需要处理通讯中发送的数据时，或由同时运行的多个程序所发送过来的数据时，会使用这种对队列中存储的不规则数据进行处理的方法。队列一般以环状缓冲区(ring buffer)也就是我们说的循环队列的方式来实现。</p>
<h1>参考资料</h1>
<ul>
<li>
<p>《数据结构》（吴伟民，李小妹）</p>
</li>
<li>
<p>《程序是怎样跑起来的》</p>
</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
        <tag>Data Structures</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-顺序栈</title>
    <url>/zh-CN/Data-structures-SqStack/</url>
    <content><![CDATA[<ul>
<li>顺序栈的描述与表示</li>
<li>顺序栈的操作接口定义</li>
<li>顺序栈的操作实现</li>
</ul>
<span id="more"></span>
<h1>顺序栈的描述与表示</h1>
<h2 id="栈">栈</h2>
<p>栈(Stack)是一种只允许在序列末端进行操作的线性结构。栈实现的是一种后进先出(Last In First Out, LIFO)策略或称先进后出（First In Last Out, FILO)，被删除的是最近插入的元素。栈与手枪中使用弹夹相似。在向弹夹装填子弹时，只能逐颗将子弹压入弹夹，最后压入的子弹位于弹夹顶部；射击时，弹夹顶部的子弹将最先被射出。</p>
<h3 id="顺序栈">顺序栈</h3>
<p>采用顺序存储结构的栈称为顺序栈，需要用一片地址连续的存储空间来存储栈的元素。根据这个特性，我们很容易想到通过一个简单的一维数组来实现这种结构，并指定栈顶位于序列末端。当有新元素入栈或栈顶元素出栈我们只需要改变栈顶位标即可。<br>
C语言中一维数组的大小是预先确定的，存满后无法继续插入新元素，所以我们将采用动态分配连续一块连续空间来存储栈元素，栈满时，通过重新分配更大空间进行扩容。</p>
<p>顺序栈类型定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  ElemType * base; <span class="comment">// 存储空间的基址</span></span><br><span class="line">  <span class="type">int</span> top; <span class="comment">// 栈顶元素的下一个位置，简称栈顶位标</span></span><br><span class="line">  <span class="type">int</span> size; <span class="comment">// 当前分配的存储容量</span></span><br><span class="line">  <span class="type">int</span> increment; <span class="comment">// 扩容时，增加的存储容量</span></span><br><span class="line">&#125; SqStack; <span class="comment">//顺序栈</span></span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong><br>
这里我们将栈顶位标<code>top</code>设置为栈顶元素的下一个位置，也有些做法是将栈顶位标设置为栈顶元素的位置，或者将其设置为指向栈顶元素位置的指针。本人查阅了一些资料，似乎没有看到关于这一点孰优孰劣的评论或分析，如有读者知晓，望指教。</p>
<h2 id="本文中预定义的说明">本文中预定义的说明</h2>
<h3 id="预定义常量和类型">预定义常量和类型</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数结果状态代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE      1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE     0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK        1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR     0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OVERFLOW -1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status; <span class="comment">// 用作函数值类型，表示函数结果状态</span></span><br></pre></td></tr></table></figure>
<h3 id="数据结构（存储结构）的表示">数据结构（存储结构）的表示</h3>
<p>数据结构的表示用类型定义(<code>typedef</code>)描述。数据元素类型约定为ElemType，读者在使用该数据类型时自行定义，如<code>int</code>、<code>char</code>等简单类型。</p>
<h3 id="扩展引用调用">扩展引用调用</h3>
<p>为了便于算法描述，我们使用了 C++ 语言中的引用调用参数传递方式。</p>
<h1>顺序栈操作接口定义</h1>
<p>作为一个存储结构，自然需要关心元素的存取问题。栈上的 INSERT 操作称为压入(PUSH)，而无元素参数的 DELETE 操作称为弹出(POP)。除了入栈、出栈操作，栈的操作还有初始化，销毁，判空等常用操作，我们定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化顺序栈 S</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitStack_Sq</span><span class="params">(SqStack &amp;S, <span class="type">int</span> size, <span class="type">int</span> inc)</span></span>;</span><br><span class="line"><span class="comment">// 销毁顺序栈</span></span><br><span class="line"><span class="function">Status <span class="title">DestoryStack_Sq</span><span class="params">(SqStack &amp;S)</span></span>;</span><br><span class="line"><span class="comment">// 判断顺序栈 S 是否为空，若为空则返回 TURE，否则返回 FALSE</span></span><br><span class="line"><span class="function">Status <span class="title">StackEmpty_Sq</span><span class="params">(SqStack S)</span></span>;</span><br><span class="line"><span class="comment">// 清空顺序栈 S （无元素，空栈，注意与 销毁顺序栈区别）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ClearStack_Sq</span><span class="params">(SqStack &amp;S)</span></span>;</span><br><span class="line"><span class="comment">// 元素压入顺序栈 S</span></span><br><span class="line"><span class="function">Status <span class="title">Push_Sq</span><span class="params">(SqStack &amp;S, ElemType e)</span></span>;</span><br><span class="line"><span class="comment">// 顺序栈 S 栈顶元素出栈，并用 e 返回</span></span><br><span class="line"><span class="function">Status <span class="title">Pop_Sq</span><span class="params">(SqStack &amp;S, ElemType &amp;e)</span></span>;</span><br><span class="line"><span class="comment">// 取栈 S 的栈顶元素，并用 e 返回（与出栈区别）</span></span><br><span class="line"><span class="function">Status <span class="title">GetTop_Sq</span><span class="params">(SqStack S, ElemType &amp;e)</span></span>;</span><br></pre></td></tr></table></figure>
<h1>顺序栈操作的实现</h1>
<h2 id="初始化顺序栈">初始化顺序栈</h2>
<p>根据顺序栈的类型定义，在顺序栈的初始化中，我们需要进行以下操作：</p>
<ul>
<li>分配存储空间</li>
<li>置栈为空栈</li>
<li>初始化栈的大小</li>
<li>初始化栈满时的增量<br>
时间复杂度为$O(1)$.</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">InitStack_Sq</span><span class="params">(SqStack &amp;S, <span class="type">int</span> size, <span class="type">int</span> inc)</span></span><br><span class="line">&#123;</span><br><span class="line">  S.base = (ElemType*)<span class="built_in">malloc</span>(size * <span class="keyword">sizeof</span>(ElemType));</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">NULL</span> == S.base)</span><br><span class="line">  <span class="comment">/*allocation failed*/</span></span><br><span class="line">    <span class="keyword">return</span> OVERFLOW;</span><br><span class="line">  S.top = <span class="number">0</span>;</span><br><span class="line">  S.size = size;</span><br><span class="line">  S.increment = inc;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> OK;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong><br>
当调用内存分配函数时，存在找不到足够大小的内存块的可能性，这时函数将返回空指针。因此在我们分配顺序栈基址时应当测试内存分配函数的返回值，并在返回空指针时采取相应操作，试图通过空指针访问内存的效果是未定义的，程序可能会崩溃或者出现不可预测的行为。</p>
<h2 id="销毁顺序栈">销毁顺序栈</h2>
<p>通过调用 <code>free</code> 函数来释放 <code>InitStack_Sq</code> 中分配的空间。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DestoryStack_Sq</span><span class="params">(SqStack &amp;S)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">free</span>(S.base);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong><br>
<code>free</code> 函数的实际参数必须是先前由内存分配函数返回的指针，如果这个指针已经被修改，可能将导致未定义的行为。而若参数为空指针，函数<code>free</code>的调用将不起到任何作用。</p>
<h2 id="顺序栈判空">顺序栈判空</h2>
<p>我们在顺序栈的类型定义中定义了栈顶位标，因此判断顺序栈是否为空，只需要判断栈顶位标是否为 0 即可。<br>
时间复杂度为$O(1)$.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">StackEmpty_Sq</span><span class="params">(SqStack S)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (S.top &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> TURE;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="清空顺序栈">清空顺序栈</h2>
<p>清空顺序栈 S 即将 S 置为空栈，只要对栈顶位标进行修改即可，原来的元素仍在数组里，但已经不在栈里了。<br>
时间复杂度为$O(1)$.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ClearStack_Sq</span><span class="params">(SqStack &amp;S)</span></span><br><span class="line">&#123;</span><br><span class="line">  S.top = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="入栈">入栈</h2>
<p>首先应检查此时是否已经栈满，若栈满，则应该扩容。由于栈顶位标指向的是栈顶元素的下一个位置，因此只需要将新的元素放入栈顶位标 <code>S.top</code> 所指示的位置，并将栈顶位标加一即可。<br>
时间复杂度为$O(1)$.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">Push_Sq</span><span class="params">(SqStack &amp;S, ElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">  ElemType* newbase;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (S.top &gt;= S.size) &#123;</span><br><span class="line">    newbase = (ElemType*)<span class="built_in">realloc</span>(S.base, (S.size + S.increment) * <span class="keyword">sizeof</span>(ElemType));</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> ==  newbase)</span><br><span class="line">      <span class="keyword">return</span> OVERFLOW;</span><br><span class="line">    S.base = newbase;</span><br><span class="line">    S.size += S.increment;</span><br><span class="line">  &#125;</span><br><span class="line">  S.base[S.top] = e;</span><br><span class="line">  S.top++;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ul>
<li>判断是否栈满实际上只需要使用<code>==</code>即可，这里使用<code>&gt;=</code>是为了防止误操作使栈顶位标大于<code>S.size</code>的情况。</li>
<li>如果<code>realloc</code>函数不能按要求扩大内存块，那么它将会返回空指针，而原有的内存块中的数据不会发生改变。</li>
<li>一旦<code>realloc</code>函数返回，一定要对内存块的所有指针进行更新，因为<code>realloc</code>函数可能会使内存块移动到了其他地方。在要求扩大内存块大小时，<code>realloc</code>会在「原先的内存块」上直接进行缩减，而不需要移动存储在内存块中的数据。如果无法扩大内存块（内存块后面的字节已经用于其他目的），<code>realloc</code>函数会在别处分配新的内存块，然后将旧的内存块中的内容复制到新的内存块中。</li>
</ul>
<h2 id="出栈">出栈</h2>
<p>出栈前应该先检查栈是否非空，如果为空栈，则报错，否则用元素 e 返回，并对栈顶位标减一。<br>
时间复杂度$O(1)$.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">Pop_Sq</span><span class="params">(SqStack &amp;S, ElemType &amp;e)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (S.top &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">  S.top--;</span><br><span class="line">  e = S.base[S.top];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="取栈顶元素">取栈顶元素</h2>
<p>同样地，在取栈顶元素之前，我们需要先判断栈是否非空，若空则报错，否则用元素 e 返回栈顶元素的值，此时不需要改动栈顶位标。<br>
时间复杂度$O(1)$.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">GetTop_Sq</span><span class="params">(SqStack S, ElemType &amp;e)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (S.top &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">  e = S.base[S.top - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>小结</h1>
<p>“栈”的原意是”干草堆积如山“。干草堆时用来临时保存家禽饲料的方式，在取用时，最后堆的干草会被最先取出来。而在程序中也是类似的，为了实现临时保存数据的目的，使用类似于干草推的机制，这种机制体现在内存上，就是栈。当我们需要暂时舍弃当前的数据，随后再原貌还原时，就会使用栈。</p>
<h1>参考资料</h1>
<ul>
<li>《数据结构》（高教版，吴伟民，李小妹）</li>
<li>《算法导论》（第三版）</li>
<li>《C语言程序设计现代方法》（第二版）</li>
<li>《程序是怎样跑起来的》</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
        <tag>Data Structures</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构-图的相关定义</title>
    <url>/zh-CN/Data-structures-graph/</url>
    <content><![CDATA[<p>图是一种比树形结构更复杂的非线性结构。在图结构中，允许多个结点之间相关，称为「多对多」关系。本文整理关于图的基本定义以及图的相关术语。</p>
<span id="more"></span>
<h1>图的定义</h1>
<p>在图中，通常将数据元素称为<strong>顶点</strong>(Vertex)，顶点之间的关系称为<strong>边</strong>(Edge)。</p>
<p><strong>图</strong>(Graph)由有限点集$V$和有限边集$E$组成，记为<br>
$$<br>
G = (V, E)<br>
$$</p>
<p>顶点总数$|V|$记为$n$，边的总数$E$记为$e$。</p>
<ol>
<li>有向图</li>
</ol>
<p>用$&lt;v, w&gt;$表示从顶点$v$指向顶点$w$的<strong>有向边</strong>，也称为<strong>弧</strong>(Arc)，$v$为<strong>起点</strong>，$w$为<strong>终点</strong>，起点与终点次序不能颠倒。当图中的边均为有向边，则称图为<strong>有向图</strong>(Digraph)。</p>
<ol start="2">
<li>无向图</li>
</ol>
<p>若边集$E$是对称的，即当$&lt;v,w&gt;\in E$ ，有$&lt;w,v&gt;\in E$，则称为<strong>无向图</strong>。此时用无序对$(v,w)$代替有序对$&lt;v,w&gt;$和$&lt;w,v&gt;$，称为<strong>无向边</strong>，简称<strong>边</strong>。</p>
<ol start="3">
<li>子图</li>
</ol>
<p>若图$G = (V, E), G’ = (V’, E’)$，当$V’\subseteq V, E’ \subseteq E$，则称$G’$为$G$的子图。</p>
<ol start="4">
<li>
<p>完全图</p>
<p>包含所有可能的边的图称为<strong>完全图</strong>。</p>
<ul>
<li>无向完全图包含$n(n-1)/2$条边。</li>
<li>有向完全图包含$n(n - 1)$条弧。</li>
</ul>
</li>
<li>
<p>邻接顶点</p>
<ul>
<li>在无向图中，若存在边$(v, w)$，则称$v$和$w$互为<strong>邻接顶点</strong>(Adjacent Verices)，或称$v$和$w$相邻接。</li>
<li>在有向图中，若存在弧$&lt;v, w&gt;$，则称$w$是$v$的邻接顶点，但$v$未必是$w$的邻接顶点。</li>
</ul>
</li>
<li>
<p>度</p>
<p>在图中，顶点的<strong>度</strong>(Degree)指依附于该顶点的边数。</p>
<p>对于有向图，又分为<strong>出度</strong>(OutDegree)和<strong>入度</strong>(InDegree)。</p>
<ul>
<li>出度：以该顶点为起点的弧的数目。</li>
<li>入度：以该顶点为终点的弧的数目。</li>
<li>有向图顶点的度为出度和入度之和。</li>
</ul>
</li>
<li>
<p>权</p>
<p>当图中的边或弧具有附加属性信息时，将此信息称为<strong>权</strong>(Weight)。</p>
<p>带权的图称为<strong>带权图</strong>，简称为<strong>网</strong>(Network)。</p>
</li>
<li>
<p>路径</p>
<p>如果顶点序列$(v_1, v_2, \cdots, v_n)$从$v_i$到$v_{i+1}(1 \le i &lt;n)$的边（弧）均存在，则称顶点序列$(v_1, v_2, \cdots, v_n)$构成一条长度为$n-1$的<strong>路径</strong>。</p>
<ul>
<li><strong>路径长度</strong>：路径包含的边数。</li>
<li><strong>简单路径</strong>：路径上的顶点各不相同。</li>
<li><strong>回路</strong>：一条路径将某个顶点连接到自身。</li>
</ul>
</li>
<li>
<p>连通图和强连通图</p>
<ul>
<li>
<p><strong>连通图</strong></p>
<p>在无向图中，若顶点$v$到顶点$w$有路径，则称$v$和$w$是连通的。若图中任意两个顶点都是连通的，则称该图为<strong>连通图</strong>(Connected Graph)。</p>
<ul>
<li><strong>连通分量</strong>(Connected Component)：无向图中的极大连通子图。</li>
</ul>
</li>
<li>
<p><strong>强连通图</strong></p>
<p>在有向图中，若图中任意两个顶点$v$和$w$，既有$v$到$w$的路径，又有$w$到$v$的路径，则称该图为<strong>强连通图</strong>(Strongly Connected Graph)。</p>
<ul>
<li><strong>强连通分量</strong>(Strongly Connected Component)：有向图中的极大强连通子图。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>生成树</p>
<p>连通图的<strong>生成树</strong>(Spanning Tree)是含有所有顶点且只有$n-1$条边的连通子图。</p>
</li>
</ol>
<h1>参考资料</h1>
<ul>
<li>《数据结构》（高教版，吴伟民，李小妹）</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Data Structures</tag>
      </tags>
  </entry>
  <entry>
    <title>数据类型选择</title>
    <url>/zh-CN/Data-type-choose/</url>
    <content><![CDATA[<p>偶然发现关于数据类型选择之前没注意到的点，做此记录。</p>
<ul>
<li>整型</li>
<li>浮点型</li>
<li>字符型（字符型实际上属于整型的一种，但这里分开讨论）</li>
</ul>
<span id="more"></span>
<h1>整型</h1>
<h2 id="取值范围">取值范围</h2>
<p>整型类型的取值范围会根据机器的不同而不同，但规定了如下最小值：</p>
<blockquote>
<ul>
<li><code>short int</code> 至少 16  位</li>
<li><code>int</code> 至少 16 位</li>
<li><code>long int</code> 至少 32 位</li>
<li><code>long long int</code> 至少 64 位</li>
</ul>
</blockquote>
<p>听上去长整型应该比短整型所能表示的值要大，但是这个假设并不一定正确。整型值之间相互的大小规则如下：</p>
<blockquote>
<ul>
<li><code>int </code>类型不能比<code>short int</code>类型短</li>
<li><code>long int</code>类型不能比<code>int</code>类型短</li>
</ul>
</blockquote>
<p>而标准并没有规定3个数值必须不同，因此基于上述规则，如果某机器的环境字长是32位，且没有指令能更有效处理更短的整型值时，可能上述提到的3个整型值都为32位。</p>
<p>当数值超过<code>int</code>表示的范围时，选用<code>long long int</code>。</p>
<p>对于特定的实现，确定整数类型范围的一种方法是检查<code>&lt;limits.h&gt;</code>。</p>
<h2 id="浮点型">浮点型</h2>
<ul>
<li>浮点数字面值在缺省情况下是<code>double</code>类型。</li>
<li>执行浮点数运算时选用<code>double</code>类型，精度高于<code>float</code>类型，而实际上单精度和双精度的计算代价相差无几，甚至有些机器运算双精度浮点数更快。</li>
<li><code>long double</code>提供扩展精度，但一般情况下没有必要，且会带来运行消耗。</li>
</ul>
<h2 id="字符型">字符型</h2>
<p>字符在本质上是小整型值。标准中没有规定<code>char</code>类型缺省是无符号型还是有符号型，取决于编译器，有些编译器将其作为有符号数来处理，有些编译器作为无符号数来处理，而另有一些编译器提供编译选项来选择<code>char</code>的类型。</p>
<ul>
<li>
<p>为了保持最佳的可移植性，把字符的值限制在有符号和无符号范围的交集之间</p>
</li>
<li>
<p>显示地将这类变量声明为<code>signed</code>或<code>unsigned</code>，可以提高可移植性，确保在不同的机器中在字符是否有符号方面保持一致。</p>
</li>
<li>
<p>只有当<code>char</code>类型显示声明了符号类型时才对其进行算术运算。</p>
</li>
<li>
<p>许多处理字符的库函数将参数声明为<code>char</code>，而若将参数显示声明为<code>signed</code>或<code>unsigned</code>时可能会带来兼容性问题。</p>
</li>
</ul>
<h1>参考资料</h1>
<ul>
<li>《C++ Primer 中文版 （第5版）》</li>
<li>《C 和指针》</li>
<li>《C语言程序设计现代方法 第2版》</li>
<li><a href = "https://stackoverflow.com/questions/1074474/should-i-use-double-or-float">c++ - Sholud I usedoble or float? - Stack Overflow</a></li>
</ul>
]]></content>
      <categories>
        <category>技术杂谈</category>
      </categories>
  </entry>
  <entry>
    <title>将本地已存在文件夹推送至远程仓库</title>
    <url>/zh-CN/Github-git-push-problem/</url>
    <content><![CDATA[<p>有时候我们可能会遇到当文件累积到了一定程度的时候，想使用 git 进行版本管理，或者推送到 Github 等远程仓库上。本文介绍如何将一个本地文件夹中已经存在的内容使用 git 进行管理，并推送至远程仓库，以及对其中可能出现的错误进行分析。</p>
<span id="more"></span>
<h2 id="创建-git-仓库">创建 git 仓库</h2>
<p>在该文件夹下初始化仓库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>
<p>此时将会在此文件夹下创建一个空的仓库，产生一个 <code>.git</code>文件，会看到以下提示：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">Initialized empty Git repository <span class="keyword">in</span> FOLDERPATH<span class="regexp">/.git/</span></span><br></pre></td></tr></table></figure>
<h2 id="将文件添加到暂存区">将文件添加到暂存区</h2>
<p>使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>
<p>此操作会将当前文件夹中所有文件添加到 git 仓库暂存区。</p>
<h2 id="将文件提交到仓库">将文件提交到仓库</h2>
<p><code>git add</code> 命令仅仅将文件暂存，但实际上还没有提交，实际上仓库中并没有这些文件，使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit</span><br></pre></td></tr></table></figure>
<p>此时将会打开一个文件，用于记录提交说明，输入提交说明即可，若说明较为简短，也可以使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;YOUR COMMENT&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="添加远程仓库">添加远程仓库</h2>
<p>使用以下命令添加添加一个远程仓库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add origin YOUR_REMOTE_REPOSITORY_URL</span><br></pre></td></tr></table></figure>
<p>其中 origin 相当于给远程仓库的名称，也就是相当于一个标识符。</p>
<h2 id="推送至远程仓库">推送至远程仓库</h2>
<p>使用以下命令将会将本地仓库中的内容推送至远程仓库的 master 分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：如果之前忘记了<code>git commit</code> 的步骤，这里将会出现一个错误提示：</p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line"><span class="keyword">error: </span>src refspec master does not match any.</span><br></pre></td></tr></table></figure>
<p>为什么会有这个报错呢？原因其实很简单，在没有使用 <code>git commit</code> 之前，由于这是一个新创建的<code>git</code>仓库，没有<code>master brench</code>，也就是并没有一个工作树可供推送至远程仓库，所以自然也就出错啦。</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li>
<p>《Github 入门与实践》</p>
</li>
<li>
<p><a href="https://georgik.rocks/common-mistake-when-creating-new-git-repo/">Common mistake when creating new git repo. Error: src refspec master does not match any.</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>JS-jQuery Zoom 使用</title>
    <url>/zh-CN/JS-jquery-Zoom/</url>
    <content><![CDATA[<p>本文介绍如何使用 <a href="https://www.jacklmoore.com/zoom/">Jquery Zoom</a> 放大图片。</p>
<span id="more"></span>
<h1>基本使用</h1>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- jQuery Required 1.7+ --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdnjs.cloudflare.com/ajax/libs/jquery-zoom/1.7.21/jquery.zoom.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>&lt;img&gt;</code> 标签需置于某个合法的 HTML 标签内，如 <code>&lt;div&gt; &lt;figure&gt; ...</code> ， 而使用 <code>zoom()</code> 的元素应该是 <code>&lt;img&gt;</code> 的 <code>Parent Elemnt</code> 。</p>
<h2 id="启用-zoom：">启用 zoom：</h2>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">figure</span> <span class="attr">id</span>=<span class="string">&quot;example&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://example.com/example.png&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">figure</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 最简单的启用方式 */</span></span><br><span class="line">$(<span class="string">&#x27;#example&#x27;</span>).<span class="title function_">zoom</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 通常需要配置 zoom 参数 */</span></span><br><span class="line">$(<span class="string">&#x27;#example&#x27;</span>).<span class="title function_">zoom</span>(&#123;</span><br><span class="line">    <span class="attr">property1</span>: value1, </span><br><span class="line">    <span class="attr">property2</span>: value2,</span><br><span class="line">    ... </span><br><span class="line">    <span class="attr">propertyN</span>: valueN</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="禁用-zoom">禁用 zoom</h2>
<p>以下是zoom的禁用方式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;#example&#x27;</span>).<span class="title function_">trigger</span>(<span class="string">&#x27;zoom.destroy&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>比如你可以使用一个checkbox来控制zoom的启用和关闭。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;input:checkbox&quot;</span>).<span class="title function_">change</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">if</span> ($(<span class="string">&quot;input:checked&quot;</span>).<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    $(<span class="string">&#x27;#example&#x27;</span>).<span class="title function_">trigger</span>(<span class="string">&#x27;zoom.destroy&#x27;</span>); </span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">   	$(<span class="string">&#x27;#example&#x27;</span>).<span class="title function_">zoom</span>(&#123;</span><br><span class="line"></span><br><span class="line">        <span class="attr">magnify</span>: <span class="number">2</span></span><br><span class="line">    &#125;); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1>属性值配置</h1>
<h2 id="url">url</h2>
<p><code>zoom</code> 图片源。</p>
<p>值 ： <code>false</code> | URL</p>
<p>默认取 <code>&lt;img&gt;</code> 中的 <code>src</code> 作为放大图片源。当填写具体 <code>url</code> 时将取该 <code>url</code> 作为放大图片源。</p>
<p>使用时可以将像素较低的图片放在 <code>&lt;img src=&quot;&quot;&gt;</code> 中，像素较高的放在 <code>zoom</code> 属性中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;#example&#x27;</span>).<span class="title function_">zoom</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&quot;https://example.com/example.png&quot;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="on">on</h2>
<p>触发 <code>zoom</code> 的方式。</p>
<ul>
<li><code>'mouseover'</code>: 默认值，鼠标经过时放大；</li>
<li><code>'grab'</code> ：鼠标左键保持按下时放大点击的地方，挪出图片区域或松开后复原；</li>
<li><code>'click'</code> :  鼠标左键点击后保持放大状态，经过时放大经过地方，挪出图片区域保持放大, 跟随鼠标移动的动作放大图片，再次点击后复原；</li>
<li><code>'toggle'</code>：仅放大鼠标左键点击的地方，再次点击时复原。</li>
</ul>
<p>建议使用不同触发事件时配合使用不同的 <code>cursor</code> <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/cursor">CSS 样式</a> 作为指示。</p>
<h2 id="duration">duration</h2>
<p>渐入渐出时，数值越大渐出越缓慢，默认为120。</p>
<p>内部调用的是 jQuery 的 <a href="https://api.jquery.com/fadeTo/">.fadeTo()</a> ，单位是毫秒。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;#example&#x27;</span>).<span class="title function_">zoom</span>(&#123;</span><br><span class="line">    <span class="attr">duration</span>: <span class="number">1000</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="target">target</h2>
<p>CSS Selector. 通过设定该属性，可以使图片不在原图片显示区域放大，而在选定的 HTML Element 上呈现放大图像，原图像保持不变。</p>
<p>下面的代码将会把放大的图像显示在 <code>id</code> 为 <code>myTarget</code> 的 <code>div</code> 中，而原来的图像保持不变。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">figure</span> <span class="attr">id</span>=<span class="string">&quot;example&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://example.com/example.png&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">figure</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myTarget&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;#example&#x27;</span>).<span class="title function_">zoom</span>(&#123;</span><br><span class="line">    <span class="attr">target</span>: <span class="string">&#x27;#myTarget&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="touch">touch</h2>
<p>是否启用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Touch_events">touch events</a>, 默认启用。</p>
<h3 id="magnify">magnify</h3>
<p>放大倍数。默认值为1，即不放大。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;#example&#x27;</span>).<span class="title function_">zoom</span>(&#123;</span><br><span class="line">    <span class="attr">magnify</span>: <span class="number">2</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="callback-onZoomIn-onZoomOut">callback/onZoomIn/onZoomOut</h2>
<p>三个属性用法一样：</p>
<ul>
<li><code>callback</code> ：图片加载完成后的回调函数</li>
<li><code>onZoomIn</code> ：图片放大时调用的函数</li>
<li><code>onZoomOut</code> ：图片复原时调用的函数</li>
</ul>
<p>下面代码将在图片放大时将测试文本变为红色，图片恢复时将测试文本变为黑色。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;#example&#x27;</span>).<span class="title function_">zoom</span>(&#123;</span><br><span class="line">    <span class="attr">onZoomIn</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        $(<span class="string">&#x27;#testZoomStatus&#x27;</span>).<span class="title function_">css</span>(<span class="string">&#x27;color&#x27;</span>, <span class="string">&#x27;red&#x27;</span>);</span><br><span class="line">  &#125;, </span><br><span class="line">    <span class="attr">onZoomOut</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        $(<span class="string">&#x27;#testZoomStatus&#x27;</span>).<span class="title function_">css</span>(<span class="string">&#x27;color&#x27;</span>, <span class="string">&#x27;black&#x27;</span>);     </span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1>参考资料</h1>
<p><a href="https://www.jacklmoore.com/zoom/">jQuery Zoom</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS-监听窗口关闭</title>
    <url>/zh-CN/JS-listen-browser-window-close/</url>
    <content><![CDATA[<p>JavaScript 监听窗口关闭。初学JavaScript，如有不当请指正。</p>
<span id="more"></span>
<p>接手的项目中有这样一个场景：</p>
<ol>
<li>
<p>点击打印按钮，生成需要临时文件存储在项目内（该步骤为水晶报表生成打印文件必须进行的流程）；</p>
</li>
<li>
<p>弹出新窗口，显示即将打印的文件名和下载按钮供用户确认；</p>
</li>
<li>
<p>用户点击下载按钮，浏览器启动下载；</p>
</li>
<li>
<p>用户关闭窗口，系统删除生成的临时文件。</p>
</li>
</ol>
<p>原有的处理方式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="variable language_">window</span>.<span class="title function_">onbeforeunload</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_">with</span>(<span class="variable language_">window</span>.<span class="property">event</span>) <span class="keyword">if</span> (clientY&lt;<span class="number">0</span>&amp;&amp;clientX+<span class="number">40</span>&gt;<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">clientWidth</span>||altKey)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_">deletePDF</span>(); <span class="comment">// 为了便于表示，将原有的此处代码块写作一个函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原有的写法在 Visual Studio 2015 中编辑器环境下会提示语法错误，但在 Debug / Run 过程中，在其他浏览器中均不会弹出错误提示，但没有跑进 <code>deletePDF()</code> 函数中，在 IE 的测试中部分测试环境会弹出错误弹窗提示：</p>
<blockquote>
<p>JavaScript critical error at … in … \n\nSCRIPT1002: Syntax error</p>
</blockquote>
<p>点击 Continue 后与其他浏览器类似，并不会影响文件下载，同样未进入 <code>deletePDF()</code> 函数。</p>
<h1>onbeforeunload/beforeunload</h1>
<p>查询 MDN 的 <a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onbeforeunload">文档</a><sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup> ，<code>onbeforeunload</code> 是 <code>beforeunload</code> 的处理程序。语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onbeforeunload</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123; ... &#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;beforeunload&quot;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123; ... &#125;);</span><br></pre></td></tr></table></figure>
<p><em>MDN 建议使用第二种语法。</em> 根据 <a href="https://stackoverflow.com/a/20001174/8257973">javascript - beforeunload Or onbeforeunload - Stack Overflow</a><sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup> ，第一种语法取代原有的处理程序，第二种语法新增一个处理程序。</p>
<p>分别使用上述两种语法修改原有的处理函数，原有的函数中的第 3 行存在语法错误，该语句用于判断鼠标的位置，将该语句移除后将会出现多次触发 <code>onbeforeunload</code> 的情况：</p>
<ul>
<li>
<p>页面刚进入时</p>
</li>
<li>
<p>点击下载按钮时</p>
</li>
<li>
<p>关闭窗口时</p>
</li>
</ul>
<p>以上情况将导致在文件未下载成功前，已进入 <code>deletePDF</code> ，临时文件已被删除无法下载。</p>
<p>实际上，<code>beforeunload</code> 会在多种情况下被触发，包括但不限于提交表单，点击链接/按钮，关闭窗口或标签，通过地址栏，搜索栏，书签等方式访问新页面。</p>
<p>因此，尽管 <code>addEventListener</code> 实现了关闭窗口的监听，却会在关闭窗口前就执行了相关操作。</p>
<p>尝试使用原有的处理方式中的 <code>event.ClientY</code> 进行下一步限制，但实际上仅仅使用 <code>ClientY</code> 将只能检测鼠标的工作情况，而无法检测通过快捷键关闭的情况，原有的处理方式同时检测了 <code>alt</code> 键，但这将导致所有的 <code>alt</code> 快捷键触发。且测试中 <code>event.ClientY</code> 并未起作用，原因尚未查明。</p>
<h1>addEventListener/removeEventListener</h1>
<p>与 <code>addEventListener</code> 对应的方法是 <code>removeEventListener</code> 。这两个方法在不支持 IE 9 以下版本。如果要在 IE9 以下版本使用，应该使用 <code>attachEvent</code> （实际上 MDN 不建议使用 <code>attachEvent</code> ）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">attachEvent</span>) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">attachEvent</span>(<span class="string">&quot;beforeunload&quot;</span>, <span class="title function_">deletePDF</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">addEventListener</span>) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;beforeunload&quot;</span>, <span class="title function_">deletePDF</span>(), <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过几次尝试，结合 MDN 的文档，<code>addEventListener</code> 与 <code>removeEventListener</code> 必须完全一致，也即，无法添加 <code>window.addEventListner</code> 而移除 <code>button.removeEventListeneer</code> 。</p>
<h1>jQuery on/off bind/unbind</h1>
<p>在检测关闭窗口并禁止提交触发的实践中，常用的方式还有使用 <code>jQuery</code> ：<code>on/off</code> <code>bind/unbind</code> 。其中 <code>on/off</code> 在 jQuery 1.7 中取代 <code>bind/unbind</code> 。由于项目较老旧，使用的 jQuery 1.2，故使用 <code>bind/unbind</code> 测试。测试中并未进入 <code>deletePDF</code> 函数，原因尚未查明。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;[id$=&#x27;_btnDownload&#x27;]&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    $(<span class="variable language_">window</span>).<span class="title function_">unbind</span>(<span class="string">&quot;beforeunload&quot;</span>);</span><br><span class="line">    <span class="comment">// $(window).off(&quot;beforeunload&quot;);</span></span><br><span class="line">&#125;)</span><br><span class="line">$(<span class="variable language_">window</span>).<span class="title function_">bind</span>(<span class="string">&quot;beforeunload&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">//$(window).on(&quot;beforeunload&quot;, function() &#123;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1>添加标志位检测</h1>
<p>考虑添加一个监听事件，当按钮按下时变更标志位，标记此次操作触发方式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> download = <span class="literal">false</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    download = <span class="literal">true</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;beforeunload&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (download)</span><br><span class="line">        download = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="title function_">deletePDF</span>();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>此代码可正常工作，但未知是否可能存在这样一种情况：</p>
<ol>
<li>
<p>用户1点击下载按钮，<code>download = true</code>;</p>
</li>
<li>
<p>用户2不进行下载直接关闭窗口，<code>download = true</code>;</p>
</li>
</ol>
<p>在这种情况下，用户2的操作产生的临时文件将不会被删除。在本地使用 Start without debug 调试，通过不同浏览器打开不同窗口，此代码可以正常工作。</p>
<h1>onunload/unload</h1>
<p>考虑需求，并不需要实现 <code>beforeunload</code> 中的离开弹窗提示，即可以直接使用 <code>unload</code> 事件，监听 <code>unload</code> 将不会在按钮按下时被触发，使用 <code>unload</code> 似乎更简洁。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;unload&quot;</span>, deletePDF);</span><br></pre></td></tr></table></figure>
<p><a href="https://developers.google.com/web/updates/2018/07/page-lifecycle-api#legacy-lifecycle-apis-to-avoid">Page Lifecycle API | Web | Google Developers</a><sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup> 指出：使用 <code>unload</code> , <code>beforeunload</code> 作为检查页面生命周期的方式并不可靠，尤其是 <code>unload</code> 在移动端极不可靠，建议使用 <code>pagehide</code>，而 <code>beforeunload</code> 适用于存在用户未保存的更改时离开页面的监听，并应该在保存后移除该监听事件，不应使用其作为判断页生命周期的方法。</p>
<p>根据该文章的建议，使用以下代码：</p>
<p>（原文使用的是 <code>const</code>， 但经过测试，IE 10及以下版本中并不支持 <code>const</code>）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> terminationEvent = <span class="string">&#x27;onpagehide&#x27;</span> <span class="keyword">in</span> self ? <span class="string">&#x27;pagehide&#x27;</span> : <span class="string">&#x27;unload&#x27;</span>;</span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(terminationEvent, deletePDF);</span><br></pre></td></tr></table></figure>
<p>该代码在本地测试除 Firefox 以外可正常使用，而该项目没有移动端需求，目前尚不能看出使用 <code>unload</code> 的劣势。</p>
<h1>参考资料</h1>
<ol>
<li>
<p><a href="https://zh.javascript.info/onload-ondomcontentloaded">页生命周期：DOMContentLoaded, load, beforeunload, unload</a></p>
</li>
<li>
<p><a href="https://stackoverflow.com/questions/1631959/how-to-capture-the-browser-window-close-event">javascript - How to capture the browser window close event? - Stack Overflow</a></p>
</li>
<li>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/beforeunload_event">Window: beforeunload event - Web APIs | MDN</a></p>
</li>
<li>
<p><a href="https://stackoverflow.com/questions/52745244/disable-js-beforeunload-if-button-with-specific-id-has-been-clicked">javascript - disable js beforeunload if button with specific id has been clicked - Stack Overflow</a></p>
</li>
<li>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener">EventTarget.removeEventListener() - Web APIs | MDN</a></p>
</li>
<li>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener">EventTarget.addEventListener() - Web APIs | MDN</a></p>
</li>
<li>
<p><a href="https://stackoverflow.com/questions/2657182/correct-usage-of-addeventlistener-attachevent">javascript - correct usage of addeventlistener attachevent - Stack Overflow</a></p>
</li>
<li>
<p><a href="https://dotblogs.com.tw/jasonyah/2013/05/31/jquery-confirm-when-user-leaving-page-if-changed">[jQuery] jQuery 實作離開網頁或表單前向使用者確認，以防止使用者誤觸離開按鈕 | 分享你的 Coding 新鮮事 - 點部落</a></p>
</li>
<li>
<p><a href="https://stackoverflow.com/questions/54155648/narrow-down-beforeunload-to-only-fire-if-field-is-changed-or-updated">javascript - Narrow Down BeforeUnload To Only Fire If Field Is Changed or Updated - Stack Overflow</a></p>
</li>
<li>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/unload_event">Window: unload event - Web APIs | MDN</a></p>
</li>
<li>
<p><a href="https://stackoverflow.com/questions/64273246/capture-close-window-by-beforeunload-but-exclude-asp-button/64311590#64311590">javascript - capture close window by beforeunload but exclude asp button - Stack Overflow</a></p>
</li>
</ol>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onbeforeunload">WindowEventHandlers.onbeforeunload - Web APIs | MDN</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p><a href="https://stackoverflow.com/questions/20001125/beforeunload-or-onbeforeunload">javascript - beforeunload Or onbeforeunload - Stack Overflow</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p><a href="https://developers.google.com/web/updates/2018/07/page-lifecycle-api#legacy-lifecycle-apis-to-avoid">Page Lifecycle API | Web | Google Developers</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Neo4j之Cypher语句</title>
    <url>/zh-CN/KG-Cypher-learning/</url>
    <content><![CDATA[<p>本文为图数据库 Neo4j 查询语言 Cypher 学习笔记，包括 <code>MATCH</code> <code>RETURN</code> <code>CREATE</code> <code>DELETE</code> <code>REMOVE</code> <code>MERGE</code> 语句的基本用法。</p>
<span id="more"></span>
<h1>MATCH</h1>
<p><code>MATCH</code> 语句用于查询，常与 <code>WHERE</code> 连用，与 SQL 语句中的 <code>SELECT ... FROM ... WHERE</code> 用法相似。</p>
<h2 id="查找节点">查找节点</h2>
<h3 id="查找所有节点">查找所有节点</h3>
<p>以下命令将返回所有节点，若在 Neo4j Browser 下，则会返回整个图，包括节点和关系，与 SQL 中的 <code>SELECT *</code> 类似。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MATCH (n) </span><br><span class="line">RETURN n</span><br></pre></td></tr></table></figure>
<p>注：</p>
<ol>
<li>
<p>分行并非必要；</p>
</li>
<li>
<p><code>n</code> 相当于一个假定变量，大小写敏感，前后不一致将会导致变量未定义错误，同时，因为 <code>n</code> 是一个假定变量，因此在查询语句的书写时和程序中设置变量一样可以使用一个更具体的描述词，而不是使用通常的变量名 <code>n</code> <code>x</code> <code>y</code> ，增强查询语句的可读性；</p>
</li>
<li>
<p>括号是必要的，作为模式的表示方式，节点是最简单的模式；</p>
</li>
<li>
<p>关键字的大小写不敏感，与 SQL 类似，大小写混用并不会出错，但并不建议混用。</p>
</li>
</ol>
<h3 id="查找指定标签节点">查找指定标签节点</h3>
<p>以下命令返回 <code>Lable</code> 标签下的所有节点。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MATCH (n:Lable)</span><br><span class="line">RETURN n</span><br></pre></td></tr></table></figure>
<h3 id="查找连接节点">查找连接节点</h3>
<p>以下命令返回与带 <code>Label</code> 标签，属性 <code>name</code> 值为 <code>a</code> 的节点相连接的所有节点。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MATCH (Lable&#123;name:&#x27;a&#x27;&#125;)--(n)</span><br><span class="line">RETURN n</span><br></pre></td></tr></table></figure>
<p>若要限定返回节点的标签 <code>Lable1</code>，可在变量 <code>n</code> 后做限定。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MATCH (Lalbe&#123;name:&#x27;a&#x27;&#125;)--(n:Lable1)</span><br><span class="line">RETURN n</span><br></pre></td></tr></table></figure>
<p>关系表示符可指定方向：</p>
<ul>
<li>
<p><code>--</code> ：任意方向；</p>
</li>
<li>
<p><code>--&gt;</code> ：指向其他节点；</p>
</li>
<li>
<p><code>&lt;--</code> ：指向自身。</p>
</li>
</ul>
<h2 id="查找关系">查找关系</h2>
<h3 id="查找关系类型">查找关系类型</h3>
<p>以下命令返回连接 <code>Lable</code> 标签下 <code>name</code> 属性分别为 <code>a</code>, <code>b</code> 的两个节点的关系类型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MATCH (:Lable&#123;name:&#x27;a&#x27;&#125;)-[r]-(:Lable&#123;name:&#x27;b&#x27;&#125;)</span><br><span class="line">RETURN TYPE(r) </span><br></pre></td></tr></table></figure>
<p><code>TYPE</code> 大小写不敏感。</p>
<p>若两个节点间没有关系，则不会做任何改变，也无返回值。</p>
<p>若要指定关系方向，可将第一句改为以下两种情况：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MATCH (:Lable&#123;name:&#x27;a&#x27;&#125;)&lt;-[r]-(:Lable&#123;name:&#x27;b&#x27;&#125;)</span><br><span class="line">MATCH (:Lable&#123;name:&#x27;a&#x27;&#125;)-[r]-&gt;(:Lable&#123;name:&#x27;b&#x27;&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="查找指定关系">查找指定关系</h3>
<p>以下命令返回关系类型为 <code>RELAY</code> 的节点及其关系。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MATCH (a)-[:RELAY]-(b)</span><br><span class="line">RETURN *  </span><br></pre></td></tr></table></figure>
<p>匹配多个关系可用管道符 <code>|</code> 连接，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MATCH (a)-[:RELAY|:RELAY1]-(b)</span><br></pre></td></tr></table></figure>
<h1>RETURN</h1>
<p><code>RETURN</code> 语句设定返回类型，如上面提到的返回节点，返回关系，返回节点的特定属性。已上一个命令为例，返回的是所有节点和关系，相当于：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MATCH (a)-[r:RELAY]-(b)</span><br><span class="line">RETURN a, b, r</span><br></pre></td></tr></table></figure>
<p>若要返回节点属性 <code>name</code>，可写作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MATCH (a)-[:RELAY]-(b)</span><br><span class="line">RETURN a.name</span><br></pre></td></tr></table></figure>
<p>返回关系类型上面已提及，不重复描述。</p>
<h1>CREATE</h1>
<h2 id="创建节点">创建节点</h2>
<p>若要查看创建节点的结果，需用 <code>RETURN</code> 语句返回，实际上以下其他命令也是如此，下面不再列出 <code>RETURN</code> 语句除非必要。否则仅会输出提示节点的创建数量、属性的设置数量、标签的创建数量。</p>
<h3 id="创建空节点">创建空节点</h3>
<p>以下命令创建一个空节点。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE (n)</span><br></pre></td></tr></table></figure>
<p>若要创建多个节点，可用逗号分隔。</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">CREATE (n), (m)</span><br></pre></td></tr></table></figure>
<h3 id="创建带标签的节点">创建带标签的节点</h3>
<p>以下命令创建一个带标签的节点。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE (n:Lable)</span><br></pre></td></tr></table></figure>
<p>若要创建多个标签，可紧随其后。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE (n:Lalbe:Lable1)</span><br></pre></td></tr></table></figure>
<h3 id="创建带属性节点">创建带属性节点</h3>
<p>以下命令创建一个带属性节点，并指定 <code>name</code> <code>name1</code>为属性名， <code>a</code> <code>b</code>  为属性值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE (n:Lable&#123;name:&#x27;a&#x27;, name1:&#x27;b&#x27;&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="创建关系">创建关系</h2>
<p>创建关系首先要使用 <code>MATCH</code> 语句匹配到关系的起点和终点。以下命令先匹配到 <code>a</code> <code>b</code> 两个节点，然后建立两个节点间的关系 <code>RELAY</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MATCH (a:Lable&#123;name:&#x27;a&#x27;&#125;), (b:Lable&#123;name:&#x27;b&#x27;&#125;)</span><br><span class="line">CREATE (a)-[:RELAY]-&gt;(b)</span><br></pre></td></tr></table></figure>
<p>注：</p>
<ol>
<li>
<p>关系的创建与查询时不同，必须指明关系方向，仅允许创建有方向的关系；</p>
</li>
<li>
<p>关系创建时必须设定关系名；</p>
</li>
<li>
<p>此匹配节点语句并不是最佳，会弹出 <code>Warning</code> 提示建议使用 <code>OPIONAL MATCH</code> 优化查询速度，此处不做探讨。</p>
</li>
</ol>
<h1>DELETE</h1>
<p><code>DELETE</code> 语句用于删除节点或关系。需要先查找到节点或者关系，实际上在仅对节点和关系的删除上只要把 <code>MATCH</code> 中的 <code>RETURN</code> 语句换做 <code>DELETE</code> 语句就可以完成删除。</p>
<p>有一点不同的是，<code>DELETE</code> 语句可以在删除节点的同时删除掉与之的关系，使用 <code>DETACH DELETE</code>, 如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MATCH (n:Lable&#123;name:&#x27;a&#x27;&#125;)</span><br><span class="line">DETACH DELETE n</span><br></pre></td></tr></table></figure>
<p>以下命令可以删除所有节点和关系，在学习试验的小数据中很有用：</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line"><span class="built_in">MATCH</span> (<span class="built_in">n</span>)</span><br><span class="line">DETACH DELETE <span class="built_in">n</span></span><br></pre></td></tr></table></figure>
<h1>REMOVE</h1>
<h2 id="移除节点属性">移除节点属性</h2>
<p>Neo4j 不允许属性值为 <code>null</code>，所以移除节点属性也可说是用于删除该属性。以下命令移除所有节点的 <code>name</code> 属性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MATCH (n)</span><br><span class="line">REMOVE n.name</span><br></pre></td></tr></table></figure>
<p><code>REMOVE</code> 语句无法使用一条命令删除所有属性，需要使用 <code>SET</code> 语句，此处不做探讨。</p>
<h2 id="移除节点标签">移除节点标签</h2>
<p>以下命令移除节点 <code>a</code> 标签 <code>Lable</code>，移除多个标签和 <code>CREATE</code> 语句类似。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MATCH (n&#123;name:&#x27;a&#x27;&#125;)</span><br><span class="line">REMOVE a:Lable</span><br></pre></td></tr></table></figure>
<h1>MERGE</h1>
<p><code>MERGE</code> 命令用于在模式匹配不成功时创建该模式，类似先通过 <code>MATHCH</code> 进行模式查找，再用 <code>CREATE</code> 进行模式创建。相比后一种方式，<code>MERGE</code> 命令更简洁，但无法进行部分匹配，一旦匹配表达式的某项不满足，整个模式都将被创建。</p>
<h2 id="归并节点">归并节点</h2>
<h3 id="归并节点标签">归并节点标签</h3>
<p>以下命令查找是否存在标签为 <code>LABEL</code> 的节点，若不存在，则创建一个标签为 <code>LABEL</code> 的节点，若存在，则不会做出改动。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MERGE (n:LABEL)</span><br></pre></td></tr></table></figure>
<h3 id="归并节点属性">归并节点属性</h3>
<p>以下命令查找是否存在 <code>name</code> 属性为 <code>n</code> 的节点，若不存在，则创建一个 <code>name</code> 属性为 <code>n</code> 的节点，若存在，则不做出改动。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MERGE (n&#123;name:&#x27;n&#x27;&#125;)</span><br></pre></td></tr></table></figure>
<p>要匹配多个属性及其对应的值可用逗号隔开，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MERGE (n&#123;name1:&#x27;n&#x27;, name2:&#x27;m&#x27;&#125;)</span><br></pre></td></tr></table></figure>
<p>在上面这条语句的情况下，只有 <code>name1</code> 和 <code>name2</code> 属性同时满足匹配条件时才不会对图数据库做出改动，只要不存在有一个节点同时满足上述两个条件，则会创建新的节点，即前面提到的 <code>MERGE</code> 语句无法实现部分归并。</p>
<h3 id="从已有属性归并节点">从已有属性归并节点</h3>
<p>以下命令从已有的 <code>LABEL1</code> 标签下的节点查找其节点属性 <code>p1</code> ，并归并出 <code>LABLE2</code> 标签的节点，新节点的属性视为 <code>p2</code> ，从而不重复创建。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MATCH (n:LABEL1)</span><br><span class="line">MERGE (m:LABEL2&#123;p2:n.p1&#125;)</span><br></pre></td></tr></table></figure>
<p>具体示例可查看官方手册的 <code>MERGE</code> 章节，举个简单的例子假设图数据库中已有几名学生的信息作为节点，学生的信息包括其籍贯，通过上面的命令即将学生视为标签 <code>LABEL1</code>，籍贯视为属性 <code>p1</code>，并将籍贯形成新的节点标签 <code>LABEL2</code>，以上命令就相当于不重复地列出学生的籍贯并一一建立新节点，并为新籍贯节点创建的属性视为 <code>p2</code> ，如果图数据库中已有籍贯相同的节点，则不会再被创建，保证了唯一性。这在从已有数据分离出一些较小的数据项时很有用。</p>
<h1>参考资料</h1>
<ul>
<li>
<p><a href="https://neo4j.com/docs/cypher-manual/3.5/">The Neo4j Cypher Manual v3.5</a></p>
</li>
<li>
<p>《 Neo4j 权威指南》</p>
</li>
</ul>
]]></content>
      <categories>
        <category>知识图谱</category>
      </categories>
      <tags>
        <tag>Neo4j</tag>
        <tag>Cypher</tag>
      </tags>
  </entry>
  <entry>
    <title>Neo4j之python连接失败解决(py2neo)</title>
    <url>/zh-CN/KG-py2neo-python-connect-neo4j/</url>
    <content><![CDATA[<p>本文简述在 python 中使用 py2neo 连接 Neo4j 及连接时可能遇到的问题和解决方法。</p>
<span id="more"></span>
<p>使用 <code>pip</code> 工具安装 py2neo 。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install py2neo</span><br></pre></td></tr></table></figure>
<p>若已安装 pip 仍提示 <code>pip : command not found</code> ，可以切换到到 Python 的安装目录<code>&lt;Installation floder&gt;\Scripts</code>目录下，使用以下命令安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./pip install py2neo</span><br></pre></td></tr></table></figure>
<p>由于网络原因，有可能多次下载失败，这种情况可以选择到  <a href="https://pypi.org">PyPI</a> 手动下载<a href="https://pypi.org/project/py2neo/#files"> py2neo package</a> ，再使用 <code>pip</code> 进行安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install THE_PACKAGE_PATH</span><br></pre></td></tr></table></figure>
<p>导入 py2neo :</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">import</span> py2neo</span><br></pre></td></tr></table></figure>
<p>调用 <code>py2neo.Graph()</code> 函数连接Neo4j中已有的图：</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">graph</span>=py2neo.<span class="keyword">Graph</span>(<span class="string">&quot;bolt://localhost:7687&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>注：这里的端口是一般情况下的默认端口号，在该端口被占用的情况下Neo4j启用的访问端口可能并不是此端口号。</p>
<p>此时并不能看出连接是否成功，可以使用查询语句查看是否能查询到结果，若连接成功，则此时可以使用图实例所提供的各项功能，py2neo 中提供了对节点、关系，以及各类操作的方法，也可以调用 Cypher 语句进行操作。</p>
<p>这里我们通过调用 <code>len()</code> 函数对节点进行计数来查看连接状态：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="built_in">len</span>(graph.nodes)</span><br></pre></td></tr></table></figure>
<p>若连接不成功，可能看到以下错误提示</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last): </span><br><span class="line">    File <span class="string">&quot;E:<span class="char escape_">\P</span>ython<span class="char escape_">\l</span>ib<span class="char escape_">\s</span>ite-packages<span class="char escape_">\p</span>y2neo<span class="char escape_">\d</span>atabase.py&quot;</span>, line <span class="number">828</span>, <span class="keyword">in</span> run entities<span class="operator">=</span>entities))</span><br><span class="line">    File <span class="string">&quot;E:<span class="char escape_">\P</span>ython<span class="char escape_">\l</span>ib<span class="char escape_">\s</span>ite-packages<span class="char escape_">\p</span>y2neo<span class="char escape_">\i</span>nternal<span class="char escape_">\c</span>onnectors.py&quot;</span>, line <span class="number">292</span>, <span class="keyword">in</span> run return self._run_1(statement, parameters, graph, keys, entities)</span><br><span class="line">    File <span class="string">&quot;E:<span class="char escape_">\P</span>ython<span class="char escape_">\l</span>ib<span class="char escape_">\s</span>ite-packages<span class="char escape_">\p</span>y2neo<span class="char escape_">\i</span>nternal<span class="char escape_">\c</span>onnectors.py&quot;</span>, line <span class="number">241</span>, <span class="keyword">in</span> _run_1cx <span class="operator">=</span> self.pool.acquire()</span><br><span class="line">    File <span class="string">&quot;E:<span class="char escape_">\P</span>ython<span class="char escape_">\l</span>ib<span class="char escape_">\s</span>ite-packages<span class="char escape_">\n</span>eobolt<span class="char escape_">\d</span>irect.py&quot;</span>, line <span class="number">715</span>, <span class="keyword">in</span> acquire return self.acquire_direct(self.address)</span><br><span class="line">    File <span class="string">&quot;E:<span class="char escape_">\P</span>ython<span class="char escape_">\l</span>ib<span class="char escape_">\s</span>ite-packages<span class="char escape_">\n</span>eobolt<span class="char escape_">\d</span>irect.py&quot;</span>, line <span class="number">608</span>, <span class="keyword">in</span> acquire_direct connection <span class="operator">=</span> self.connector(address, error_handler<span class="operator">=</span>self.connection_error_handler)</span><br><span class="line">    File <span class="string">&quot;E:<span class="char escape_">\P</span>ython<span class="char escape_">\l</span>ib<span class="char escape_">\s</span>ite-packages<span class="char escape_">\p</span>y2neo<span class="char escape_">\i</span>nternal<span class="char escape_">\c</span>onnectors.py&quot;</span>, line <span class="number">227</span>, <span class="keyword">in</span> connector encrypted<span class="operator">=</span>cx_data[<span class="string">&quot;secure&quot;</span>], <span class="operator">*</span><span class="operator">*</span>kwargs)</span><br><span class="line">    File <span class="string">&quot;E:<span class="char escape_">\P</span>ython<span class="char escape_">\l</span>ib<span class="char escape_">\s</span>ite-packages<span class="char escape_">\n</span>eobolt<span class="char escape_">\d</span>irect.py&quot;</span>, line <span class="number">972</span>, <span class="keyword">in</span> connect raise last_error </span><br><span class="line">    File <span class="string">&quot;E:<span class="char escape_">\P</span>ython<span class="char escape_">\l</span>ib<span class="char escape_">\s</span>ite-packages<span class="char escape_">\n</span>eobolt<span class="char escape_">\d</span>irect.py&quot;</span>, line <span class="number">964</span>, <span class="keyword">in</span> connect connection <span class="operator">=</span> _handshake(s, address, der_encoded_server_certificate, <span class="operator">*</span><span class="operator">*</span>config)</span><br><span class="line">    File <span class="string">&quot;E:<span class="char escape_">\P</span>ython<span class="char escape_">\l</span>ib<span class="char escape_">\s</span>ite-packages<span class="char escape_">\n</span>eobolt<span class="char escape_">\d</span>irect.py&quot;</span>, line <span class="number">932</span>, <span class="keyword">in</span> _handshake connection.hello()</span><br><span class="line">    File <span class="string">&quot;E:<span class="char escape_">\P</span>ython<span class="char escape_">\l</span>ib<span class="char escape_">\s</span>ite-packages<span class="char escape_">\n</span>eobolt<span class="char escape_">\d</span>irect.py&quot;</span>, line <span class="number">249</span>, <span class="keyword">in</span> hello self.sync()</span><br><span class="line">    File <span class="string">&quot;E:<span class="char escape_">\P</span>ython<span class="char escape_">\l</span>ib<span class="char escape_">\s</span>ite-packages<span class="char escape_">\n</span>eobolt<span class="char escape_">\d</span>irect.py&quot;</span>, line <span class="number">527</span>, <span class="keyword">in</span> sync detail_delta, summary_delta <span class="operator">=</span> self.fetch()</span><br><span class="line">    File <span class="string">&quot;E:<span class="char escape_">\P</span>ython<span class="char escape_">\l</span>ib<span class="char escape_">\s</span>ite-packages<span class="char escape_">\n</span>eobolt<span class="char escape_">\d</span>irect.py&quot;</span>, line <span class="number">419</span>, <span class="keyword">in</span> fetch    return self._fetch()</span><br><span class="line">    File <span class="string">&quot;E:<span class="char escape_">\P</span>ython<span class="char escape_">\l</span>ib<span class="char escape_">\s</span>ite-packages<span class="char escape_">\n</span>eobolt<span class="char escape_">\d</span>irect.py&quot;</span>, line <span class="number">461</span>, <span class="keyword">in</span> _fetch  response.on_failure(summary_metadata <span class="keyword">or</span> &#123;&#125;)</span><br><span class="line">    File <span class="string">&quot;E:<span class="char escape_">\P</span>ython<span class="char escape_">\l</span>ib<span class="char escape_">\s</span>ite-packages<span class="char escape_">\n</span>eobolt<span class="char escape_">\d</span>irect.py&quot;</span>, line <span class="number">774</span>, <span class="keyword">in</span> on_failure raise AuthError(message)</span><br><span class="line">neobolt.exceptions.<span class="params">AuthError:</span> The client is unauthorized due to authentication failure.                                                                             During handling of the above exception, another exception <span class="params">occurred:</span>                 Traceback (most recent call last):</span><br><span class="line">    File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> <span class="symbol">&lt;module&gt;</span></span><br><span class="line">    File <span class="string">&quot;E:<span class="char escape_">\P</span>ython<span class="char escape_">\l</span>ib<span class="char escape_">\s</span>ite-packages<span class="char escape_">\p</span>y2neo<span class="char escape_">\m</span>atching.py&quot;</span>, line <span class="number">196</span>, <span class="keyword">in</span> __len__  return len(self.match())</span><br><span class="line">    File <span class="string">&quot;E:<span class="char escape_">\P</span>ython<span class="char escape_">\l</span>ib<span class="char escape_">\s</span>ite-packages<span class="char escape_">\p</span>y2neo<span class="char escape_">\m</span>atching.py&quot;</span>, line <span class="number">80</span>, <span class="keyword">in</span> __len__ return self.graph.evaluate(<span class="operator">*</span>self._query_and_parameters(count<span class="operator">=</span>True))</span><br><span class="line">    File <span class="string">&quot;E:<span class="char escape_">\P</span>ython<span class="char escape_">\l</span>ib<span class="char escape_">\s</span>ite-packages<span class="char escape_">\p</span>y2neo<span class="char escape_">\d</span>atabase.py&quot;</span>, line <span class="number">395</span>, <span class="keyword">in</span> evaluate return self.begin(autocommit<span class="operator">=</span>True).evaluate(cypher, parameters, <span class="operator">*</span><span class="operator">*</span>kwparameters)</span><br><span class="line">    File <span class="string">&quot;E:<span class="char escape_">\P</span>ython<span class="char escape_">\l</span>ib<span class="char escape_">\s</span>ite-packages<span class="char escape_">\p</span>y2neo<span class="char escape_">\d</span>atabase.py&quot;</span>, line <span class="number">876</span>, <span class="keyword">in</span> evaluate return self.run(cypher, parameters, <span class="operator">*</span><span class="operator">*</span>kwparameters).evaluate(<span class="number">0</span>)</span><br><span class="line">    File <span class="string">&quot;E:<span class="char escape_">\P</span>ython<span class="char escape_">\l</span>ib<span class="char escape_">\s</span>ite-packages<span class="char escape_">\p</span>y2neo<span class="char escape_">\d</span>atabase.py&quot;</span>, line <span class="number">830</span>, <span class="keyword">in</span> run raise GraphError.hydrate(&#123;<span class="string">&quot;code&quot;</span>: error.code, <span class="string">&quot;message&quot;</span>: error.message&#125;)</span><br><span class="line">    File <span class="string">&quot;E:<span class="char escape_">\P</span>ython<span class="char escape_">\l</span>ib<span class="char escape_">\s</span>ite-packages<span class="char escape_">\p</span>y2neo<span class="char escape_">\d</span>atabase.py&quot;</span>, line <span class="number">676</span>, <span class="keyword">in</span> hydrate_, classification, category, title <span class="operator">=</span> code.split(<span class="string">&quot;.&quot;</span>)                                   <span class="params">AttributeError:</span> &#x27;NoneType&#x27; object has no attribute &#x27;split&#x27;                     </span><br></pre></td></tr></table></figure>
<p>可以看到是身份验证失败而产生的错误。这是由于连接时未设置用户名和密码导致的，默认用户名为 <code>neo4j</code>，密码为<code>password</code>，而 Neo4j 默认密码为 <code>neo4j</code> ，因此导致了认证失败，同时在第一次开启图数据库时 Neo4j 会提示设立身份验证方式，此时设置的密码将用于登录，若使用 Neo4j Browser，并不会在每一次登陆时都提示身份验证，因此并未注意到这一点。在 Neo4j Browser 中使用 <code>server user list</code> 可以看到此时有名为 <code>neo4j</code> 的使用者。可以使用 <code>server user add</code> 命令添加一个用户，用此用户作为 <code>Graph()</code> 的 <code>auth</code> 项参数登录即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;graph=py2neo.Graph(<span class="string">&quot;bolt://localhost:7687&quot;</span>, auth=(<span class="string">&#x27;username&#x27;</span>, <span class="string">&#x27;password&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p>注：在查找此问题的解决方式时看到有提议用 <code>neo4j-admin</code> 工具修改初始密码，在 Windows 下，此工具并不是直接以 <code>*.exe</code> 的可执行文件出现，而是 <code>*.bat</code> 的批处理文件，并且在 Neo4j Desktop 版本下此工具不是位于 <code>&lt;Installation Folder&gt;/bin</code> ，而应该切换至 <code>&lt;Database Folder&gt;/bin</code> 目录下，运行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./neo4j-admin.bat YOURCOMMAND</span><br></pre></td></tr></table></figure>
<p>但在此操作应该是在数据库未建立时，否则，将会提示此时的权限已经转移到 <code>&lt;Database Folder&gt;/data/dbms/</code> 下的 <code>auth</code> 文件中，如果要重设密码应该移除 <code>auth</code> 和 <code>role</code> 相关文件或者重设该数据库，所以并不能使用此方式，新建一个用户应该是一个比较好的选择。</p>
<ul>
<li><strong>参考资料</strong>：<a href="https://py2neo.org/v4/index.html">The Py2neo v4 Handbook</a></li>
</ul>
]]></content>
      <categories>
        <category>知识图谱</category>
      </categories>
      <tags>
        <tag>Neo4j</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>LaTeX-使用mcmthesis模板写作美赛论文</title>
    <url>/zh-CN/LaTex-use-mcmthesis-write/</url>
    <content><![CDATA[<p>本文总结了使用mcmthesis的方法，以及一些美赛时可能用到的表格，图片等环境。本文并不能作为LaTex的学习教程。</p>
<span id="more"></span>
<h1>论文基本设置</h1>
<p>在<code>mcmthesis</code>中设置了<code>\mcmsetup</code>来调整基本选项，通过这些选项设置队伍的相关信息，论文中的标题，摘要等。如果想要调整模板的一些参数设置，或者是摘要页的格式，可以通过修改<code>mcmthesis.cls</code>文件进行修改，也就是调整模板格式 。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\mcmsetup</span>&#123;</span><br><span class="line">          tcn = 12345,</span><br><span class="line">          problem = B,</span><br><span class="line">          sheet = true,</span><br><span class="line">          titleinsheet = true,</span><br><span class="line">          keywordsinsheet = false,</span><br><span class="line">          titlepage = false,</span><br><span class="line">          abstract = true</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure>
<h2 id="队伍控制号">队伍控制号</h2>
<p>在成功注册缴费报名后，每个队伍会得到一个控制号（Team Control Number），根据美赛的规则，控制号必须在摘要页以及之后的论文的页眉中出现，这点模板中已经设置好了，我们只需要改为自己队伍的控制号即可，即将<code>tcn</code>的值改为本队控制号，例如12345（默认值为0000）。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\mcmsetup</span>&#123;tcn = 12345&#125;</span><br></pre></td></tr></table></figure>
<h2 id="选题">选题</h2>
<p>在比赛开始后，将一共发布6道题，队伍只能选择一道题作答，并将该题编号写于摘要页上。我们只需要改动<code>problem</code>的值为本队选择的问题即可，例如B题（默认值为A）。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\mcmsetup</span>&#123;probelm = B&#125;</span><br></pre></td></tr></table></figure>
<h2 id="摘要页">摘要页</h2>
<p><code>mcmthesis</code>模板中生成了摘要页，队伍可以选择使用此摘要页，或者选择学校提供的摘要页或者官网提供的Word摘要页，关闭此摘要页（默认值为<code>true</code>，即开启）。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\mcmsetup</span>&#123;sheet = true&#125;</span><br></pre></td></tr></table></figure>
<h2 id="摘要页中的标题">摘要页中的标题</h2>
<p>如果希望在摘要页中显示文章标题，将<code>titleinsheet</code>的值设置为<code>true</code>（默认值为<code>false</code>）。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\mcmsetup</span>&#123;titleinsheet = true&#125;</span><br></pre></td></tr></table></figure>
<h2 id="摘要页中的关键词">摘要页中的关键词</h2>
<p>如果希望在摘要页中显示关键词，将<code>keywordsinsheet</code>的值设置为<code>true</code>（默认值为<code>false</code>）。如果不显示关键词，请记得也把摘要中的<code>\begin&#123;keywords&#125;...\end&#123;keywords&#125;</code>去掉或修改注释掉。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\mcmsetup</span>&#123;keywordsinsheet = false&#125;</span><br></pre></td></tr></table></figure>
<h2 id="标题页">标题页</h2>
<p>如果希望在摘要后显示LaTex标准的标题页，将<code>titlepage</code>的值设置为<code>true</code>（默认值为<code>true</code>）。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\mcmsetup</span>&#123;titlepage = false&#125;</span><br></pre></td></tr></table></figure>
<h2 id="标题页的摘要">标题页的摘要</h2>
<p>如果在上一项<code>titlepage</code>的值设置为<code>true</code>，将此选项<code>abstract</code>的值设置为<code>true</code>，将在标题页中显示摘要，也就是在前面的摘要页之后再一次显示摘要，摘要会被放在标题页中，如果<code>titlepage</code>值设置为<code>false</code>，则此处就无影响（默认值为<code>true</code>）。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\mcmsetup</span>&#123;abstract = true&#125;</span><br></pre></td></tr></table></figure>
<h1>美赛写作常用</h1>
<p>以下将整理一些在美赛中常用的设置，环境，调用等等。</p>
<h2 id="段落缩进">段落缩进</h2>
<p><code>mcmthesis</code>模板中的段落缩进与LaTex中一样，首段默认不缩进，其他段落缩进，通过资料搜寻，发现这似乎是一个英文习惯，所以首段不缩进的问题不大。可以通过<code>\usepackage&#123;identfirst&#125;</code>解决，本人调用宏包失败尚未解决这个问题。如果觉得有的缩进有的不缩进显得混乱，可以通过<code>\setlength&#123;\parindent&#125;&#123;0pt&#125;</code>设置缩进为0。</p>
<h2 id="插入图片（Figure）">插入图片（Figure）</h2>
<p>在文中常常需要插入图片，图片的标题应该在图片下方，<code>mcmthesis</code>模板中提供了一个参考格式如下：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;figure&#125;[htbp]</span><br><span class="line">    <span class="keyword">\small</span></span><br><span class="line">    <span class="keyword">\centering</span></span><br><span class="line">    <span class="keyword">\includegraphics</span>[width=12cm]&#123;a.eps&#125;</span><br><span class="line">    <span class="keyword">\caption</span>&#123;a&#125;</span><br><span class="line">    <span class="keyword">\label</span>&#123;fig:Figure 1&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;figure&#125;</span><br></pre></td></tr></table></figure>
<p>htbp选项表示由LaTex决定插图位置，即这里，页顶，页底，浮动。 <code>\centring</code>表示居中，<code>\label&#123;&#125;</code>应该在<code>\caption</code>之后。图片格式可以通过 <a href="http://www.tlhiv.org/rast2vec/">Convert PNG/JPEG(Raster) to EPS/PDF(Vector) Format</a> 转化为<code>*.eps</code>,<code>*.pdf</code>格式，放置于<code>figure</code>文件夹中，并且<code>*.pdf</code>的命名格式有一定的要求，如图片为<code>a.eps</code>，则PDF文件应该命名为<code>a-eps-converted-to.pdf</code>。</p>
<h2 id="列表">列表</h2>
<p>简单的列表样式通常用于列举assumptions，方程、公式等的参数</p>
<h3 id="无序列表">无序列表</h3>
<p>无序列表各项前的符号默认为实心小圆点，可以通过改变<code>\item[]</code>参数来修改符号。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;itemize&#125;</span><br><span class="line">  <span class="keyword">\item</span></span><br><span class="line">  <span class="keyword">\item</span>[-]</span><br><span class="line">  <span class="keyword">\item</span>[*]</span><br><span class="line"><span class="keyword">\end</span>&#123;itemize&#125;</span><br></pre></td></tr></table></figure>
<h3 id="有序列表">有序列表</h3>
<p>参数同样可以改变。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;enumerate&#125;</span><br><span class="line">  <span class="keyword">\item</span></span><br><span class="line">  <span class="keyword">\item</span></span><br><span class="line"><span class="keyword">\end</span>&#123;enumerate&#125;</span><br></pre></td></tr></table></figure>
<h2 id="表格（Table）">表格（Table）</h2>
<p>常用于列举notations，以及各种参数，表格的标题应该在表格上方，下面是一个简单的示例：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;table&#125;[htbp]</span><br><span class="line"><span class="keyword">\centering</span></span><br><span class="line"><span class="keyword">\caption</span>&#123;Notations&#125;</span><br><span class="line"><span class="keyword">\label</span>&#123;tab:Table 1&#125;</span><br><span class="line">  <span class="keyword">\begin</span>&#123;tabular&#125;&#123;c|l&#125;</span><br><span class="line">    <span class="keyword">\toprule</span></span><br><span class="line">    Symbol <span class="built_in">&amp;</span> Description<span class="keyword">\\</span></span><br><span class="line">    <span class="keyword">\midrule</span></span><br><span class="line">    <span class="built_in">$</span>W/L<span class="built_in">$</span> <span class="built_in">&amp;</span> width  <span class="keyword">\\</span></span><br><span class="line">    <span class="keyword">\hline</span></span><br><span class="line">    <span class="built_in">$</span>A<span class="built_in">$</span>   <span class="built_in">&amp;</span> area <span class="keyword">\\</span></span><br><span class="line">    <span class="keyword">\bottomrule</span></span><br><span class="line">  <span class="keyword">\end</span>&#123;tabular&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;table&#125;</span><br></pre></td></tr></table></figure>
<p>参数设置与图片浮动Figure环境类似。<code>\hline</code>表示横线，<code>\toprule</code>,<code>\bottomrule</code>可以使顶部和底部的线与中间的线<code>\midrule</code>区分开来。<code>|</code>表示竖线，每列的横向对齐方式通过<code>l</code>,<code>c</code>,<code>r</code>控制，分别表示左对齐 ，居中，右对齐。<code>\\</code>用于换行，也就是分行，<code>&amp;</code>用于分列。</p>
<h2 id="数学">数学</h2>
<h3 id="公式">公式</h3>
<p>带序号的行间公式，可以在equation后加上*不带序号。</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;equation&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">\end</span>&#123;equation&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方程组">方程组</h3>
<p>可以使用方程和数组的结合，参考如下：</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;equation&#125;</span><br><span class="line">  <span class="keyword">\left</span><span class="keyword">\&#123;</span></span><br><span class="line">  <span class="keyword">\begin</span>&#123;array&#125;&#123;lll&#125;</span><br><span class="line">    <span class="keyword">\frac</span>&#123;<span class="keyword">\partial</span> T&#125;&#123;<span class="keyword">\partial</span> n&#125;=0<span class="keyword">\\</span></span><br><span class="line">  <span class="keyword">\\</span></span><br><span class="line">    T = a</span><br><span class="line">  <span class="keyword">\\</span></span><br><span class="line">    T<span class="built_in">_</span>0=25</span><br><span class="line">  <span class="keyword">\end</span>&#123;array&#125;<span class="keyword">\right</span>.</span><br><span class="line">  <span class="keyword">\end</span>&#123;equation&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多行公式等号对齐">多行公式等号对齐</h3>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;align&#125;</span><br><span class="line">    <span class="keyword">\eta</span><span class="built_in">_</span>1 <span class="built_in">&amp;</span>= <span class="keyword">\frac</span>&#123;S<span class="built_in">_</span>1&#125;&#123;A&#125;</span><br><span class="line">    <span class="keyword">\\</span></span><br><span class="line">    <span class="keyword">\eta</span><span class="built_in">_</span>2 <span class="built_in">&amp;</span>= <span class="keyword">\frac</span>&#123;N <span class="keyword">\times</span> A&#125;&#123;S<span class="built_in">_</span>&#123;Total&#125;&#125;</span><br><span class="line">    <span class="keyword">\\</span></span><br><span class="line">         Z <span class="built_in">&amp;</span>= p <span class="keyword">\eta</span><span class="built_in">_</span>3 + (1-p)<span class="keyword">\eta</span><span class="built_in">_</span>4</span><br><span class="line"><span class="keyword">\end</span>&#123;align&#125;</span><br></pre></td></tr></table></figure>
<p>更多常用数学符号的整理传送门：<a href="https://fish-404.github.io/LaTeX-common-math-symbol-equation/">LaTeX - 常用数学符号 | 在逃的貓</a></p>
<p>LaTeX 数学符号快速搜索：<a href="https://latex.guide/">LaTeX Search: Find LaTeX commands</a></p>
<h2 id="参考文献的书写">参考文献的书写</h2>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;thebibliography&#125;&#123;99&#125;</span><br><span class="line">  <span class="keyword">\bibitem</span>&#123;1&#125;Wikipedia. 2018. Thermal Conduction. <span class="keyword">\url</span>&#123;<span class="link">https://en.wikipedia.org/wiki/Thermal_conduction</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">\bibitem</span>&#123;2&#125;Name. Article(in Chinese). <span class="keyword">\emph</span>&#123;Magazine&#125;, year, number: page. <span class="keyword">\url</span>&#123;<span class="link">site</span>&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;thebibliography&#125;</span><br></pre></td></tr></table></figure>
<p>99表示允许的最大条目数。在文章中可以使用<code>\cite&#123;&#125;</code>对<code>\bibitem</code>中编号了的参考文献进行引用。</p>
<h2 id="强调">强调</h2>
<p><code>\emph</code>用于强调，通常会变为斜体<br>
<code>\textbf&#123;&#125;</code>用于字体加粗</p>
<h1>参考资料</h1>
<ul>
<li>
<p><a href="https://liam0205.me/2016/01/27/how-to-use-mcmthesis/">如何使用美赛模板mcmthesis|始终</a></p>
</li>
<li>
<p><a href="http://www.ptep-online.com/ctan/lshort_chinese.pdf">一份不太简短的LATEX2ε介绍(PDF)</a></p>
</li>
<li>
<p><a href="http://dralpha.altervista.org/zh/tech/lnotes2.pdf">LATEX Notes雷太赫排版系统简介第二版v2.03(PDF)</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>LaTeX</tag>
        <tag>Mathematical modeling</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-在移动硬盘上安装Arch Linux</title>
    <url>/zh-CN/Linux-Install-archlinux-harddisk/</url>
    <content><![CDATA[<p>记录在移动硬盘上安装Arch Linux的过程。一部分用作Arch Linux，另一部分则用于日常存储。</p>
<span id="more"></span>
<h1>安装背景</h1>
<p>在2017年暑期接触到Linux，接触得并不太多，也只是装了个虚拟机VM ware，在虚拟机上使用过Ubuntu和CentOS，后来很长一段时间没怎么玩。最近入手了一块移动硬盘，Win 10用得总是崩溃，又想捣鼓一下Linux玩玩，电脑的配置并不高，也不想再重新分区，所以并没有装双系统，于是就想着是不是可以在移动硬盘上面装一个Linux，周围的伙伴推荐过Arch Linux，再加上Arch Linux的Wiki非常详细，大多数的东西都能在官方Wiki上面找到，于是决定进行尝试。</p>
<h1>安装准备</h1>
<p>采用MBR+BIOS引导启动，通过<a href="https://virtualbox.org">Virtual Box</a>引导Arch 的 ISO，将移动硬盘连接到虚拟机进行安装。在使用前我删除了移动硬盘上的所有分区，移动硬盘处于未分配状态，分区操作将在后文提及。（也可以选择使用<a href="https://www.disktool.cn/">分区助手</a>将GPT格式分区修改为MBR分区方式，以及格式化和分区。）</p>
<h2 id="新建虚拟机">新建虚拟机</h2>
<p>在Virtual Box上新建一个虚拟机，不设置虚拟磁盘。需要注意的是在虚拟机的设置中需要启用USB设置项，选择“启用USB控制器”，选择USB 3.0(xHCI)控制器。此选项需要安装<a href="https://virtualbox.org/wiki/Downloads">VirtualBox Extension Pack</a>，下载完扩展包后，在VirtualBox的全局设定中的扩展选项卡将此扩展包加入，才可以正常使用USB3.0控制器。</p>
<p><strong>加载Arch Linux ISO文件时，记得在顶部的菜单栏选择USB设备！</strong></p>
<h2 id="分区，格式化，挂载">分区，格式化，挂载</h2>
<h3 id="分区">分区</h3>
<p>运行分区工具：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cfdisk</span><br></pre></td></tr></table></figure>
<p>如果移动硬盘中并不存在分区，则将会出现一个选择菜单&quot;Select label type&quot;，这里我们选择<code>dos</code>，这将会使用MBR方式对硬盘进行分区。之后将显示整个移动硬盘的分区状态，当前显示为<code>Free Space</code>，对此进行分区，根据提示输入分区大小，创建分区后，需要选择<code>Write</code>将分区写入，忽略<code>Write</code>操作分区将并不会被修改，根据自己的需要进行分区。我创建了两个分区用于<code>root</code>，和<code>home</code>，这两个分区的类型为<code>83 Linux</code>，一个分区用于<code>swap</code>，分区类型为<code>82 Linux swap / Solaris</code>，剩下的作为日常存储使用，当然这里我也根据需要进行了一定的分区，分区类型均为<code>7 HPFS/NTFS/exFAT</code>。</p>
<p>分区完成后可以使用以下命令查看分区情况：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fdisk -l</span><br></pre></td></tr></table></figure>
<p>或者使用命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsblk</span><br></pre></td></tr></table></figure>
<h3 id="格式化">格式化</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkfs.ext4 /dev/sda1</span><br></pre></td></tr></table></figure>
<h3 id="设置卷标">设置卷标</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">e2label /dev/sda1 <span class="built_in">arch</span></span><br></pre></td></tr></table></figure>
<h3 id="挂载分区，启用swap">挂载分区，启用swap</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount /dev/sda1 /mnt</span><br><span class="line"><span class="built_in">mkdir</span> /mnt/home</span><br><span class="line">mount /dev/sda2 /mnt/home</span><br><span class="line">mkswap /dev/sda3</span><br><span class="line">swapon /dev/sda3</span><br></pre></td></tr></table></figure>
<h1>安装</h1>
<h2 id="检查网络连接">检查网络连接</h2>
<p>检查网络连接是否正常（此时机器应该时自动连接到网络的），可以使用<code>ping</code>验证连接是否正常：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ping -c 3 archlinux.org</span><br></pre></td></tr></table></figure>
<h2 id="选择镜像源">选择镜像源</h2>
<p>修改<code>/etc/pacman.d/mirrorlist</code>文件，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/pacman.d/mirrorlist</span><br></pre></td></tr></table></figure>
<p>关于vim的操作，此处不做介绍。<br>
此文件定义了软件包会从哪个镜像源下载，在列表中越前的镜像在下载软件包时有越高的优先权。可以加入以下两个镜像：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 中科大的</span></span></span><br><span class="line">Server = https://mirrors.ustc.edu.cn/archlinux/$repo/os/$arch</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 阿里云的</span></span></span><br><span class="line">Server = https://mirrors.aliyun.com/archlinux/$repo/os/$arch</span><br></pre></td></tr></table></figure>
<h2 id="安装基本系统">安装基本系统</h2>
<p>使用<code>pacstrap</code>脚本，安装<code>base</code>组，和<code>base-devel</code>软件包组，也可以之后再安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pasctrap -i /mnt base base-devel</span><br></pre></td></tr></table></figure>
<h1>配置系统</h1>
<h2 id="Fstab">Fstab</h2>
<p>生成<code>fstab</code>文件，该文件用于定义磁盘分区，其他块设备和远程文件系统如何装入文件系统，<code>-U</code>选项设置使用UUID：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">genfstab -U /mnt &gt;&gt; /mnt/etc/fstab</span><br></pre></td></tr></table></figure>
<p>根据 Arch Wiki 的建议， 最好检查一下<code>fstab</code>文件是否正确：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /mnt/etc/fstab</span><br></pre></td></tr></table></figure>
<h2 id="Chroot">Chroot</h2>
<p>Change root 到新系统</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">arch-chroot /mnt</span><br></pre></td></tr></table></figure>
<h2 id="时区">时区</h2>
<p>设置时区：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ln</span> -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line">hwclock --systohc</span><br></pre></td></tr></table></figure>
<h2 id="本地化">本地化</h2>
<p>(这里vim可能尚未安装，使用<code>pacman -S vim</code>进行安装）<br>
在<code>/etc/locale.gen</code>文件中修改需要的本地化类型，移除掉对应行前的注释号即可:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/locale.gen</span><br></pre></td></tr></table></figure>
<p>执行<code>locale-gen</code>生成locale讯息，使<code>/etc/locale.ben</code>生成指定的本地化文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">locale-gen</span><br></pre></td></tr></table></figure>
<p>创建<code>locale.conf</code>并编辑<code>LANG</code>变量：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/locale.conf</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">LANG = en_US.UTF-8</span><br></pre></td></tr></table></figure>
<h2 id="设置主机名">设置主机名</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> myhostname &gt; /etc/hostname</span><br></pre></td></tr></table></figure>
<h2 id="设置root密码">设置root密码</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">passwd</span><br></pre></td></tr></table></figure>
<h2 id="添加普通用户">添加普通用户</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">useradd -m newuser</span><br><span class="line">passwd newuser</span><br></pre></td></tr></table></figure>
<p>修改权限：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">visudo</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root ALL=(ALL)ALL</span><br><span class="line">newuser ALL=(ALL)ALL</span><br></pre></td></tr></table></figure>
<h2 id="安装Grub">安装Grub</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pacman -S grub</span><br><span class="line">grub-install --recheck /dev/sda</span><br><span class="line">grub-mkconfig -o /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure>
<h2 id="退出Chroot环境并卸载分区，关闭虚拟机">退出Chroot环境并卸载分区，关闭虚拟机</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exit</span></span><br><span class="line">umount /mnt/home</span><br><span class="line">umount /mnt</span><br><span class="line">power off</span><br></pre></td></tr></table></figure>
<p>系统安装完成~<br>
重启，通过BIOS启动菜单直接进入移动硬盘即可进入Arch Linux~</p>
<h1>参考资料</h1>
<ul>
<li><a href="https://wiki.archlinux.org/index.php/Installation_guide">Installation guide - ArchWiki</a></li>
<li><a href="https://blog.contabo.com/tutorials/mounting-additional-hard-disks-linux/">Mounting of additional hard disks in Linux | Official Blog - Contabo.com</a></li>
<li><a href="https://wiki.archlinux.org/index.php/Partitioning">Partitioning =ArchWiki</a></li>
<li><a href="https://wiki.archlinux.org/index.php/Fstab">fstab - ArchWiki</a></li>
<li><a href="https://wiki.archlinux.org/index.php/Microcode">Microcode - ArchWiki</a></li>
<li><a href="https://wiki.archlinux.org/index.php/GRUB">GRUB - ArchWiki</a></li>
<li><a href="https://www.cnblogs.com/tsdxdx/p/7215416.html">Arch Linux 安装记（安装到移动硬盘）- 天下掉下的X - 博客园</a></li>
<li><a href="https://www.jianshu.com/p/a1c10e6c9eba">arch linux安装到移动介质-简书</a></li>
<li><a href="http://smilejay.com/2012/06/swap_size/">交换分区(SWAP)的大小分配-笑遍世界</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Arch Linux</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>LaTeX-常用数学符号</title>
    <url>/zh-CN/LaTeX-common-math-symbol-equation/</url>
    <content><![CDATA[<p>本文整理 LaTeX 中常用的数学符号及一些数学元素的表达，以便查阅。</p>
<span id="more"></span>
<p>下列所有表示均在<strong>数学模式</strong>下。</p>
<p>更新：一个LaTeX 数学符号快速搜索工具：<a href="https://latex.guide/">LaTeX Search: Find LaTeX commands</a></p>
<h1>数学符号</h1>
<h2 id="希腊字母表">希腊字母表</h2>
<h3 id="小写字母">小写字母</h3>
<table>
<thead>
<tr>
<th>希腊字母</th>
<th>符号表示</th>
<th>希腊字母</th>
<th>符号表示</th>
<th>希腊字母</th>
<th>符号表示</th>
</tr>
</thead>
<tbody>
<tr>
<td>$\alpha$</td>
<td><code>\alpha</code></td>
<td>$\iota$</td>
<td><code>\iota</code></td>
<td>$\varrho$</td>
<td><code>\varrho</code></td>
</tr>
<tr>
<td>$\beta$</td>
<td><code>\beta</code></td>
<td>$\kappa$</td>
<td><code>\kappa</code></td>
<td>$\sigma$</td>
<td><code>\sigma</code></td>
</tr>
<tr>
<td>$\gamma$</td>
<td><code>\gamma</code></td>
<td>$\lambda$</td>
<td><code>\lambda</code></td>
<td>$\varsigma$</td>
<td><code>\varsigma</code></td>
</tr>
<tr>
<td>$\delta$</td>
<td><code>\delta</code></td>
<td>$\mu$</td>
<td><code>\mu</code></td>
<td>$\tau$</td>
<td><code>\tau</code></td>
</tr>
<tr>
<td>$\epsilon$</td>
<td><code>\epsilon</code></td>
<td>$\nu$</td>
<td><code>\nu</code></td>
<td>$\upsilon$</td>
<td><code>\upsilon</code></td>
</tr>
<tr>
<td>$\varepsilon$</td>
<td><code>\varepsilon</code></td>
<td>$\xi$</td>
<td><code>\xi</code></td>
<td>$\phi$</td>
<td><code>\phi</code></td>
</tr>
<tr>
<td>$\zeta$</td>
<td><code>\zeta</code></td>
<td>$o$</td>
<td><code>o</code></td>
<td>$\varphi$</td>
<td><code>\varphi</code></td>
</tr>
<tr>
<td>$\eta$</td>
<td><code>\eta</code></td>
<td>$\pi$</td>
<td><code>\pi</code></td>
<td>$\chi$</td>
<td><code>\chi</code></td>
</tr>
<tr>
<td>$\theta$</td>
<td><code>\theta</code></td>
<td>$\varpi$</td>
<td><code>\varpi</code></td>
<td>$\psi$</td>
<td><code>\psi</code></td>
</tr>
<tr>
<td>$\vartheta$</td>
<td><code>\vartheta</code></td>
<td>$\rho$</td>
<td><code>\rho</code></td>
<td>$\omega$</td>
<td><code>\omega</code></td>
</tr>
</tbody>
</table>
<h3 id="大写字母">大写字母</h3>
<p><em>注意</em> ：大写字母表示符号第一个字母需<strong>大写</strong>。</p>
<table>
<thead>
<tr>
<th>希腊字母</th>
<th>符号表示</th>
<th>希腊字母</th>
<th>符号表示</th>
<th>希腊字母</th>
<th>符号表示</th>
</tr>
</thead>
<tbody>
<tr>
<td>$\Gamma$</td>
<td><code>\Gamma</code></td>
<td>$\Xi$</td>
<td><code>\Xi</code></td>
<td>$\Phi$</td>
<td><code>\Phi</code></td>
</tr>
<tr>
<td>$\Delta$</td>
<td><code>\Delta</code></td>
<td>$\Pi$</td>
<td><code>\Pi</code></td>
<td>$\Psi$</td>
<td><code>\Psi</code></td>
</tr>
<tr>
<td>$\Theta$</td>
<td><code>\Theta</code></td>
<td>$\Sigma$</td>
<td><code>\Sigma</code></td>
<td>$\Omega$</td>
<td><code>\Omega</code></td>
</tr>
<tr>
<td>$\Lambda$</td>
<td><code>\Lambda</code></td>
<td>$\Upsilon$</td>
<td><code>\Upsilon</code></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="运算符号">运算符号</h2>
<h3 id="二元关系符">二元关系符</h3>
<p>下列命令可加上<code>\not</code>命令，得到否定形式。</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>命令</th>
<th>符号</th>
<th>命令</th>
<th>符号</th>
<th>命令</th>
</tr>
</thead>
<tbody>
<tr>
<td>$&lt;$</td>
<td><code>&lt;</code></td>
<td>$&gt;$</td>
<td><code>&gt;</code></td>
<td>$=$</td>
<td><code>=</code></td>
</tr>
<tr>
<td>$\leq$</td>
<td><code>\leq</code> or <code>\le</code></td>
<td>$\geq$</td>
<td><code>\geq</code> or <code>\ge</code></td>
<td>$\equiv$</td>
<td><code>\equiv</code></td>
</tr>
<tr>
<td>$\subset$</td>
<td><code>\subset</code></td>
<td>$\supset$</td>
<td><code>\supset</code></td>
<td>$\approx$</td>
<td><code>\approx</code></td>
</tr>
<tr>
<td>$\subseteq$</td>
<td><code>\subseteq</code></td>
<td>$\supseteq$</td>
<td><code>\supseteq</code></td>
<td>$\sim$</td>
<td><code>\sim</code></td>
</tr>
<tr>
<td>$\in$</td>
<td><code>\in</code></td>
<td>$\cong$</td>
<td><code>\cong</code></td>
<td>$\approx$</td>
<td><code>\approx</code></td>
</tr>
<tr>
<td>$\propto$</td>
<td><code>\propto</code></td>
<td>$\parallel$</td>
<td><code>\parallel</code></td>
<td>$\perp$</td>
<td><code>\prep</code></td>
</tr>
<tr>
<td>$\ll$</td>
<td>·<code>\ll</code></td>
<td>$\gg$</td>
<td><code>\gg</code></td>
<td>$\simeq$</td>
<td><code>\simeq</code></td>
</tr>
</tbody>
</table>
<h3 id="二元运算符">二元运算符</h3>
<table>
<thead>
<tr>
<th>符号</th>
<th>命令</th>
<th>符号</th>
<th>命令</th>
<th>符号</th>
<th>命令</th>
</tr>
</thead>
<tbody>
<tr>
<td>$\pm$</td>
<td><code>\pm</code></td>
<td>$\mp$</td>
<td><code>\mp</code></td>
<td>$\cdot$</td>
<td><code>\cdot</code></td>
</tr>
<tr>
<td>$\times$</td>
<td><code>\times</code></td>
<td>$\div$</td>
<td><code>\div</code></td>
<td>$\odot$</td>
<td><code>\odot</code></td>
</tr>
<tr>
<td>$\cup$</td>
<td><code>\cup</code></td>
<td>$\cap$</td>
<td><code>\cap</code></td>
<td>$\oplus$</td>
<td><code>\oplus</code></td>
</tr>
<tr>
<td>$\lor$</td>
<td><code>\vee</code> or <code>\lor</code></td>
<td>$\wedge$</td>
<td><code>\wedge</code> or <code>\land</code></td>
<td>$\circ$</td>
<td><code>\circ</code></td>
</tr>
</tbody>
</table>
<h3 id="积分">积分</h3>
<table>
<thead>
<tr>
<th>符号</th>
<th>命令</th>
<th>符号</th>
<th>命令</th>
<th>符号</th>
<th>命令</th>
</tr>
</thead>
<tbody>
<tr>
<td>$\int$</td>
<td><code>\int</code></td>
<td>$\iint$</td>
<td><code>\iint</code></td>
<td>$\iiint$</td>
<td><code>\iiint</code></td>
</tr>
</tbody>
</table>
<h3 id="根号">根号</h3>
<p>根号命令为<code>\sqrt[a]&#123;x&#125;</code>，$a$ 表示开根号的次数，$x$ 为指数，$\sqrt[a]{x}$。</p>
<h3 id="上下标">上下标</h3>
<ul>
<li>上标：$x^a$ 用<code>x^a</code>产生，当指数超过一个字符时应使用大括号包含，如<code>x^&#123;abc&#125;</code>产生$x^{abc}$。</li>
<li>下标：<code>x_a</code> 用<code>x_a</code>产生，同样地，当下标超过一个字符时也应该用大括号包含。</li>
</ul>
<h3 id="分数">分数</h3>
<p>分数用<code>\frac&#123;a&#125;&#123;b&#125;</code>表示 $\frac{a}{b}$ 。</p>
<h3 id="求和，求积">求和，求积</h3>
<ul>
<li>求和：求和符号$\sum$ 用<code>\sum</code>表示，在行间公式中当上下标将被压缩表示为$\sum_{i = 1}^n$，若希望产生类似于手写模式则应该加上<code>\limits</code>命令，如<code>\sum\limits\_&#123;i = 1&#125;&#123;n&#125;</code>表示 $\sum\limits_{i = 1}^{n}$ 。</li>
<li>求积：求积符号$\prod$ 用<code>\prod</code>表示，上下标规则与求和符号相同。</li>
</ul>
<h3 id="偏导">偏导</h3>
<p>偏导符号$\partial$用<code>\partial</code>表示。</p>
<h2 id="其他符号">其他符号</h2>
<h3 id="箭头">箭头</h3>
<table>
<thead>
<tr>
<th>符号</th>
<th>命令</th>
<th>符号</th>
<th>命令</th>
<th>符号</th>
<th>命令</th>
</tr>
</thead>
<tbody>
<tr>
<td>$\leftarrow$</td>
<td><code>\leftarrow</code></td>
<td>$\rightarrow$</td>
<td><code>\rightarrow</code></td>
<td>$\leftrightarrow$</td>
<td><code>\leftrightarrow</code></td>
</tr>
<tr>
<td>$\Leftarrow$</td>
<td><code>\Leftarrow</code></td>
<td>$\Rightarrow$</td>
<td><code>\Rightarrow</code></td>
<td>$\Leftrightarrow$</td>
<td><code>\Leftrightarrow</code></td>
</tr>
</tbody>
</table>
<h3 id="注音">注音</h3>
<table>
<thead>
<tr>
<th>符号</th>
<th>命令</th>
<th>符号</th>
<th>命令</th>
<th>符号</th>
<th>命令</th>
</tr>
</thead>
<tbody>
<tr>
<td>$\bar{x}$</td>
<td><code>\bar&#123;x&#125;</code></td>
<td>$\vec{x}$</td>
<td><code>\vec&#123;x&#125;</code></td>
<td>$\hat{x}$</td>
<td><code>\hat&#123;x&#125;</code></td>
</tr>
<tr>
<td>$\dot{x}$</td>
<td><code>\dot&#123;x&#125;</code></td>
<td>$\mathring{x}$</td>
<td><code>\mathring&#123;x&#125;</code></td>
<td>$\tilde{x}$</td>
<td><code>\tilde&#123;x&#125;</code></td>
</tr>
</tbody>
</table>
<h3 id="省略号">省略号</h3>
<ul>
<li>下标省略号 ： $x_1, x_2, \dots, x_n$用<code>\dots</code>表示；</li>
<li>中间省略号： $1, 2, \cdots, n$ 用<code>\cdots</code>表示；</li>
<li>纵向省略号：$\vdots$ 用<code>\vdots</code>表示；</li>
<li>斜向省略号：$\ddots$ 用<code>\ddots</code>表示。</li>
</ul>
<h3 id="数学粗体表示">数学粗体表示</h3>
<p>使用<code>\mathbf</code>命令：$\mathbf{R}$ 由 <code>\mathbf&#123;R&#125;</code> 生成。</p>
<h3 id="其他符号-2">其他符号</h3>
<table>
<thead>
<tr>
<th>符号</th>
<th>命令</th>
<th>符号</th>
<th>命令</th>
<th>符号</th>
<th>命令</th>
</tr>
</thead>
<tbody>
<tr>
<td>$\lfloor$</td>
<td><code>\lfloor</code></td>
<td>$\rfloor$</td>
<td><code>\rfloor</code></td>
<td>$\exists$</td>
<td><code>\exists</code></td>
</tr>
<tr>
<td>$\lceil$</td>
<td><code>\lceil</code></td>
<td>$\rceil$</td>
<td><code>\rceil</code></td>
<td>$\infty$</td>
<td><code>\infty</code></td>
</tr>
<tr>
<td>$\hbar$</td>
<td><code>\hbar</code></td>
<td>$\angle$</td>
<td><code>\angle</code></td>
<td>$\forall$</td>
<td><code>\forall</code></td>
</tr>
<tr>
<td>$\because$</td>
<td><code>\because</code></td>
<td>$\therefore$</td>
<td><code>\therefore</code></td>
<td>$\neg$</td>
<td><code>\neg</code> or <code>\lnot</code></td>
</tr>
</tbody>
</table>
<h1>矩阵</h1>
<p>使用 <code>\array</code>环境生成矩阵</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;array&#125;[外部对齐]&#123;列对齐&#125;</span><br><span class="line">    行列内容</span><br><span class="line"><span class="keyword">\end</span>&#123;array&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>外部对齐参数：整个矩阵和周围对象的纵向关系：
<ul>
<li>居顶：<code>t</code></li>
<li>居中（缺省）：<code>c</code></li>
<li>居底：<code>b</code></li>
</ul>
</li>
<li>列对齐参数
<ul>
<li>居左：<code>l</code></li>
<li>居中：<code>c</code></li>
<li>居右：<code>r</code></li>
</ul>
</li>
<li>换行：<code>\\</code></li>
<li>列分隔：<code>&amp;</code></li>
</ul>
<p>示例：<br>
$$<br>
\begin{array}{ccc}<br>
x_1    &amp; x_2    &amp; \cdots \<br>
x_3    &amp; x_4    &amp; \cdots \<br>
\vdots &amp; \vdots &amp; \ddots \<br>
\end{array}<br>
$$</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;array&#125;&#123;ccc&#125;    </span><br><span class="line">    x<span class="built_in">_</span>1    <span class="built_in">&amp;</span> x<span class="built_in">_</span>2    <span class="built_in">&amp;</span> <span class="keyword">\cdots</span> <span class="keyword">\\</span>    </span><br><span class="line">    x<span class="built_in">_</span>3    <span class="built_in">&amp;</span> x<span class="built_in">_</span>4    <span class="built_in">&amp;</span> <span class="keyword">\cdots</span> <span class="keyword">\\</span>    </span><br><span class="line">    <span class="keyword">\vdots</span> <span class="built_in">&amp;</span> <span class="keyword">\vdots</span> <span class="built_in">&amp;</span> <span class="keyword">\ddots</span> <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\end</span>&#123;array&#125;</span><br></pre></td></tr></table></figure>
<p>(分隔符对齐非必要，仅出于个人使用习惯）</p>
<p>使用<code>array</code>环境产生的矩阵没有旁边的各种分隔符，可以用以下环境替代产生分隔符：</p>
<p>$$<br>
\begin{pmatrix}<br>
a &amp; b \\<br>
c &amp; d<br>
\end{pmatrix}<br>
$$</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;pmatrix&#125;</span><br><span class="line">  a <span class="built_in">&amp;</span> b <span class="keyword">\\</span></span><br><span class="line">  c <span class="built_in">&amp;</span> d</span><br><span class="line"><span class="keyword">\end</span>&#123;pmatrix&#125;</span><br></pre></td></tr></table></figure>
<p>$$<br>
\begin{vmatrix}<br>
a &amp; b \\<br>
c &amp; d<br>
\end{vmatrix}<br>
$$</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;vmatrix&#125;</span><br><span class="line">  a <span class="built_in">&amp;</span> b <span class="keyword">\\</span></span><br><span class="line">  c <span class="built_in">&amp;</span> d</span><br><span class="line"><span class="keyword">\end</span>&#123;vmatrix&#125;</span><br></pre></td></tr></table></figure>
<h1>分段函数</h1>
<p>使用 <code>\cases</code>环境可以生成分段函数，同样可以用于方程组。</p>
<p>示例：<br>
$$<br>
y=<br>
\begin{cases}<br>
-x, \quad x\leq 0 \\<br>
x, \quad x &gt; 0<br>
\end{cases}<br>
$$</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">y= <span class="comment">% 换行是非必要的</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;cases&#125;</span><br><span class="line">    -x, <span class="keyword">\quad</span> x<span class="keyword">\leq</span> 0 <span class="keyword">\\</span></span><br><span class="line">    x, <span class="keyword">\quad</span> x &gt; 0</span><br><span class="line"><span class="keyword">\end</span>&#123;cases&#125;</span><br></pre></td></tr></table></figure>
<h1>参考资料</h1>
<ul>
<li><a href="http://www.ptep-online.com/ctan/lshort_chinese.pdf">一份不太简短的LATEX2ε介绍(PDF)</a></li>
<li><a href="http://dralpha.altervista.org/zh/tech/lnotes2.pdf">LATEX Notes雷太赫排版系统简介第二版v2.03 (PDF)</a></li>
<li><a href="http://mirrors.huaweicloud.com/repository/toolkit/CTAN/info/symbols/comprehensive/symbols-a4.pdf">The Comprehensive LATEX Symbol List (PDF)</a></li>
</ul>
]]></content>
      <categories>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>MATLAB 偏好设置</title>
    <url>/zh-CN/MATLAB-matlab-preference-settings/</url>
    <content><![CDATA[<ul>
<li>语言设置</li>
<li>修改暗色主题</li>
</ul>
<span id="more"></span>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="title class_">MATLAB</span>版本<span class="symbol">:R2014a</span></span><br><span class="line">操作系统：<span class="title class_">Windows</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>
<h1>语言设置</h1>
<p>在默认语言为中文的操作系统下安装和使用MATLAB，界面语言默认为中文，而并不是全部汉化，使用这样的专业软件习惯了英文界面，发现在预设里面并没有语言设置的选项，本文记录设置为英文的方法。</p>
<h2 id="设置步骤">设置步骤</h2>
<ol>
<li>打开“系统设置”窗口：<br>
控制面板-&gt;系统和安全-&gt;系统-&gt;高级系统设置；</li>
<li>单击右下角“环境变量(N)…”，弹出“环境变量”设置窗口；</li>
<li>在“系统变量(S)”窗口下方单击“新建(W)…”弹出“新建系统变量”窗口；</li>
<li>在“变量名(N)”一栏填入<code>MWLOCALE_TRANSLATED</code>；</li>
<li>在“变量值(V)”一栏填入<code>OFF</code>（若要恢复中文设置，只需要改变这个值为<code>ON</code>即可）。</li>
</ol>
<h1>修改为暗色主题</h1>
<ol>
<li>在命令行窗口输入命令<code>prefdir</code>查看预设文件所在路径；</li>
<li>在路径中找到文件<code>matlab.prf</code>将其中的内容进行替换，在<a href="https://github.com/scottclowe/matlab-schemer/tree/master/schemes%E4%B8%AD%E5%8F%AF%E4%BB%A5%E6%89%BE%E5%88%B0%E4%B8%80%E4%BA%9B%E9%85%8D%E8%89%B2%E6%96%B9%E6%A1%88%E3%80%82">https://github.com/scottclowe/matlab-schemer/tree/master/schemes中可以找到一些配色方案。</a></li>
</ol>
<h1>参考资料</h1>
<ul>
<li><a herf="https://cn.mathworks.com/matlabcentral/answers/129813-matlab-8-3-r2014a?s_tid=gn_loc_drophttps://cn.mathworks.com/matlabcentral/answers/129813-matlab-8-3-r2014a?s_tid=gn_loc_drop">在中文操作系统中，如何将中文版MATLAB 8.3(R2014a)转换为英文版？</a></li>
<li><a href = "https://ww2.mathworks.cn/help/matlab/ref/prefdir.html">包含预设项、设置、历史记录和布局文件的文件夹 - MATLAB prefdir - MathWorks 中国</a></li>
</ul>
]]></content>
      <categories>
        <category>MATLAB</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
        <tag>software</tag>
      </tags>
  </entry>
  <entry>
    <title>计算方法-[2]非线性方程的数值解法</title>
    <url>/zh-CN/Numerical-methods-solutions-of-nolinear-equations/</url>
    <content><![CDATA[<p>计算方法第二章非线性方程的数值解法课程内容整理。</p>
<span id="more"></span>
<p>以下Matlab代码于<a href="https://github.com/fish-404/Notes/tree/master/%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95/programs/Solutions%20of%20Nonlinear%20Equations">Notes/计算方法/programs/Solution of Nolinear Equations at master · fish-404/Notes</a> 中，使用时创建一个<code>f.m</code>文件写入待求解函数，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function y=f(x)</span><br><span class="line">y=sqrt(x)-cos(x);</span><br></pre></td></tr></table></figure>
<p>使用牛顿法，需要另外创建一个<code>fd.m</code>文件，写入待求解函数一阶导函数。</p>
<h2 id="二分法-Bisection-or-Binary-search-method">二分法 (Bisection or Binary-search method)</h2>
<h3 id="二分法">二分法</h3>
<h4 id="原理">原理</h4>
<p>函数 $f$ 在$[a, b]$ 上连续（$f \in C [a, b]$)，$f$在区间$[a,b]$的两个端点处异号($f(a)f(b) &lt; 0)$, 方程$f(x) = 0$在 $(a, b)$内至少有一个实根$p$，使得$f(p) = 0$，区间$[a,b]$称为方程的有根区间。</p>
<h4 id="采用二分法求出-p-的逼近过程">采用二分法求出$p$的逼近过程</h4>
<p>取$a_0 = a,b_0 = b$，中点$x_0 = \frac{a_0 + b_0}{2}$，若$f(x_0) = 0$，则 $p = x_0$，算法停止，否则如果$f(a_0)f(x_0)&lt;0$，取$a_1 = a_0$，$b_1 = x_0$；如果$f(x_0)f(b_0) &lt;0$，取$a_1 = x_0$，$b_1 = b_0$，方程的有根区间缩小为$[a_1,b_1]$。</p>
<p>重复上述步骤，不断缩小有根区间，直至找到满足精度的解。</p>
<p>算法的停止条件可以是：</p>
<ul>
<li>$|x_n-x_{n-1}|&lt;\varepsilon$</li>
<li>$\frac{|x_n-x_{n-1}}{|x_ n|}&lt;\varepsilon, \quad x_n \not= 0$</li>
<li>$|f(x_n)|&lt;\varepsilon$</li>
</ul>
<p><strong>注意</strong>：</p>
<ol>
<li>
<p>在使用计算机进行数值逼近时，需注意计算精度问题，计算区间中心值时，应选用公式<br>
$$<br>
x_n = a_n + \frac{b_n-a_n}{2}<br>
$$<br>
因为当$a_n$和$b_n$都接近机器精度时，$x_n = \frac{a_n + b_n}{2}$得到的值可能超出$[a_n，b_n]$范围。</p>
</li>
<li>
<p>在判断子区间${a_n,b_n}$中是否存在$f$的根时，应使用符号函数：<br>
$$<br>
sgn(x) = \begin{cases}<br>
-1, \quad x &lt; 0 \\<br>
0, \quad x = 0 \<br>
1,\quad x &gt; 0<br>
\end{cases}<br>
$$<br>
检查$f(a_n)$与$f(b_n)$是否异号，使用$sgn(f(a_n)\cdot sgn(f(b_n))&lt;0$，而不是$f(a_n)\cdot f(b_n) &lt;0$，避免乘积越界而导致错误。</p>
</li>
</ol>
<p><strong>定理2.1</strong><br>
设$f\in C[a,b]$，$f(a)f(b)&lt;0$，则二分法产生的数列${x_n}$满足<br>
$$<br>
|x_n - p| \le \frac{b-a}{2^{n+1}}<br>
$$<br>
其中$p\in[a,b]$是$f(x) = 0$的根，$n = 0,1,\cdots$。</p>
<ul>
<li>
<p><strong>收敛速率</strong><br>
由定理2.1，当$n\to \infty$时，数列${x_n}$以$O(\frac{1}{2^n})$的速度收敛到实际解$p$<br>
$$<br>
x_n = p + O(\frac{1}{2^n})<br>
$$<br>
收敛速度与比值为$\frac{1}{2}$的等比级数相同。</p>
</li>
<li>
<p><strong>估计求解步数</strong><br>
对于给定的精度$\varepsilon$，二分法找到满足某个精度的解所需步数$n+1$ 满足<br>
$$<br>
\frac{b-a}{2^{n+1}} &lt; \varepsilon \Rightarrow n+1 &gt; \frac{ln(b-a)-lnc}{ln 2}<br>
$$<br>
即：<br>
$$<br>
n + 1\ge \lceil \frac{ln(b-a) - ln\varepsilon}{ln2} \rceil<br>
$$<br>
实际误差可能比这个值小得多。</p>
</li>
</ul>
<h4 id="优缺点">优缺点</h4>
<ul>
<li>
<p><strong>优点</strong>:</p>
<ul>
<li>简单，总会收敛到解</li>
<li>只要求函数连续即可</li>
</ul>
</li>
<li>
<p><strong>缺点</strong>：</p>
<ul>
<li>收敛速度慢，只利用函数值的正负</li>
<li>只能用于求实根，无法用于求复根和偶重根</li>
</ul>
</li>
</ul>
<h4 id="二分法Matlab代码">二分法Matlab代码</h4>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% Bisection: get the solution of function f in [a,b]</span></span><br><span class="line"><span class="comment">% a : the interval lower bound </span></span><br><span class="line"><span class="comment">% b : the interval upper bound</span></span><br><span class="line"><span class="comment">% varphi : the presicion</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bisection</span><span class="params">(a, b, varphi)</span></span></span><br><span class="line">clc</span><br><span class="line"><span class="built_in">i</span>=<span class="number">1</span>;</span><br><span class="line"> fprintf(<span class="string">&#x27;n\t \t a_n \t\t b_n\t\t x_n\t |f(x_n)|\t \n&#x27;</span>)</span><br><span class="line"> <span class="keyword">while</span> <span class="built_in">i</span>&lt;<span class="number">100</span></span><br><span class="line">    p=a+(b-a)/<span class="number">2</span>;</span><br><span class="line">    w=f(p);</span><br><span class="line">    <span class="keyword">if</span> w==<span class="number">0</span> || ((b-a)/<span class="number">2</span>)&lt;varphi</span><br><span class="line">        fprintf(<span class="string">&#x27;%d\t%8.5g\t%8g\t%8.5g\t%8.5g\t%8.5g\t%8.5g\n&#x27;</span>,<span class="built_in">i</span> - <span class="number">1</span>,a,b,p,w,(b-a)/<span class="number">2</span>,(b-a)/<span class="number">2</span>/<span class="built_in">abs</span>(p));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    fprintf(<span class="string">&#x27;%d\t%8.5g\t%8.5g\t%8.5g\t%8.5g\t%8.5g\t%8.5g\n&#x27;</span>,<span class="built_in">i</span> - <span class="number">1</span>,a,b,p,w,(b-a)/<span class="number">2</span>,(b-a)/<span class="number">2</span>/<span class="built_in">abs</span>(p));</span><br><span class="line">    <span class="built_in">i</span>=<span class="built_in">i</span>+<span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">if</span> w*f(a)&lt;<span class="number">0</span></span><br><span class="line">        b=p;</span><br><span class="line">    <span class="keyword">else</span> a=p;</span><br><span class="line">    <span class="keyword">end</span>  </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="线性插值二分法">线性插值二分法</h3>
<h4 id="原理-2">原理</h4>
<p>在二分法的基础上，利用函数在区间两端点$a$和$b$上的连线与$x$轴的交点，缩小有根区间。<br>
$$<br>
x_n = b_n - f(b_n) \cdot \frac{b_n-a_n}{f(b_n)-f(a_n)}<br>
$$</p>
<p>在一定条件下，线性插值二分法比二分法的收敛速度快些。</p>
<h4 id="线性插值二分法Matlab代码">线性插值二分法Matlab代码</h4>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% Linear interpolation dichotomy</span></span><br><span class="line"><span class="comment">% a : the interval lower bound </span></span><br><span class="line"><span class="comment">% b : the interval upper bound</span></span><br><span class="line"><span class="comment">% varphi : the presicion</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LinearInterpolation</span><span class="params">(a, b, varphi)</span></span></span><br><span class="line">clc</span><br><span class="line">fprintf(<span class="string">&#x27;One point secant Iteration\n&#x27;</span>);</span><br><span class="line">fprintf(<span class="string">&#x27;n\t x_n\n&#x27;</span>);</span><br><span class="line"><span class="built_in">i</span>=<span class="number">1</span>;</span><br><span class="line">fa=f(a);</span><br><span class="line">fb=f(b);</span><br><span class="line"><span class="keyword">while</span> <span class="built_in">i</span>&lt;<span class="number">100</span></span><br><span class="line">    p=b-fb*(b-a)/(fb-fa);</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">abs</span>(p-b)&lt;varphi</span><br><span class="line">        fprintf(<span class="string">&#x27;%d\t%g\n&#x27;</span>,<span class="built_in">i</span>,p);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    fprintf(<span class="string">&#x27;%d\t%g\n&#x27;</span>,<span class="built_in">i</span>,p);</span><br><span class="line">    <span class="built_in">i</span>=<span class="built_in">i</span>+<span class="number">1</span>;</span><br><span class="line">    q=f(p);</span><br><span class="line">    <span class="keyword">if</span> q*fb&lt;<span class="number">0</span></span><br><span class="line">        a=b;</span><br><span class="line">        fa=fb;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    b=p;</span><br><span class="line">    fb=q;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="迭代法-Iteration-Method">迭代法 (Iteration Method)</h2>
<p>将区间$[a,b]$上的方程$f(x) = 0$改写成等价形式：<br>
$$<br>
x = \varphi(x), a\le x\le b<br>
$$<br>
其中$\varphi \in C[a,b]$。</p>
<ul>
<li><strong>迭代数列</strong>${x_n}$<br>
$$<br>
x_n = \varphi(x_{n - 1}), n = 1, 2, \cdots<br>
$$<br>
上式称为$f(x) = 0$的一个<strong>迭代格式</strong>， $x_0$ 称为<strong>迭代初值</strong></li>
</ul>
<h3 id="一般迭代法-不动点迭代法-Fixed-Point-Iteration-函数迭代法-Functional-Iteration">一般迭代法\不动点迭代法(Fixed-Point Iteration)\函数迭代法(Functional Iteration)</h3>
<p>如果数列${x_n}$ , 设$\lim\limits_{n\to \infty} x_n = p$，则</p>
<p>$$<br>
p = \lim\limits_{n\to \infty}<br>
x_{n+1} = \lim \limits_{n\to \infty} \varphi(x_n) =\varphi(\lim \limits_{n\to \infty } x_n ) = \varphi(p)<br>
$$</p>
<p>此时$p$为方程 $f(x) = 0$ 的根。</p>
<h4 id="不动点理论">不动点理论</h4>
<ul>
<li>定义2.1<br>
对于函数$\varphi$, 若点$p$ 使得$\varphi(p) = p$，称$p$为$\varphi$的不动点。</li>
</ul>
<h5 id="不动点存在的充分条件">不动点存在的充分条件</h5>
<ul>
<li>定理2.2<br>
若函数$\varphi \in C[a,b]$且对于$\forall x\in [a, b]$有$\varphi(x) \in [a,b]$ ，那么$\varphi$在$[a,b]$上有不动点。</li>
</ul>
<h5 id="区间内不动点存在且唯一的充分条件">区间内不动点存在且唯一的充分条件</h5>
<ul>
<li>定理 2.3<br>
满足定理2.2的前提下，如果函数$\varphi$满足李普希茨(Lipschitz)条件<br>
$$<br>
|\varphi(x) - \varphi(y)| \le L|x- y|, \forall x, y \in [a,b]<br>
$$<br>
并且常数$0 &lt; L &lt;1$，那么$\varphi$在$[a,b]$上有唯一的不动点。</li>
<li>定理2.4<br>
满足定理2.2的前提下，如果$\varphi$在$(a,b)$上有一阶连续导数，且存在常数$0&lt;L&lt;1$使得<br>
$$<br>
|\varphi’(x) |\le L, \forall x \in[a,b]<br>
$$<br>
那么$\varphi$在$[a,b]$上有唯一的不动点。</li>
</ul>
<p><em>注意</em> ，定理2.3与定理2.4为充分条件，也即即使$\varphi$不满足这两个定理，也可能存在不动点唯一的情况。</p>
<h4 id="迭代收敛的条件">迭代收敛的条件</h4>
<ul>
<li>
<p>定义2.2<br>
满足定理2.3或定理2.4的函数$\varphi$称为区间$[a,b]$上的<strong>压缩映射</strong>，式中的$L$称为$\varphi$的<strong>压缩系数</strong>。</p>
</li>
<li>
<p>定理2.5 <strong>迭代收敛定理\压缩映射定理\不动点定理</strong><br>
若$\varphi$是区间$[a,b]$上的压缩映射，那么对于$\forall x_0 \in [a,b]$，由迭代公式$x_n = \varphi(x_{n-1})$产生的数列${x_n}$收敛到方程$x = \varphi(x)$在$[a,b]$上的唯一解。</p>
</li>
</ul>
<h4 id="不动点迭代法Matlab代码">不动点迭代法Matlab代码</h4>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% Functional Iteration / Fixed-Point Iteration</span></span><br><span class="line"><span class="comment">% varphi : the presicion</span></span><br><span class="line"><span class="comment">% x0 : the initial value</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FunctionalIteration</span><span class="params">(varphi, x0)</span></span></span><br><span class="line">clc</span><br><span class="line"><span class="built_in">i</span>=<span class="number">1</span>;</span><br><span class="line">fprintf(<span class="string">&#x27;n\t x_n\n&#x27;</span>);</span><br><span class="line"><span class="keyword">while</span> <span class="built_in">i</span>&lt;<span class="number">100</span></span><br><span class="line">    x=f(x0);</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">abs</span>(x-x0)&lt;varphi</span><br><span class="line">        fprintf(<span class="string">&#x27;%d\t%g\n&#x27;</span>,<span class="built_in">i</span>,x);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    fprintf(<span class="string">&#x27;%d\t%g\n&#x27;</span>,<span class="built_in">i</span>,x);</span><br><span class="line">    <span class="built_in">i</span>=<span class="built_in">i</span>+<span class="number">1</span>;</span><br><span class="line">    x0=x;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="迭代算法理论">迭代算法理论</h3>
<ul>
<li>迭代法的几何意义<br>
相当于把曲线$y = \varphi(x)$与直线$y = x$的求交问题，近似地转化为数列${x_n}$向不动点逼近的过程，其中$x_n = \varphi(x_{n-1}), n = 1, 2, \cdots$。</li>
<li>定理 2.6 压缩系数与迭代收敛速度的关系<br>
若$\varphi$是区间$[a,b]$上的压缩映射，迭代过程中解的误差满足<br>
$$<br>
|x_n - p| &lt;L^n \max(x_0 - a, b-x_0)<br>
$$<br>
$$<br>
|x_n - p| \le \frac{L}{1-L}|x_n - x_{n - 1}|\le \frac{L^n}{1-L}|x_1 - x_0|<br>
$$<br>
其中$p$为区间$[a,b]$上的不动点，$(0&lt;L&lt;1)$为$\varphi$在区间$[a,b]$的压缩系数，$n = 1, 2, \cdots$。</li>
</ul>
<p>压缩系数$L$的值越小，$x_n$趋近$p$的速度越快，而当$L$的值接近于1时，迭代法的收敛速度就变得很慢。</p>
<ul>
<li>定理2.7 局部收敛性<br>
设$p$时函数$\varphi$的不动点，且$\varphi’(p) \ne 1$，如果存在常数$\delta&lt;0$使得$\varphi$在区间$[p-\delta, p+\delta]$上满足定理2.4， 那么一般迭代法得到的数列对任意初值$x_0 \in [p-\delta, p+ \delta]$收敛。</li>
</ul>
<h4 id="收敛阶">收敛阶</h4>
<ul>
<li>
<p>定义2.3<br>
对于一个收敛到$p$的数列${x_n}$， $x_n \ne p$， 如果存在实数$\lambda$和$\alpha$使得<br>
$$<br>
\lim \limits_{n\to \infty} \frac{|x_{n+1} - p|}{|x_n - p|^\alpha} = \lambda<br>
$$</p>
</li>
<li>
<p>当$\lambda \ne 0$时数列${x_n}$的<strong>收敛阶</strong>是$\alpha$，$\lambda$为<strong>渐近误差常数</strong>。</p>
<ol>
<li>若$\alpha = 1$, 称数列<strong>线性收敛</strong>或<strong>1阶收敛</strong>。</li>
<li>若$\alpha = 2$，称数列<strong>平方收敛</strong>或<strong>2阶收敛</strong>。</li>
<li>若$\alpha &gt;1$，称数列<strong>超线性收敛</strong>或$\alpha$阶收敛。</li>
</ol>
</li>
<li>
<p>当$\lambda = 0$时称数列${x_n}$的收敛阶高于$\alpha$。</p>
</li>
<li>
<p>迭代法的普遍性定理<br>
满足压缩映射的函数$\varphi$得到的数列${x_n}$:</p>
<ul>
<li>当$\varphi’(p) \ne 0$时，对$\forall x_0 \in [a,b]$，数列${x_n}$都收敛到区间$[a,b]$上唯一的不动点$p$。</li>
<li>当$\varphi’(p) = 0$，$\varphi$在$(a,b)$有二阶连续导数，且$\varphi’'(p) \ne 0$时数列的收敛阶是2.</li>
</ul>
</li>
</ul>
<h3 id="加速收敛迭代法">加速收敛迭代法</h3>
<h4 id="埃特金方法-（Aitken">埃特金方法 （Aitken)</h4>
<p>对于一个收敛到 $p$ 的数列${x_n}$，如果其收敛阶为1， 那么<br>
$$<br>
\lim \limits_{n \to \infty}\frac{|x_{n+1} - p|}{|x_n - p|} = C， C 为常数，0&lt; C &lt; 1<br>
$$<br>
可以认为当$n \to \infty$时有<br>
$$<br>
\frac{x_n  -p}{x_{n - 1} - p } \approx \frac{x_{n - 1} - p}{x_{n - 2} - p}<br>
$$<br>
得到<strong>Aitken数列</strong>$\hat$<br>
$$<br>
\hat{x_n} = x_n - \frac{(x_n - x_{n - 1})^2}{x_n - 2 x_{n - 1} + x_{n - 2}}<br>
$$</p>
<ul>
<li>定理2.9<br>
若数列${x_ n}$以1阶收敛到$p$，记<br>
$$<br>
e_n = x_n - p \ne 0<br>
$$<br>
对一切$n\ge 0$成立，且<br>
$$<br>
\lim \limits_{n\to \infty} \frac{e_{n+1}}{e_n} = \lambda, \quad |\lambda| &lt; 1<br>
$$<br>
则Aitken数列$\hat{x_n}$是完全确定的，且<br>
$$<br>
\lim \limits_{n\to \infty} \frac{\hat{x_n} -p}{x_n - p} = 0<br>
$$<br>
即Aitken数列${\hat{x_n}}$比数列${x_n}$更快收敛到$p$。</li>
</ul>
<h5 id="Aitken-加速迭代法Matlab代码">Aitken 加速迭代法Matlab代码</h5>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% AitkenIteration</span></span><br><span class="line"><span class="comment">% x0 : the initial value</span></span><br><span class="line"><span class="comment">% varphi : the presicion</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AitkenIteration</span><span class="params">(x0, varphi)</span></span></span><br><span class="line">clc</span><br><span class="line"><span class="built_in">i</span>=<span class="number">1</span>;</span><br><span class="line">x1=f(x0);</span><br><span class="line">p=x0;</span><br><span class="line">fprintf(<span class="string">&#x27;Aitken Iteration\n&#x27;</span>);</span><br><span class="line">fprintf(<span class="string">&#x27;n\t x_n\n&#x27;</span>);</span><br><span class="line">fprintf(<span class="string">&#x27;0\t%g\n&#x27;</span>,x0);</span><br><span class="line"><span class="keyword">while</span> <span class="built_in">i</span>&lt;<span class="number">100</span>   </span><br><span class="line">    x2=f(x1);</span><br><span class="line">    x=x0-(x1-x0).^<span class="number">2.</span>/(x2<span class="number">-2</span>*x1+x0);</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">abs</span>(x-p)&lt;varphi</span><br><span class="line">        fprintf(<span class="string">&#x27;%d\t%g\n&#x27;</span>,<span class="built_in">i</span>,x);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    fprintf(<span class="string">&#x27;%d\t%g\n&#x27;</span>,<span class="built_in">i</span>,x);</span><br><span class="line">    <span class="built_in">i</span>=<span class="built_in">i</span>+<span class="number">1</span>;</span><br><span class="line">    x0=x1;</span><br><span class="line">    x1=x2;</span><br><span class="line">    p=x;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="Steffensen-方法">Steffensen 方法</h4>
<p>Aitken 数列可以对任意线性收敛的数列进行处理。若将Aitken方法与不动点结合则可以得到Steffensen方法</p>
<ul>
<li>定理2.10<br>
设$p$是函数$\varphi$的不动点，那么具有下列迭代格式的函数$\psi$与$\varphi$具有相同的不动点。<br>
$$<br>
x_n = \psi(x_{n-1}) =<br>
\frac{x_{n-1}\varphi(\varphi(x_{n-1})) - [\varphi(x_{n-1})]^2}{\varphi(\varphi(x_{n-1})) - 2\varphi(x_{n - 1})+ x_{n-1}}<br>
=x_{n-1} -<br>
\frac{[\varphi(x_{n-1} - x_{n-1}]^2}{\varphi(\varphi(x_{n-1})) - 2\varphi(x_{n-1}) + x_{n-1}}<br>
$$</li>
<li>定理2.11<br>
设$p$是函数$\varphi$的不动点，且$\varphi’(p)\ne1$，如果存在常数$\delta&gt;0$使得$\varphi$在区间$[p - \delta, p + \delta]$上有三阶连续导数，那么 Steffensen 方法得到的数列对任意初值$x_0 \in [p - \delta, p+ \delta]$二阶收敛。</li>
</ul>
<h5 id="Steffensen-迭代的特点">Steffensen 迭代的特点</h5>
<ul>
<li>对于一阶收敛到$p$的数列$x_{n+1} = \varphi(x_n)$，在$\varphi '(p)\ne 1$时，Steffensen 方法得到的数列二阶收敛</li>
<li>对于原本不收敛的数列，Steffensen 方法也可能把它改进为二阶收敛</li>
<li>对于超线性收敛（大于1阶）数列，改用 Steffensen 方法的意义不大</li>
<li>Steffensen 方法多用于改进一阶方法</li>
</ul>
<h5 id="Steffensen-迭代法Matlab代码">Steffensen 迭代法Matlab代码</h5>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% SteffensenIteration</span></span><br><span class="line"><span class="comment">% x0 : the initial value</span></span><br><span class="line"><span class="comment">% varphi : the presicion</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SteffensenIteration</span><span class="params">(x0, varphi)</span></span></span><br><span class="line"><span class="built_in">i</span>=<span class="number">1</span>;</span><br><span class="line">fprintf(<span class="string">&#x27;Steffensen Iteration\n&#x27;</span>);</span><br><span class="line">fprintf(<span class="string">&#x27;n\t x_n\n&#x27;</span>);</span><br><span class="line">fprintf(<span class="string">&#x27;0\t%g\n&#x27;</span>,x0);</span><br><span class="line"><span class="keyword">while</span> <span class="built_in">i</span>&lt;<span class="number">100</span>   </span><br><span class="line">    x1=f(x0);</span><br><span class="line">    x2=f(x1);</span><br><span class="line">    x=x0-(x1-x0).^<span class="number">2.</span>/(x2<span class="number">-2</span>*x1+x0);</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">abs</span>(x-x0)&lt;varphi</span><br><span class="line">        fprintf(<span class="string">&#x27;%d\t%g\n&#x27;</span>,<span class="built_in">i</span>,x);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    fprintf(<span class="string">&#x27;%d\t%g\n&#x27;</span>,<span class="built_in">i</span>,x);</span><br><span class="line">    <span class="built_in">i</span>=<span class="built_in">i</span>+<span class="number">1</span>;</span><br><span class="line">    x0=x;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="牛顿法-牛顿切线法-牛顿迭代法-Newton-Raphson-Methon">牛顿法/牛顿切线法/牛顿迭代法(Newton-Raphson Methon)</h2>
<p>将非线性方程线性化，有<br>
$$<br>
f(x) = f(x_n) + f’(x_n)(x-x_0)<br>
$$<br>
当$f’(x_n)\ne0$，用$x_{n+1}$代替$x$，由$f(x) = 0$得到迭代公式：<br>
$$<br>
x_{n+1} = x_n -<br>
\frac{f(x_n)}{f’(x_n)}<br>
$$<br>
即<br>
$$<br>
\varphi(x) = x - \frac{f(x)}{f’(x)}<br>
$$<br>
从几何角度来解释，即过$(x_n, f(x_n))$作曲线$y = f(x)$的切线，切线与$x$轴交点的横坐标即为$x_{n+1}$。</p>
<ul>
<li>定理2.12 牛顿法收敛的充分条件<br>
设$f\in C^2[a, b]$，即$f$在$[a,b]$上有二阶连续导数，若</li>
</ul>
<ol>
<li>$f(a)f(b)&lt;0$</li>
<li>$f’$与$f’'$在$[a,b]$上符号保持不变</li>
<li>$f(x_0)f’'(x)&gt;0, x_0, x\in [a,b]$（$x_0$为迭代初值）<br>
那么由牛顿迭代格式生成的数列${x_n}$收敛于方程$f(x) = 0$在${a,b]$上的唯一解，且收敛阶为2。</li>
</ol>
<ul>
<li>推论2.1<br>
设$f\in C^2[a,b]$且$f(a)f(b)&lt;0$，并在$[a,b]$上$f’f’'&gt;0$，那么当迭代初值$x_0 = b$时，由牛顿迭代格式生成的数列${x_n}$是一个严格递减有下界的数列，它收敛于方程$f(x) = 0$在$[a,b]$上的唯一解，且收敛阶为2.</li>
<li>推论2.2<br>
设$f\in C^2[a,b]$且$f(a)f(b)&lt;0$，并在$[a,b]$上$f’f’'&lt;0$，那么当迭代初值$x_0 = a$时，由牛顿迭代格式生成的数列${x_n}$是一个严格递增有上届的数列，它收敛于方程$f(x) = 0$在$[a,b]$上的唯一解，且收敛阶为2.</li>
<li>定理2.13 牛顿法的局部收敛性<br>
设$f\in C^2[a,b]$，如果存在$p \in [a,b]$使得$f(p) = 0$和$f’(p)\ne 0$，那么存在一个正数$\delta &gt;0$使得牛顿法生成的数列${x_n}$对$\forall x_0 \in [p - \delta, p+ \delta]$都收敛于$p$，即数列${x_n}$局部收敛于$p$，并且二阶收敛。</li>
</ul>
<p>牛顿法的致命弱点在于每次迭代除了计算函数值外还要计算导数值。</p>
<h3 id="牛顿法Matlab代码">牛顿法Matlab代码</h3>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% Newton-Raphson Method</span></span><br><span class="line"><span class="comment">% x0 : the initial value</span></span><br><span class="line"><span class="comment">% varphi : the presicion</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NewtonRaphsonMethod</span><span class="params">(x0, varphi)</span></span></span><br><span class="line">clc</span><br><span class="line"><span class="built_in">i</span>=<span class="number">1</span>;</span><br><span class="line">fprintf(<span class="string">&#x27;Newton Iteration\n&#x27;</span>);</span><br><span class="line">fprintf(<span class="string">&#x27;n\t x_n\n&#x27;</span>);</span><br><span class="line">fprintf(<span class="string">&#x27;0\t%g\n&#x27;</span>,x0);</span><br><span class="line"><span class="keyword">while</span> <span class="built_in">i</span>&lt;<span class="number">100</span>   </span><br><span class="line">    x=x0-f(x0)/fd(x0);</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">abs</span>(x-x0)&lt;varphi</span><br><span class="line">        fprintf(<span class="string">&#x27;%d\t%g\n&#x27;</span>,<span class="built_in">i</span>,x);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    fprintf(<span class="string">&#x27;%d\t%g\n&#x27;</span>,<span class="built_in">i</span>,x);</span><br><span class="line">    <span class="built_in">i</span>=<span class="built_in">i</span>+<span class="number">1</span>;</span><br><span class="line">    x0=x;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="弦截法-割线法-双点弦截法-Secant-method">弦截法/割线法/双点弦截法(Secant method)</h2>
<p>使用差商代替牛顿法中的$f’(x_n)$：<br>
$$<br>
x_{n+ 1} = x_n -<br>
\frac{f(x_0)(x_0 - x_{n-1})}{f(x_n)-f(x_{n-1}）}<br>
$$<br>
几何意义： 用过点$(x_{n-1}, f(x_{n-1}))$和$(x_n, f(x_n))$的割线与$x$轴的交点逼近方程$f(x) = 0$的解。</p>
<ul>
<li>定理2.14<br>
设$f(p) = 0$，在$p$的一个邻域$\Delta = [p - \delta, p+ \delta]$内$f \in C^2(\Delta)$， $f’(\Delta)\ne 0$, $M \delta&lt;1$，其中<br>
$$<br>
M = \frac{\max \limits_{x\in \Delta}|f’‘(x)|}{2 \min \limits_{x\in \Delta}|f’(x)|}<br>
$$<br>
则当$x_0x_1\in \Delta$时，由弦截法迭代格式产生的数列${x_n} \subset \Delta$收敛于$p$，且收敛阶为 $\frac{1+\sqrt{5}}{2} \approx 1.618$</li>
</ul>
<h3 id="弦截法Matlab代码">弦截法Matlab代码</h3>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% Secant Method: get the solution of function f in [a,b]</span></span><br><span class="line"><span class="comment">% x0 : the initial value</span></span><br><span class="line"><span class="comment">% x1 : the initial value</span></span><br><span class="line"><span class="comment">% varphi : the presicion</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SecantMethod</span><span class="params">(x0, x1, varphi)</span></span></span><br><span class="line">clc</span><br><span class="line"><span class="built_in">i</span>=<span class="number">1</span>;</span><br><span class="line">fprintf(<span class="string">&#x27;Secant Iteration\n&#x27;</span>);</span><br><span class="line">fprintf(<span class="string">&#x27;n\t x_n\n&#x27;</span>);</span><br><span class="line">fprintf(<span class="string">&#x27;0\t%.5f\n&#x27;</span>,x0);</span><br><span class="line">fprintf(<span class="string">&#x27;1\t%.5f\n&#x27;</span>,x1);</span><br><span class="line">w0=f(x0);</span><br><span class="line"><span class="keyword">while</span> <span class="built_in">i</span>&lt;<span class="number">100</span></span><br><span class="line">    w1=f(x1);</span><br><span class="line">    x=x1-w1*(x1-x0)/(w1-w0);</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">abs</span>(x-x1)&lt;varphi</span><br><span class="line">        fprintf(<span class="string">&#x27;%d\t%g\n&#x27;</span>,<span class="built_in">i</span>+<span class="number">1</span>,x);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    fprintf(<span class="string">&#x27;%d\t%g\n&#x27;</span>,<span class="built_in">i</span>+<span class="number">1</span>,x);</span><br><span class="line">    <span class="built_in">i</span>=<span class="built_in">i</span>+<span class="number">1</span>;</span><br><span class="line">    x0=x1;</span><br><span class="line">    x1=x;</span><br><span class="line">    w0=w1;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="抛物线法-Muller法（Parabola-Iteration">抛物线法/Müller法（Parabola Iteration)</h2>
<p>弦截法是通过$(x_{n-1}, f(x_{n-1}))$和$(x_n, f(x_n))$两点做直线与$x$轴的焦点得出$x_{n+1}$，而抛物线法则是过$(x_{n-2}, f(x_{n-2})), (x_{n-1}, f(x_{n-1}))$和$(x_n, f(x_n))$三点作抛物线与$x$轴的交点作为$x_{n+1}$。<br>
迭代公式为<br>
$$<br>
x_{n+1} = x_n - \frac{2c}{b + sgn(b)\sqrt{b^2 - 4ac}}<br>
$$<br>
抛物线法可用于求解非线性方程的实根和复根，特别适用于多项式的求根问题。收敛阶为1.839。</p>
<h3 id="抛物线法Matlab代码">抛物线法Matlab代码</h3>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% Parabolalteration Method</span></span><br><span class="line"><span class="comment">% x0 : the initial value</span></span><br><span class="line"><span class="comment">% x1 : the initial value</span></span><br><span class="line"><span class="comment">% x2 : the initial value</span></span><br><span class="line"><span class="comment">% varphi : the presicionclc</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ParabolaIteration</span><span class="params">(x0, x1, x2, varphi)</span></span></span><br><span class="line"><span class="built_in">i</span>=<span class="number">3</span>;</span><br><span class="line">fprintf(<span class="string">&#x27;Parabola Iteration\n&#x27;</span>);</span><br><span class="line">fprintf(<span class="string">&#x27;n\t x_n\n&#x27;</span>);</span><br><span class="line">fprintf(<span class="string">&#x27;0\t%.5f\n&#x27;</span>,x0);</span><br><span class="line">fprintf(<span class="string">&#x27;1\t%.5f\n&#x27;</span>,x1);</span><br><span class="line">fprintf(<span class="string">&#x27;2\t%.5f\n&#x27;</span>,x2);</span><br><span class="line">h1=x1-x0;</span><br><span class="line">h2=x2-x1;</span><br><span class="line">w1=(f(x1)-f(x0))/h1;</span><br><span class="line">w2=(f(x2)-f(x1))/h2;</span><br><span class="line">d=(w2-w1)/(h2+h1);</span><br><span class="line"><span class="keyword">while</span> <span class="built_in">i</span>&lt;<span class="number">100</span></span><br><span class="line">    b=w2+h2*d;</span><br><span class="line">    D=<span class="built_in">sqrt</span>(b*b<span class="number">-4</span>*f(x2)*d);</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">abs</span>(b-D)&lt;<span class="built_in">abs</span>(b+D)</span><br><span class="line">        E=b+D;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        E=b-D;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    h=<span class="number">-2</span>*f(x2)/E;</span><br><span class="line">    p=x2+h;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">abs</span>(h)&lt;varphi</span><br><span class="line">        fprintf(<span class="string">&#x27;%d\t%g\n&#x27;</span>,<span class="built_in">i</span>, p);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    fprintf(<span class="string">&#x27;%d\t%g\n&#x27;</span>,<span class="built_in">i</span>,p);</span><br><span class="line">    <span class="built_in">i</span>=<span class="built_in">i</span>+<span class="number">1</span>;</span><br><span class="line">    x0=x1;</span><br><span class="line">    x1=x2;</span><br><span class="line">    x2=p;</span><br><span class="line">    h1=x1-x0;</span><br><span class="line">    h2=x2-x1;</span><br><span class="line">    w1=(f(x1)-f(x0))/h1;</span><br><span class="line">    w2=(f(x2)-f(x1))/h2;</span><br><span class="line">    d=(w2-w1)/(h2+h1);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算方法</category>
      </categories>
      <tags>
        <tag>Numerical methods</tag>
      </tags>
  </entry>
  <entry>
    <title>计算方法-[3]线性方程组的数值解法</title>
    <url>/zh-CN/Numerical-solution-of-linear-equations/</url>
    <content><![CDATA[<p>计算方法第三章线性方程的数值解法课程内容整理，尚未包含代码部分。</p>
<span id="more"></span>
<h2 id="直接法">直接法</h2>
<h3 id="高斯消去法-Gaussian-Elimination">高斯消去法(Gaussian Elimination)</h3>
<p>$$<br>
\mathbf{Ax} = \mathbf{b} \Rightarrow<br>
\begin{bmatrix}<br>
a_{11} &amp; \cdots &amp; a_{1n} \\<br>
&amp; \ddots &amp; \vdots \\<br>
&amp;        &amp; a_{nn}^{(n-1)}<br>
\end{bmatrix}\mathbf{x} =<br>
\begin{bmatrix}<br>
b_1 \\<br>
\vdots \\<br>
b_n^{(n-1)}<br>
\end{bmatrix}<br>
$$</p>
<ul>
<li>消去：</li>
</ul>
<p>$$<br>
l_{ik} = a_{ik}^{(k)}/a_{kk}^{(k)}  \<br>
$$<br>
$$<br>
\begin{cases}<br>
a_{ij}^{(k+1)} = a_{ij}^{(k)} - l_{ik} a_{kj}^{(k)} \\<br>
b_{i}^{(k+1)} = b_{i}^{(k)} - l_{ik} b_{k}^{(k)}<br>
\end{cases}<br>
(k = 1,2，\cdots, n - 1 ,  \quad i，j = k + 1, k + 2, \cdots, n)<br>
$$</p>
<ul>
<li>回代：</li>
</ul>
<p>$$<br>
\begin{cases}<br>
x_n = b_n^{(n)} / a^{(n)}_{nn}\\<br>
x_i = (b_i^{(i)} - \sum\limits^n_{j = i+1})/a_{ii}^{(i)}<br>
\end{cases}<br>
\quad i = n - 1, n - 2, \cdots, 1<br>
$$</p>
<ul>
<li>复杂度 ： $O(n^3)$</li>
</ul>
<h3 id="列主元消去法">列主元消去法</h3>
<p>主元素：$a_{kk}^{(k)}$ (作为除数的元素)</p>
<p>使用高斯消去法时，若除数很小，除法计算时将产生较大的舍入误差，影响后续消元。</p>
<p>列主元消去法即改进的高斯消去法，在选取主元素时按列选取待消去的矩阵元素中 <strong>绝对值</strong> 最大的元素与当前行交换，成为新的主元素。即：<br>
$$<br>
if \quad \max_{k \le i\le n}|a_{i_k}| \ne 0 \quad and \quad i_k \ne k \\<br>
then \quad i_k \leftrightarrow k<br>
$$</p>
<p>相比于高斯消去法，列主元消去法更稳定，但行列交换需花费较多时间，计算量高于高斯消去法 $O(n^2/3)$。</p>
<h3 id="高斯-若当消去法（Gauss-Jordan-Method">高斯-若当消去法（Gauss-Jordan Method)</h3>
<p>$$<br>
\mathbf{Ax} = \mathbf{b} \Rightarrow<br>
\begin{bmatrix}<br>
a_{11} &amp;  &amp; \\<br>
&amp; \ddots &amp;\\<br>
&amp; &amp; a_{nn}^{(n-1)}<br>
\end{bmatrix}\mathbf{x} =<br>
\begin{bmatrix}<br>
b_1 \\<br>
\vdots \\<br>
b_n^{(n-1)}<br>
\end{bmatrix}<br>
$$</p>
<ol>
<li>将当前列主元 $a_{kk}^{(k)}$ 变为1</li>
<li>将  $a_{kk}^{(k)}$ 所在列的上下元素变为0</li>
</ol>
<p>计算量比高斯消去法多$(n^3-3n^2 + 2n)/6$ 次乘除。常用于求逆矩阵。</p>
<ul>
<li>高斯若当法求逆矩阵</li>
</ul>
<p>$$<br>
[A|E] \Rightarrow[E| A^{-1}]<br>
$$</p>
<h3 id="LU-分解法">LU 分解法</h3>
<p>$n$阶矩阵$A$,若其所有顺序主子式均不为0，则可将其分解为一个单位下三角矩阵$L$ 和一个上三角矩阵$U$的乘积，且这种分解唯一。<br>
$$<br>
\mathbf{A} =<br>
\begin{bmatrix}<br>
1 &amp; &amp; &amp; \\<br>
l_{21} &amp; 1 &amp; &amp; \\<br>
\vdots &amp; \vdots &amp; \ddots &amp; \\<br>
l_{n1} &amp; l_{n2} &amp; \cdots &amp; 1<br>
\end{bmatrix}<br>
\begin{bmatrix}<br>
u_{11} &amp; u_{12} &amp; \cdots &amp; u_{1n} \\<br>
&amp; u_{22} &amp; \cdots &amp; u_{2n} \\<br>
&amp;        &amp; \ddots &amp; \vdots \\<br>
&amp;        &amp;        &amp; u_{nn}<br>
\end{bmatrix}<br>
$$</p>
<p>求解过程：<br>
$$<br>
\mathbf{A}^{(k)} = \mathbf{L}_{k-1} \mathbf{A}^{(k-1)}\\<br>
\mathbf{U} = \mathbf{A}^{(n)} = \mathbf{L}_{n-1}\mathbf{A}^{(k-1)}\\<br>
\mathbf{L}_k =<br>
\begin{bmatrix}<br>
1 &amp;  &amp;  &amp;  \\<br>
&amp; 1 &amp; &amp; \\<br>
&amp; -l_{k+1, k} &amp; &amp; \\<br>
&amp; \vdots     &amp; \ddots\\<br>
&amp; -l_{n, k}  &amp;  0 &amp; 1<br>
\end{bmatrix},<br>
\quad l_{ik} = \frac{a_{ik}^{(k)}}{a_{kk}^{(k)}}<br>
\<br>
$$<br>
回代：<br>
$$<br>
\begin{cases}<br>
y_i = b_i - \sum \limits_{k = 1}^{i-1} k_{ik}y_k, \quad i = 1, 2, \cdots, n \\<br>
x_i = y_i - \sum \limits^{n}_{k = i + 1}u_{ik}x_{k}/u_{ii}, \quad i = n, n-1, \cdots, 1<br>
\end{cases}<br>
$$</p>
<h3 id="直接法求解的特点">直接法求解的特点</h3>
<ol>
<li>经过可预先确定的有限次<strong>算术运算</strong> 求出精确解；</li>
<li>由于有舍入误差，只能得到近似解；</li>
<li>需要对解进行误差分析；</li>
<li>不适合用于求解病态方程组；</li>
<li>一般适合于解矩阵 $A$ 为低阶稠密矩阵的方程组。</li>
</ol>
<h3 id="判断矩阵是否为病态矩阵">判断矩阵是否为病态矩阵</h3>
<p>判断矩阵是否病态，常由经验得出：</p>
<ol>
<li>行列式很大或很小（如某些行、列近似相关）；</li>
<li>元素间相差大数量级，且无规则；</li>
<li>主元消去过程中出现小主元；</li>
<li>特征值相差大数量级。</li>
</ol>
<p>使用直接法求解病态矩阵的方程组可能使解严重偏离真实值。</p>
<h2 id="迭代法">迭代法</h2>
<p>将待求解方程组改写成其等价形式$\mathbf{x = Bx+g}$ ，以迭代序列的形式逼近方程的根。</p>
<p>$\mathbf{L}$：下三角矩阵；</p>
<p>$\mathbf{U}$：上三角矩阵；</p>
<p>$\mathbf{D}$：对角矩阵。</p>
<h3 id="雅可比迭代法-Jacobi-Iterative-Methods">雅可比迭代法(Jacobi Iterative Methods)</h3>
<p>$$<br>
\mathbf{x}^{(k+1)} = \mathbf{B}_J \mathbf{x}^{(k)} + \mathbf{g}_J \\<br>
\begin{cases}<br>
\mathbf{B}_J = -\mathbf{D}^{-1}(\mathbf{L+U}) \\<br>
\mathbf{g}_J = \mathbf{D}^{-1} \mathbf{b}<br>
\end{cases}<br>
$$</p>
<h3 id="高斯-塞尔德-Gauss-Seidel-Iterative-Methods">高斯-塞尔德(Gauss-Seidel Iterative Methods)</h3>
<p>$$<br>
\mathbf{x}^{(k+1)} = \mathbf{B}_S \mathbf{x}^{(k)} + \mathbf{g}_S\\<br>
\begin{cases}<br>
\mathbf{B}_S = -\mathbf{(D+L)}^{-1}\mathbf{U} \\<br>
\mathbf{g}_S = \mathbf{(D+L)}^{-1} \mathbf{b}<br>
\end{cases}<br>
$$</p>
<h3 id="迭代法的收敛性">迭代法的收敛性</h3>
<p>迭代法收敛的充要条件是谱半径小于1。<br>
$$<br>
\rho(\mathbf{B}) &lt; 1<br>
$$<br>
谱半径(spectral radius)：$\rho(\mathbf{B}) = \max\limits_{1\le i\le n}|\lambda_i|$，$\lambda\ _i$ 为$\mathbf{B}$的特征值。</p>
<h4 id="特殊的迭代矩阵">特殊的迭代矩阵</h4>
<ul>
<li>若$\mathbf{A}$ 为严格对对角占优矩阵，则方程组的Jacobi和 Gauss-Seidel 迭代均收敛。</li>
</ul>
<p>严格对角占优矩阵 (strictly diagonally dominant matrix)</p>
<p>$\mathbf{A}$的每一行对角线元素绝对值都严格大于同行其他元素绝对值之和：<br>
$$<br>
|a_{ii}|&gt;\sum\limits^n_{j = 1\\j\ne i}|a_{ij}| \quad (i =  1, 2, \cdots, n)<br>
$$</p>
<ul>
<li>若$\mathbf{A}$ 不可约，即不能通过出初等行变换变为上三角矩阵的形式，且按行弱对角占优，则方程组的 Jacobi 和 Gauss-Seidel迭代均收敛。</li>
</ul>
<p>弱对角占优；<br>
$$<br>
|a_{ii}|\ge\sum\limits^n_{j = 1\\j\ne i}|a_{ij}| \quad (i =  1, 2, \cdots , n)<br>
$$<br>
且至少有一个$i$使得大于号成立，则$\mathbf{A}$为弱对角占优矩阵。</p>
<ul>
<li>若$\mathbf{A}$ 为对称正定矩阵，则 Gauss-Seidel迭代收敛。</li>
</ul>
<h3 id="迭代法的特点">迭代法的特点</h3>
<ol>
<li>构造出合适的迭代格式可加快收敛速度；</li>
<li>不容易构造能收敛到解的迭代函数；</li>
</ol>
<h3 id="迭代法的优点">迭代法的优点</h3>
<ol>
<li>舍入误差影响小；</li>
<li>对于高阶方程组计算量小于直接法；</li>
<li>适合于求解系数矩阵问题</li>
</ol>
<h2 id="解线性方程组的误差分析">解线性方程组的误差分析</h2>
<h3 id="范数">范数</h3>
<h4 id="向量范数">向量范数</h4>
<p>注：将向量看作矩阵时，应视为$n\times1$的列向量。</p>
<p>$\mathbf{R}^n$ 空间的向量范数$||\cdot||$ 对任意$\mathbf{x, y} \in \mathbf{R}^n$ 满足：</p>
<ul>
<li>
<p>正定性(positive definite)： $||\mathbf{x}||\ge 0; \quad ||\mathbf{x}|| = 0 \Leftrightarrow \mathbf{x} = 0$</p>
</li>
<li>
<p>齐次性(homogeneous)：$||\alpha \mathbf{x}|| = |\alpha| \cdot ||\mathbf{x}||$</p>
</li>
<li>
<p>三角不等式(triangle inequality)：$||\mathbf{x +y}|| \le||\mathbf{x}|| + ||\mathbf{y}||$</p>
</li>
</ul>
<p>常用向量范数：</p>
<ul>
<li>$||x||_1 = \sum \limits_{i = 1}^n |x_i|$</li>
<li>$||x||_2 = \sqrt{\sum \limits_{i = 1}^n | x_i| ^2}$</li>
<li>$||x||_p = (\sum\limits_{i = 1}^n |x_i|^p)^{1/p}$</li>
<li>$||x||_{\infty} = \max\limits_{1\le i \le n}|x_i|$</li>
</ul>
<h4 id="矩阵范数">矩阵范数</h4>
<p>$\mathbf{R}^{m\times n}$ 空间的矩阵范数$||\cdot||$ 对任意 $\mathbf{A,B} \in \mathbf{R}^{m\times n}$ 满足：</p>
<ul>
<li>正定性：$||\mathbf{A}|| \ge 0; \quad ||\mathbf{A}|| = 0 \Leftrightarrow \mathbf{A} = 0$</li>
<li>齐次性：$||\alpha \mathbf{A}|| = |\alpha| \cdot ||\mathbf{A}||$</li>
<li>三角不等式：$||\mathbf{A+B} || \le || \mathbf{A}|| + || \mathbf{B}||$</li>
<li>相容(consistent)（当$m = n$ 时）：$||\mathbf{AB}||\le ||\mathbf{A}|| \cdot || \mathbf{B}||$</li>
</ul>
<p>常用矩阵范数：</p>
<ul>
<li>行和范数： $||\mathbf{A}||_{\infty} = \max \limits_{1\le i \le n} \sum \limits_{j=1}^n |a_{ij}$</li>
<li>列和范数：$||\mathbf{A}||_1  = \max \limits_{1\le j\le n} \sum \limits_{i = 1}^n |a_{ij}|$</li>
<li>谱范数(spectral norm)：$||\mathbf{A}||_2 = \sqrt{\rho(\mathbf{A^TA)}}$</li>
</ul>
<h3 id="条件数">条件数</h3>
<p>矩阵$\mathbf{A}$的条件数记为$cond(\mathbf{A})$，越大则矩阵越病态，越难得到准确解。<br>
$$<br>
cond(\mathbf{A}) = ||\mathbf{A}|| \cdot ||A^{-1}||<br>
$$<br>
性质：</p>
<ul>
<li>若$\mathbf{A}$ 对称，则$cond(\mathbf{A})_2 = \frac{max|\lambda|}{min|\lambda|}$</li>
<li>若$\mathbf{A}$ 可逆，则$cond(\mathbf{A})_p \ge 1$</li>
<li>若$\mathbf{A}$ 可逆， $\alpha \in R$， 则$cond(\alpha \mathbf{A}) = cond(\mathbf{A})$</li>
<li>若$\mathbf{A}$ 正交， 则$cond(\mathbf{A})_2 = 1$</li>
<li>若$\mathbf{A}$ 可逆， $\mathbf{R}$ 正交， 则 $cond(\mathbf{RA})_2 = cond(\mathbf{AR})_2 = cond(\mathbf{A})_2$</li>
</ul>
]]></content>
      <categories>
        <category>计算方法</category>
      </categories>
      <tags>
        <tag>Numerical methods</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL - 空字符串、空白字符串和 NULL</title>
    <url>/zh-CN/SQL-emptyStr-whitespace-null/</url>
    <content><![CDATA[<p>本文谈谈 SQL 中的空字符串，空白字符串和 <code>NULL</code>.</p>
<span id="more"></span>
<p>遇到这样一个需求，从数据库中获取中文名，无中文名时以英文名代替。而无中文名实际上可能有空白字符串，空字符串，还可能是 <em><code>NULL</code></em>, 在处理这些值的时候遇到了一些有趣的结果。</p>
<p>为了解释以下查询语句的结果，假设我们有一个表：</p>
<table>
<thead>
<tr>
<th>c_name</th>
<th>name</th>
</tr>
</thead>
<tbody>
<tr>
<td>NULL</td>
<td>name with c_name null</td>
</tr>
<tr>
<td></td>
<td>name with c_name empty</td>
</tr>
</tbody>
</table>
<p>你可以在 <a href="https://dbfiddle.uk/?rdbms=sqlserver_2017&amp;fiddle=69a1c3d70c1f92155552d3e2be4c94bd">db&lt;&gt;fiddle</a> 中测试本文提到的 SQL 语句。</p>
<p>原始 SQL 语句为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">case</span> c_name <span class="keyword">when</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">then</span> name <span class="keyword">else</span> c_name <span class="keyword">end</span> <span class="keyword">as</span> name <span class="keyword">from</span> employee</span><br></pre></td></tr></table></figure>
<h1>空白字符串与空字符串</h1>
<p>我首先考虑的是直接与空字符串比较是否会在 <code>c_name</code> 为多个空白字符的时候因被判不等而返回空白字符串，C# 中字符串的判空方法就有 <a href="https://docs.microsoft.com/en-us/dotnet/api/system.string.isnullorempty?view=net-6.0"><code>String.IsNullOrEmpty(String)</code></a> 与 <a href="https://docs.microsoft.com/en-us/dotnet/api/system.string.isnullorwhitespace?view=net-6.0"><code>String.IsNullOrWhiteSpace(String)</code></a> 的区别，因此将查询语句改成了以下版本。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- SQL Server 2017 (14.x) and later</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">case</span> <span class="built_in">trim</span>(c_name) <span class="keyword">when</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">then</span> name <span class="keyword">else</span> c_name <span class="keyword">end</span> <span class="keyword">as</span> name <span class="keyword">from</span> employee</span><br><span class="line"><span class="comment">-- SQL Server 2017 (14.x) before</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">case</span> ltrim(rtrim(c_name)) <span class="keyword">when</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">then</span> name <span class="keyword">else</span> c_name <span class="keyword">end</span> <span class="keyword">as</span> name <span class="keyword">from</span> employee</span><br></pre></td></tr></table></figure>
<p>根据 <a href="https://docs.microsoft.com/en-us/sql/t-sql/functions/trim-transact-sql?view=sql-server-ver15">MS Docs</a> , <code>TRIM</code> 与 <code>LTRIM(RTRIM(@string))</code> 的行为一致，但 <code>TRIM</code> 是 SQL Server 2017(14.x) 才引进的。</p>
<p>但我当我使用上面的脚本和之前的脚本去测试一个包含多个空白字符的 <code>c_name</code> 时，发现它们都能得到正确的结果 <code>name</code> ，而不会返回空白字符串 <code>c_name</code> 。实验结果证明空白字符串无论含有多少个空白字符，实际上在 SQL Server 中都是相等的。</p>
<p>几经搜索后发现这是 <a href="https://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt">SQL - 92</a> 中规定的标准。标准的第208页写道：</p>
<blockquote>
<p>If the length in characters of X is not equal to the length in characters of Y, then the shorter string is effectively replaced, for the purposes of comparison, with a copy of itself that has been extended to the length of the longer string by concatenation on the right of one or more pad characters, where the pad character is chosen based on CS. If CS has the NO PAD attribute, then the pad character is an    implementation-dependent character different from any character in the character set of X and Y that collates less than any string under CS. Otherwise, the pad character is a <space>.</p>
</blockquote>
<p>也就是说当一个空字符串与一个有多个空白字符的空白字符串进行比较时，空字符串会以添加空格的形式被扩展，从而最后两者的值被判定为相等。</p>
<p>所以我们实际上仍然可以使用原来的查询语句。</p>
<h1>NULL</h1>
<p>前面提到，除了空白字符串，空字符串，实际上我们还有可能遇到 <code>NULL</code> 作为 <code>c_name</code> 的取值，这时候上面的查询语句是否还能正常工作呢？</p>
<p>很不幸，在以 <code>NULL</code> 作为 <code>c_name</code> 的测试中，<code>NULL</code> 依然被作为了一个合法的中文名被返回。</p>
<p>先来看看上面语句的另一种写法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">case</span> <span class="keyword">when</span> c_name <span class="operator">!=</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">then</span> c_name <span class="keyword">else</span> name <span class="keyword">end</span> <span class="keyword">as</span> name <span class="keyword">from</span> employee</span><br></pre></td></tr></table></figure>
<p>这条查询语句与上面原始的查询语句是否一样呢？从语义上来看似乎是一样的，只不过是把 <code>case when</code> 条件换了个顺序。但是令人惊讶的是，换做这种写法时，我们得到了正确的结果，它不再会返回 <code>NULL</code> 。</p>
<p>这是怎么回事呢？按照我们上面的测试，<code>c_name</code> 为 <code>NULL</code> 时与空字符串不等，所以仍然返回了 <code>c_name</code> , 但在这里，按照这样的理解，它似乎应该还是返回 <code>c_name</code> 。我一度以为是 <code>case when</code> 的用法有什么奇妙之处导致了这个问题，但似乎没有找到类似的问题，于是在 Stack Overflow 上<a href="https://stackoverflow.com/questions/71120524/handle-null-and-empty-in-sql-server">发问</a>，才发现原来并不是 <code>case when</code> 的问题，而是 <code>NULL</code> 的问题。网友指出：</p>
<blockquote>
<p>Remember: <strong>null does not mean “empty”</strong>. Instead, it means “I don’t know”.</p>
</blockquote>
<p>LeetCode 中有道类似 SQL 的<a href="https://leetcode-cn.com/problems/find-customer-referee/">题目</a>，第一反应肯定是 <code>referee_id != 2</code> 这样最直观的想法，但是你会发现如果直接使用这个 <code>where</code> 条件，在 <code>NULL</code> 确实与2不相等的情况下却不会被返回，这是怎么回事呢？</p>
<p>来看看 <a href="https://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt">SQL - 92</a> 关于等于操作符有怎样的规定：</p>
<blockquote>
<p>General Rules</p>
<ol>
<li>
<p>Let X and Y be any two corresponding <code>&lt;row value constructor element&gt;</code>s. Let XV and YV be the values represented by X and Y, respectively.</p>
<p>Case:</p>
<p>a) If XV or YV is the null value, then “X <code>&lt;comp op&gt;</code> Y” is unknown.</p>
</li>
</ol>
</blockquote>
<p>在这里我们可以看到，如果被比较的两个值至少有一个为 <code>NULL</code> , 比较的结果实际上并非我们想象中的 <code>True | False</code> , 而是 <code>Unkown</code> ，所以我们的 <code>WHERE</code> 语句对于值为 <code>NULL</code> 的记录得到的并不是一个 <code>True</code> 的结果。</p>
<p>在前面的查询语句中，我们的相等条件不满足，返回了 <code>c_name</code> , 在这一条查询语句中，我们的不等条件实际上得到了一个<code>Unkown</code> 也不满足 <code>True</code> ，所以它不会返回第一个表达式 <code>c_name</code> ，误打误撞返回了正确的 <code>name</code> 。</p>
<p>这里涉及到了一个三元问题，我们发现一个原本应该得到的二元布尔值集合变成了一个三元集合。在我们所接触过的其他语言中，布尔值明确地就是 <code>True | False</code> ，而在 SQL 中，这个概念相当于是被扩充了，在逻辑运算的计算法则上也有很大的不同，这里不再展开。</p>
<h1>ISNULL|NULLIF</h1>
<p>回到上面的最初查询名字的问题，网友给出了一种方案：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> isnull(<span class="built_in">nullif</span>(c_name, <span class="string">&#x27;&#x27;</span>), name) <span class="keyword">as</span> name <span class="keyword">from</span> employee</span><br></pre></td></tr></table></figure>
<p>我尝试使用该查询语句，它确实可以返回不为空和 <code>NULL</code> 的结果，但是结果被截断了。实际上当我的 <code>c_name</code> 定义长度小于 <code>name</code> 的定义长度时，就有可能返回一个截断的结果。</p>
<p>先来看看这两个表达式，首先是 <code>NULLIF</code> :</p>
<blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NULLIF</span> ( expression , expression )  </span><br></pre></td></tr></table></figure>
<p>NULLIF returns the first <em>expression</em> if the two expressions are not equal. If the expressions are equal, NULLIF returns a null value of the type of the first <em>expression</em>.</p>
</blockquote>
<p>两个表达式不等时返回第一个表达式，两个表达式相等时，返回 <code>NULL</code> 。</p>
<p>根据 <a href="https://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt">SQL - 92</a> ，实际上 <code>NULLIF</code> 相当于 <code>CASE ... WHEN</code> ：</p>
<blockquote>
<p>NULLIF (V1, V2) is equivalent to the following <code>&lt;case specification&gt;</code>:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CASE</span> <span class="keyword">WHEN</span> V1<span class="operator">=</span>V2 <span class="keyword">THEN</span> <span class="keyword">NULL</span> <span class="keyword">ELSE</span> V1 <span class="keyword">END</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>当我们的 <code>c_name</code> 为空字符串或空白字符串时， 两个表达式根据前面的解释应该相等，即返回 <code>NULL</code> ，当 <code>c_name</code> 为 <code>NULL</code> 时，由于 <code>NULL</code> 不等于空白字符串，返回自身，即这里将空白字符串，空字符串，<code>NULL</code> 都返回为了 <code>NULL</code> ，注意这里的返回类型与 <code>c_name</code> 一致。</p>
<p>再来看看 <code>IFNULL</code> :</p>
<blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">ISNULL ( check_expression , replacement_value )  </span><br></pre></td></tr></table></figure>
<p>Returns the same type as <em>check_expression</em>. If a literal NULL is provided as <em>check_expression</em>, returns the datatype of the <em>replacement_value</em>. If a literal NULL is provided as <em>check_expression</em> and no <em>replacement_value</em> is provided, returns an <strong>int</strong>.</p>
</blockquote>
<p>现在我们已经知道 <code>check_expression</code> 是一个 <code>NULL</code> ，只需要 <code>replacement_value</code> 用我们需要的 <code>name</code> 代替似乎就大功告成了。但事实上我们丢失了部分字符，例如我如果定义 <code>c_name</code> 为 <code>char(4)</code>，返回结果将变为只保留了前4个字符而非我们完整的 <code>name</code> 字符串。这又是怎么回事呢？</p>
<blockquote>
<p>The value of <em>check_expression</em> is returned if it is not NULL; otherwise, <em>replacement_value</em> is returned after it is implicitly converted to the type of <em>check_expression</em>, if the types are different. <em>replacement_value</em> can be truncated if <em>replacement_value</em> is longer than <em>check_expression</em>.</p>
</blockquote>
<p>官方定义文档中提到了这点，如果 <code>check_expression</code> 与 <code>replacement_value</code> 的类型定义不一致，且 <code>replacement_value</code> 长度大于 <code>check_expression</code> ，这时返回值会被截断。值得注意的是，<a href="https://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt">SQL - 92</a> 中对 <code>ISNULL</code> 是没有定义的。</p>
<h1>COALESCE</h1>
<p>在搜索 <code>ISNULL</code> 的截断相关资料时，又看到了类似的 <code>COALESCE</code> 的讨论。</p>
<p>于是我们上面使用 <code>ISNULL</code> 得到截断结果的查询语句又可以改写成：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">coalesce</span>(<span class="built_in">nullif</span>(c_name, <span class="string">&#x27;&#x27;</span>), name) <span class="keyword">from</span> employee</span><br></pre></td></tr></table></figure>
<p>这一次我们发现我们不再会得到截断的结果，它和我们上面使用 <code>CASE</code> 误打误撞得到的正确结果一致。</p>
<p>实际上根据 <a href="https://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt">SQL - 92</a> 的定义，<code>COALESCE</code> 可以改写成 <code>CASE</code> ：</p>
<blockquote>
<p>COALESCE (V1, V2) is equivalent to the following <case specification>:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CASE</span> <span class="keyword">WHEN</span> V1 <span class="keyword">IS</span> <span class="keyword">NOT NULL</span> <span class="keyword">THEN</span> V1 <span class="keyword">ELSE</span> V2 <span class="keyword">END</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>这时候理解 <code>COALESCE</code> 就非常直观了，我们先用 <code>NULLIF</code> 将不相等的空白字符串与 <code>NULL</code> 都转成一样的 <code>NULL</code> ，再使用 <code>COALESCE</code> 代替前面有截断缺陷的 <code>ISNULL</code>，它实际上是与 <code>ISNULL</code> 的语义一致。</p>
<h1>Stored Procedure 与NULL</h1>
<p>上面的问题我们已经得到了合适的方案，这里顺便一提正好有点相关的 <code>NULL</code> 在 Stroed Procedure 中的使用。</p>
<p>常常会遇到这样的需求，某个查询页面，用户需要根据不同的条件查询不同的信息，往往这个不同的信息还需要“全部”这个选项。我们知道，如果是一个单一的查询条件，传递起来是比较方便的，我们直接获取用户通过控件选择的输入值作为 <code>WHERE</code> 语句的判断条件即可得到正确结果。但是对于全部呢？这时候如果这个选项非常多，将其串联再传递给 Stored Procedure 就显得非常没有必要了，因为这时候我们实际上不需要对这些记录进行过滤。</p>
<p>通常我们可能会使用 <code>IF ... ELSE ... </code> 去判断参数值然后走不同的 <code>SELECT</code> 语句，但是如果可供用户选择的条件非常多，这样又显得有些繁琐了。还有一种办法是通过 <code>IF ... ELSE ...</code> 判断后生成 <code>WHERE</code> 条件，然后生成我们需要的查询语句。那么有没有什么办法，让我们直接去判断这个参数呢？通过我们上面提到的 <code>COALESCE</code> 就可以做到：</p>
<blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WHERE</span> COL <span class="operator">=</span> <span class="built_in">COALESCE</span>(<span class="variable">@INPUT</span>, COL)</span><br></pre></td></tr></table></figure>
</blockquote>
<p>这时候当后台调用传入 <code>@INTPUT = NULL</code> 时，就相当于忽视了这个 <code>WHERE</code> 条件，而当我们传入一个不为 <code>NULL</code> 的筛选值时，这个 <code>@INPUT</code> 筛选值就会作用于这个 <code>WHERE</code> 语句，这时候我们就很容易处理后台的用户输入值，也很容易用单一 Stored Procedure 去完成这个查询任务了。</p>
<h1>参考资料</h1>
<ol>
<li><a href="https://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt">Information Technology - Database Language SQL (Proposed revised text of DIS 9075) - July 1992 (TXT)</a></li>
<li><a href="https://www.red-gate.com/simple-talk/databases/sql-server/learn/sql-and-the-snare-of-three-valued-logic/">SQL and the Snare of Three-Valued Logic - Simple Talk</a></li>
<li><a href="https://dba.stackexchange.com/questions/9456/empty-strings-why-or-when-is-equal-to">sql server 2008 - Empty Strings: Why or when is “equal to”? - Database Administrators Stack Exchange</a></li>
<li><a href="https://en.wikipedia.org/wiki/Null_(SQL)">Null (SQL) - Wikipedia</a></li>
<li><a href="https://www.mssqltips.com/sqlservertip/2689/deciding-between-coalesce-and-isnull-in-sql-server/">Deciding between COALESCE and ISNULL in SQL Server</a></li>
<li><a href="https://stackoverflow.com/questions/1399844/sql-server-2008-empty-string-vs-space">SQL Server 2008 Empty String vs. Space - Stack Overflow</a></li>
<li><a href="https://stackoverflow.com/questions/5465235/in-sql-server-why-is-it-that-null-does-not-equal-empty-string-and-doesnt-not-e">In SQL Server, why is it that NULL does not equal empty string AND doesn’t not equal empty string? - Stack Overflow</a></li>
<li><a href="https://stackoverflow.com/questions/2578194/what-are-ddl-and-dml">sql - What are DDL and DML? - Stack Overflow</a></li>
<li><a href="https://stackoverflow.com/questions/25752879/isnull-returning-truncated-string/25752908#25752908">sql server - ISNULL returning truncated string - Stack Overflow</a></li>
<li><a href="https://stackoverflow.com/questions/18885256/why-is-t-sql-isnull-truncating-the-string-and-coalesce-is-not">sql server - Why is T-SQL ISNULL() truncating the string and COALESCE is not? - Stack Overflow</a></li>
<li><a href="https://stackoverflow.com/questions/7408893/using-isnull-vs-using-coalesce-for-checking-a-specific-condition">sql - Using ISNULL vs using COALESCE for checking a specific condition? - Stack Overflow</a></li>
<li><a href="https://stackoverflow.com/questions/18828641/sql-difference-between-coalesce-and-isnull">sql server - SQL - Difference between COALESCE and ISNULL? - Stack Overflow</a></li>
<li><a href="https://stackoverflow.com/questions/13174399/coalesce-vs-case">sql - Coalesce vs Case - Stack Overflow</a></li>
<li><a href="https://stackoverflow.com/questions/10185638/optional-arguments-in-where-clause">sql - Optional Arguments in WHERE Clause - Stack Overflow</a></li>
<li><a href="https://stackoverflow.com/questions/697671/stored-procedure-with-optional-where-parameters">sql - Stored Procedure with optional “WHERE” parameters - Stack Overflow</a></li>
<li><a href="https://stackoverflow.com/questions/21919161/sql-server-stored-procedure-nullable-parameter">SQL Server stored procedure Nullable parameter - Stack Overflow</a></li>
<li><a href="https://docs.oracle.com/cd/B14117_01/server.101/b10759/statements_1001.htm">Types of SQL Statements</a></li>
<li><a href="https://support.microsoft.com/en-us/topic/inf-how-sql-server-compares-strings-with-trailing-spaces-b62b1a2d-27d3-4260-216d-a605719003b0">INF: How SQL Server Compares Strings with Trailing Spaces</a></li>
<li><a href="https://www.ibm.com/docs/en/i/7.4?topic=concepts-collating-sequence">Collating sequence - IBM Documentation</a></li>
<li><a href="https://docs.microsoft.com/en-us/sql/t-sql/functions/isnull-transact-sql?view=sql-server-ver15">ISNULL (Transact-SQL) - SQL Server | Microsoft Docs</a></li>
<li><a href="https://docs.microsoft.com/en-us/sql/t-sql/language-elements/nullif-transact-sql?view=sql-server-ver15">NULLIF (Transact-SQL) - SQL Server | Microsoft Docs</a></li>
<li><a href="https://docs.microsoft.com/en-us/sql/t-sql/language-elements/coalesce-transact-sql?redirectedfrom=MSDN&amp;view=sql-server-ver15">COALESCE (Transact-SQL) - SQL Server | Microsoft Docs</a></li>
<li><a href="https://docs.microsoft.com/en-us/sql/t-sql/language-elements/null-and-unknown-transact-sql?view=sql-server-ver15">NULL and UNKNOWN (Transact-SQL) - SQL Server | Microsoft Docs</a></li>
<li><a href="https://docs.microsoft.com/en-us/sql/t-sql/statements/set-ansi-nulls-transact-sql?view=sql-server-ver15">SET ANSI_NULLS (Transact-SQL) - SQL Server | Microsoft Docs</a></li>
<li><a href="https://docs.microsoft.com/en-us/sql/t-sql/language-elements/case-transact-sql?view=sql-server-ver15">CASE (Transact - SQL) - SQL Server | Microsoft Docs</a></li>
<li><a href="https://docs.microsoft.com/en-us/sql/t-sql/language-elements/equals-transact-sql?view=sql-server-ver15">=(Equals) (Transact - SQL) - SQL Server | Microsoft Docs</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/system.string.isnullorempty?view=net-6.0">String.IsNullOrEmpty(String) Method (System) | Microsoft Docs</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/api/system.string.isnullorwhitespace?view=net-6.0">String.IsNullOrWhiteSpace(String) Method (System) | Microsoft Docs</a></li>
<li><a href="https://docs.microsoft.com/en-us/sql/t-sql/functions/trim-transact-sql?view=sql-server-ver15">TRIM (Transact-SQL) - SQL Server | Microsoft Docs</a></li>
</ol>
]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>STM8-认识GPIO及输入输出模式</title>
    <url>/zh-CN/STM8-GPIO-input-output/</url>
    <content><![CDATA[<p>本文对STM8单片机进行简要介绍，并对GPIO输入输出模式进行介绍，对GPIO的相关寄存器配置进行介绍。</p>
<span id="more"></span>
<p>本STM8系列实验基于STM8S105C6芯片。相关参考手册可以访问<a href="http://www.st.com/content/st_com/en/products/microcontrollers/stm8-8-bit-mcus/stm8s-series/stm8s103-105/stm8s105c6.html">ST官网</a>获取。</p>
<h1>GPIO简介</h1>
<p>GPIO(General purpose input/output ports)，即通用输入/输出口，用于芯片与外部的数据传输。一个I/O端口包含8个引脚，每个引脚可以被独立配置为数字输入或数字输出，部分引脚有模拟输入，外部中断等功能。打个也许不太恰当的比方，当我们的手接近火焰时会有缩手反射的现象，这个过程需要神经中枢的参与，手就像是外设，而单片机就像是神经中枢，手对于外界火焰的感知就好比输入，而神经中枢对输入的处理就好比单片机的软件处理，神经中枢所产生的神经冲动而导致缩手反射就好比输出。一个强大的系统离不开输入输出和中枢系统的协调配合。GPIO的配置是单片机编程中最基本，最常用的配置。LQFP48(7×7)封装的STM8S105C6可用I/O端口共38个(参考STM8/STM32选型手册)。不同型号的STM8芯片的可用I/O端口数量不一样，更多的I/O端口可以连接更多的外设，但也不要盲目求多，适用即可，比所用的预留一些即可，过多也是资源的浪费。</p>
<h1>输入模式</h1>
<p>STM8S系列芯片的GPIO输入模式有四种：</p>
<ul>
<li>悬浮不带中断输入</li>
<li>悬浮中断输入</li>
<li>上拉不带中断输入</li>
<li>上拉中断输入</li>
</ul>
<p>这里中断我们暂且不提，将输入方式分为悬浮输入和上拉输入。区分方式是从GPIO的内部结构来划分。</p>
<h2 id="悬浮输入">悬浮输入</h2>
<p>悬浮输入，也叫浮空输入，顾名思义，即引脚悬空。这种方式的输入阻抗很高。当悬浮输入的引脚上加上信号时，单片机所得到的信号并不确定是高电平或是低电平，是一个不确定的信号。因而常用于模拟信号转换为数字信号的信号输入方式，例如ADC。</p>
<h2 id="上拉输入">上拉输入</h2>
<p>上拉输入也很好理解，即在引脚处接一个上拉电阻到内部电源。这种方式的优点是可以增强驱动能力，增强抗干扰性，同时上拉电阻也起到了一个限流的作用。根据ST官方提供的STM8S105XX系列数据手册，内部电源$ V_DD $ 通常为5.0V，在此条件下，上拉电阻的取值最小为30kΩ，最大为80kΩ，典型值为55kΩ（不知道为什么中文版的数据手册典型值为45kΩ）。可以计算得出此时电流的大小是μA级别，这是因为我们的上拉电阻取值很大，所以限流作用就相对较小，这也被称之为弱上拉输入模式，即Weak Pull-up(WPU)。</p>
<h1>输出模式</h1>
<p>STM8S系列输出模式有两种：</p>
<ul>
<li>推挽输出</li>
<li>开漏输出</li>
</ul>
<h2 id="推挽输出">推挽输出</h2>
<p>推挽输出(Push-pull output)，也称为互补输出，推拉式输出。推挽输出模式导通损耗小，效率高。在此模式下，N-MOS、P-MOS两个MOS均被接入电路，通过输出控制寄存器控制两个MOS管的导通或关闭。正常工作状态下，仅有一个MOS管导通，另一个MOS管截止，从而可以自如地控制高低数字信号的输出。</p>
<h2 id="开漏输出">开漏输出</h2>
<p>开漏输出(Open drain output)，有时简称为OD输出。相比推挽输出，GPIO结构中的P-MOS管没有被接入，无法输出高电平状态，需要外接上拉电阻。在没有外接上拉电阻，引脚悬空的状态下，端口引脚状态将不确定。上拉电阻阻值的大小会引起输出信号上升沿时间的变化，上拉电阻越小，上升沿时间越短，速度越快。开漏输出模式吸收电流能力强（一般在20mA以内），适用于电流型驱动。用作电流型驱动时，驱动电流由外部电源经上拉电阻给引脚连接的电路或器件，单片机内部几乎不需要提供驱动电流，减少了单片机自身功耗。利用开漏输出模式通过上拉电阻外接不同的电源还可以实现电平信号标准的转换。将多个开漏模式引脚连在一起，可以构成线与结构。</p>
<p>需要注意的是，有部分引脚具有“真正的”开漏输出功能。所谓“真正的”开漏输出指的是除了无P-MOS以外，也没有连接电源的保护二极管，即不存在任何电路连接到内部电源。在此模式下，必须加上拉电阻。</p>
<h1>补充：保护二极管</h1>
<p>GPIO引脚内部通常还会有一对反向连接电源地的保护二极管。以防止外部管脚输入电压过高或过低损坏引脚电路。通常为锗二极管，肖特基势垒二极管。</p>
<h1>输入输出寄存器配置</h1>
<p>简单地了解了输入输出模式，接下来我们将介绍如何配置相应的输入输出模式。查阅对应芯片系列的Reference manual（建议看原版，或者中英对照），查阅GPIO章节，与之相关的几个寄存器分别是<code>Px_DDR</code>,<code>Px_IDR</code>,<code>Px_ODR</code>,<code>Px_CR1</code>,<code>Px_CR2</code>，手册中详细地描述了每个寄存器的配置过程及功能。</p>
<ul>
<li>输出数据寄存器        ODR</li>
<li>数据方向寄存器               DDR</li>
<li>控制寄存器                      CR1</li>
<li>控制寄存器                      CR2</li>
<li>输入寄存器                       IDR</li>
</ul>
<p>如果我们需要IO输出一个低电平，需要如何操作呢？</p>
<ul>
<li>将DDR置1选择输出模式</li>
<li>配置CR1,CR2选择输出模式
<ul>
<li>CR1：选择开漏输出或是推挽输出（有些翻译为上拉输出）</li>
<li>CR2：配置输出速率</li>
</ul>
</li>
<li>写ODR寄存器，STM8将通过锁存器输出对应的数值到I/O</li>
</ul>
]]></content>
      <categories>
        <category>STM8</category>
      </categories>
      <tags>
        <tag>STM8</tag>
      </tags>
  </entry>
  <entry>
    <title>翻译-高效的字符串匹配：辅助参考书目检索</title>
    <url>/zh-CN/Translate-efficient-string-matching-an-aid-to-bibliographic-search/</url>
    <content><![CDATA[<p>原文地址：<a href="https://dl.acm.org/doi/epdf/10.1145/360825.360855">Efficient String Matching - An Aid to Bibliographic Search</a></p>
<p>作者 Alfred V. Aho，Margaret J. Corasick 贝尔实验室</p>
<p>本文为个人毕业设计外文参考文献翻译部分，有不当之处欢迎指正。</p>
<p>文章主要论述了 AC 自动算法的原理，函数构建，性能。（伪代码部分由于未能找到在代码块中插入数学符号的方式，故采用图片方式，若有相关方法，期待评论告知。）</p>
<span id="more"></span>
<p>本文描述了一种简单高效的算法，用于在文本字符串中找出任一有限字符数的关键词所有出现位置。这种算法通过关键词构建一个有限状态模式匹配机，然后通过这个模式匹配机在一趟遍历中处理单词输入的文本字符串。构建此模式匹配机的时间与关键字的长度之和成正比。通过模式状态匹配机处理文本字符串的状态转换次数与关键字的长度无关。这个算法已经将图书馆的参考书目搜索程序运行速度提升了 5 到 10 倍。</p>
<p><strong>关键词</strong>：关键字和短语，字符串模式匹配，参考书目检索，信息检索，文本编辑，有限状态机，计算复杂度</p>
<p>CR类别：3.74,3.71,5.22,5.25</p>
<h1>简介</h1>
<p>在许多信息检索和文字编辑的应用程序中，能够在文本中快速定位用户指定的词或短语某些或者所有出现的位置是非常重要的。本文介绍了一种简单高效的算法，用于在任意的文本字符串中找出任一有限字符数的关键词或短语所有出现位置。</p>
<p>熟知有限自动机的人应该熟悉这种方法。这个算法由两部分组成。在第一部分中我们从关键词字符集中构造有限状态模式匹配机；在第二部分中我们将字符串作为模式匹配机的输入。只要这个机器已发现一个匹配的关键词，它就会发出信号。</p>
<p>在模式匹配程序中使用有限状态机并不新奇 [4,8,17]，但程序员们似乎常常回避使用它们。部分程序员不愿意这样做的部分原因可能是因为从正则表达式 [3,10,15] 构建有限自动机的常规算法的复杂性，尤其是在需要最优解的情况下 [2,14] 。本文表明，从受限的正则表达式，也即由有限集合组成的关键词，可以快速而简单地构建一个高效的有限状态模式匹配机。我们的方法将有限状态机与 KMP 算法 [13] 相结合。</p>
<p>也许本文最有趣的地方在于有限状态算法提供了比常规方法更多的改进。我们在一个图书馆的参考书目查询程序中使用有限状态模式匹配算法。这个程序的目的是，让书目编者在引文索引中找到所有满足布尔匹配的关键词和短语的标题。这个查询程序开始是使用一种直接的字符串匹配算法。在该程序中使用有限状态算法来替代这个算法后，在典型输入上，运行时间为原程序的五到十分之一。</p>
<h1>模式匹配机</h1>
<p>本节描述了一种在文本字符串中定位关键词的有限状态字符串模式匹配机。下一节将描述从一个给定的有限关键字集合中构建类似机器的算法。</p>
<p>在本文中，字符串只是简单地表示为一个有限符号序列。设 $K={y_1,y_2,\dots,y_k}$ 是一个有限字符串集合，我们称之为关键字，设 $x$ 为任意字符串，我们称之为文本字符串。我们的问题是找出有限的所有x的子字符串中在K集合中的关键词。子字符串可能彼此重叠。</p>
<p>用于K的模式匹配机是一个程序，它将文本字符串 $x$ 作为输入，关键字 $K$ 在 $x$ 的子字符串中的出现的位置作为输出。这种模式匹配机由一个状态集组成。每种状态都用一个数字表示。这种机器通过连续读取 $x$ 中的字符来处理文本字符串 $x$ ，产生状态转换，或是状态输出。这种状态机的行为由三个函数决定：一个跳转函数 $g$ ，一个失败处理函数 $f$ ，以及一个输出函数 $output$ 。</p>
<p>图1展示了函数在模式匹配状态机针对关键字集 {he, she, his, hers} 时的使用情况。</p>
<p><img src="https://d3i71xaburhd42.cloudfront.net/3547ac839d02f6efe3f6f76a8289738a22528442/2-Figure1-1.png" alt="图1 模式匹配机"></p>
<p>一种状态（通常是 0 状态）被指定 $start$ 状态。在图1中状态表示为 0,1,···,9。跳转函数 $g$ 将一种状态和一个输入字符组成一对映射为一种状态或 $fail$ 信息。图1(a) 的有向图表示跳转函数。例如，从 0 到 1 标有 h 的边表示 $g(0,h) = 1$ 。没有箭头表示$fail$。因此，对于所有不是 e 或者 i 的输入字符 $\delta$ ， $g(1,\delta)=fail$ 。我们的模式匹配机具有对所有的输入字符 $\delta$ ， $g(0,\delta)\ne fail$ 的特性。我们将看到跳转函数在 0 状态的这个特性确保在每一个机器周期机器都将处理一个输入字符。</p>
<p>失败处理函数f将一个状态映射到另一个状态。当跳转函数返回 $fail$ 时失败函数将被调用。当一组关键字被找到时，某些状态将被指定为输出状态。输出函数将一组关键字（可能为空）与每个状态组合将此形式化。</p>
<p>模式匹配机的一个操作周期定义如下：设 $s$ 表示机器的当前状态， $a$ 表示输入字符串 $x$ 中的当前字符。</p>
<ol>
<li>
<p>如果 $g(s, a) = s’$，状态机执行跳转转换，进入状态 $s’$ ，并将 $x$ 的下一个字符作为当前输入字符。此外，如果 $output(s’)$ 不为空，则机器输出 $output(s’)$ 集合和当前输入字符的位置。这个操作周期现在已完成。</p>
</li>
<li>
<p>如果 $g(s,a) = fail$ ，状态机调用失败函数 $f$ ，也就是执行了失败转换。如果 $f(s) = s’$ ，状态机重复以 $s’$ 作为当前状态，以 $a$ 作为当前输入字符的循环。</p>
</li>
</ol>
<p>最初，状态机的当前状态为开始状态，文本字符串的第一个字符作为当前输入字符。状态机随后通过对每一个文本字符串的字符执行一个操作周期来处理文本字符串。</p>
<p>例如，考虑状态机 $M$ 使用图1 中的函数处理文本字符串 “ushers” 的行为。图2表明了 $M$ 处理文本字符串的状态转换关系。</p>
<p><img src="https://i.loli.net/2020/06/10/QgEY7y2BbcUd9pm.png" alt="状态转化队列"><br>
考虑这样一个操作周期， $M$ 处在状态 4，当前输入字符为 e 。因为 $g(4,e) = 5$ ，状态机进入状态 5，前移到下一个输入字符，并输出 $output(5)$ ，表明状态机已经发现了在文本字符串的倒数4个位置是关键词 “she” 和 “he” 。</p>
<p>在状态 5输入字符 r，状态机在它的操作周期中执行两次状态转换。因为 $g(5,r) = fail$ ， $M$ 进入状态 $2 = f(5)$ 。然后因为$g(2,r) = 8$，$M$ 进入状态 8，接着前移一个输入字符。在这个操作周期中没有产生输出。</p>
<p>以下算法总结了模式匹配机的行为。</p>
<p><strong>算法1</strong> 模式匹配机</p>
<p><strong>输入</strong> 一个文本字符串 $x = a_1a_2 \dots a_n$ ,每一个 $a_i$  作为一个输入字符，模式匹配机 $M$ 包含跳转函数 $g$，失败函数 $f$，以及输出函数 $output$，如上所述</p>
<p><strong>输出</strong> 关键词在$x$中的位置</p>
<p><strong>方法</strong></p>
<p><img src="https://i.loli.net/2020/06/12/LkejgAN8c6WV7il.png" alt="image.png"></p>
<p>每一趟<strong>for</strong>循环都代表状态机的一个操作周期。</p>
<p>算法1是在 KMP 算法的基础上模式化得到的，KMP 算法用于在一个文本字符串中查找一个关键字 [13]，也可以看作是 [11] 中讨论的 “trie” 搜索方法的扩展。Hopcroft和Karp（当时未发表）提出一种类似于算法1的模式，用于在文本字符串中查找任一有限关键字集合第一次出现的位置 [13]。本文的第6节探讨了一种算法1的有限自动机版本，它避免了所有的失败转换。</p>
<h1>构造跳转，失败，输出函数</h1>
<p>我们说，当 $g,f,output$ 三个函数应用于一组关键字，算法1表现为，关键字 $y$ 在文本字符串 $x$ 的第 $i$ 个位置中止，当且仅当 $x= uyv$ 并且$uy$的长度为 $i$。</p>
<p>现在我们应该展示如何从一个关键字集构建有效的跳转，失败和输出函数。构建分为两部分。第一部分我们定义状态和跳转函数。第二部分我们计算失败函数。输出函数的计算则在第一部分开始构建，在第二部分完成。</p>
<p>为了构建跳转函数，我们应该构建一个跳转图。我们从一个表示状态 0 的顶点开始这幅图。然后我们通过往图中添加一条从开始状态引出的有向路径将关键字 $y$ 添加到图中。这样就会有新的顶点和边被添加到图中，从开始状态开始，一条路径拼出关键字 $y$。当一个状态终结了这条路径，关键字 $y$ 将被添加到输出函数中。我们仅在必要时才往图中添加新的边。</p>
<p>例如，设 {he,she,his,hers} 是关键字集。将第一个关键字添加到图中，我们得到：</p>
<p><img src="https://i.loli.net/2020/06/10/6SZBLcHPk1j2gIK.png" alt="image.png"></p>
<p>从0到2的路径拼出了关键字 “he”;我们将输出 “he” 关联到状态2.添加第二个关键字 “she”，我们得到图：</p>
<p><img src="https://i.loli.net/2020/06/10/uDa9p7P5fiWXjQJ.png" alt="image.png"></p>
<p>输出 “she” 被关联到状态 5。添加关键字 “his”，我们得到下面的图。注意到，当我们添加关键字 “his” 时，已经有从状态 0 到状态 1 标号为 “h” 的边，所以我们不需要添加另一条从状态 0 到状态 1 标号为 “h” 的边。输出 “his” 被关联到状态 7。</p>
<p><img src="https://i.loli.net/2020/06/10/TZxzdrIf1895PQH.png" alt="image.png"></p>
<p>添加最后一个关键字 “hers”，我们得到：</p>
<p><img src="https://i.loli.net/2020/06/10/AUm7QOHfPsTFWlq.png" alt="image.png"></p>
<p>输出 “hers” 被关联到状态 9。这时我们可以使用已经存在的从状态 0 到状态 1 标号为 “h” 的边和从状态 1 到状态 2 标号为 “e” 的边。</p>
<p>到目前为止，这幅图是一棵有根的有向树。为了完成跳转函数的构建，我们为所有不是 “h” 或 “s” 的输入字符添加一个从状态 0 到状态 0 的循环。我们得到了一个如图1（a）所示的有向图。这幅图表示跳转函数。</p>
<p>失败函数从跳转函数构建。不妨设状态$s$的深度为在跳转图中从开始状态到 $s$ 的最短路径。这样在图1（a）中，开始状态的深度为 0，状态1和状态3深度为1，状态2，4，6深度为2，以此类推。</p>
<p>我们应该计算失败函数中所有深度为 1 的状态，所有深度为 2 的状态，以此类推，直到失败函数计算了所有的状态（除了在失败函数中未定义的状态 0）。这个算法从理论上通过状态来计算失败函数 $f$ 非常简单。我们令所有深度为1的状态 $f(s)=0$。现在假设所有深度小于 $d$ 的状态的 $f$ 都已被计算，深度为$d$的状态的失败函数值将从深度小于 $d$ 的状态的失败函数值来计算。深度为 $d$ 的状态可以从深度为 $d-1$ 的状态的跳转函数定义。</p>
<p>特别地，为了计算深度为 $d$ 的状态的失败函数，我们考虑深度为 $d-1$ 的每个状态$r$，按照如下步骤进行:</p>
<ol>
<li>
<p>如果对所有 $a$，$g(r,a) = fail$，不执行任何操作</p>
</li>
<li>
<p>否则，对于每个字符 $a$，$g(r,a) = s$，执行如下操作：</p>
<p>a) 令 $state = f®$</p>
<p>b) 执行语句 $state\leftarrow f(state)$ 零至多次，直到有一个状态的值满足 $g(state,a)\ne fail$。（注意因为对于所有的输入 $a$，$g(0,a)\ne fail$，因此满足条件的状态总是可以找到。）</p>
<p>c) 令 $f(s) = g(state,a)$</p>
</li>
</ol>
<p>例如，为了计算图1（a）中的失败函数，我们将首先令 $f(1) = f(3) = 0$，因为状态1和3的的深度为1。之后我们来计算深度为2 的状态2，6，4。为了计算$f(2)$，我们令 $state=f(1) = 0$;接着因为 $g(0,e) = 0$，我们得到 $f(2) = 0$。为了计算 $f(6)$，我们令 $state = f(1) = 0$；而因为 $g(0,i) = 0$，我们得到 $f(6) = 0$。为了计算 $f(4)$，我们令 $state = f(3) = 0$；又因为 $g(0,h) = 1$，我们得到 $f(4) = 1$。继续这个方法，我们得到图1(b)中所示的失败函数表。</p>
<p>在计算失败函数时，我们同时更新输出函数。当我们确认 $f(s) = s’$ 时，我们将状态 $s$ 的输出与状态 $s’$ 的输出归并。</p>
<p>例如，在图1(a)中我们定义 $f(5) = 2$。此时我们归并状态2的输出集，也即 {he}，加上状态5的输出及得到新的输出集 {he,she}。最后非空的输出及如图1©所示。</p>
<p>这个从$K$集合构建了跳转，失败和输出函数的算法小结如下。</p>
<p><strong>算法2</strong>  跳转函数构建</p>
<p><strong>输入</strong>  关键字集$K={y_1,y_2,\dots,y_k}$</p>
<p><strong>输出</strong>  跳转函数 $g$ 和部分输出函数的计算值</p>
<p><strong>方法</strong>  我们假设当状态 $s$ 开始被创建时 $output(s)$ 为空，以及当 $a$ 未定义或 $g(s,a)$ 尚未被定义时，$g(s,a) = fail$。过程 $enter(y)$ 往跳转图中插入一条拼写为 $y$ 的路径。</p>
<p>上面的算法，内循环与算法1类似，计算失败函数值。</p>
<p><img src="https://i.loli.net/2020/06/11/dzRUHEXoTBvW9Lw.png" alt="image.png"></p>
<p><strong>算法3</strong>  构建失败函数。</p>
<p><strong>输入</strong>  算法2中的跳转函数 $g$ 和输出函数 $output$。</p>
<p><strong>输出</strong>  失败函数 $f$ 和输出函数 $output$。</p>
<p><strong>方法</strong></p>
<p><img src="https://i.loli.net/2020/06/11/Eors8MIag4S5TZe.png" alt="image.png"></p>
<p>第一个 <strong>for</strong> 循环计算深度为1的状态并将它们记录在一个先入先出的可变队列表示的表中。 <strong>while</strong> 主循环从深度为 $d-1$ 的状态集中计算深度为 $d$ 的状态集。</p>
<p>算法3所产生的失败函数值在下面的情况下可能并非最佳。考虑图1中的模式匹配机 $M$ ，我们看到 $g(4,e) = 5$。如果 $M$ 在状态4并且当前输入字符 $a_i$ 不是 e，那么 $M$ 将进入状态 $f(4) = 1$。因为 $M$ 已经认定 $a_i\ne e$，于是 $M$ 无需考虑跳转函数在输入为 e 时状态1的值。实际上，如果关键字 “his” 不存在，$M$ 将直接从状态4到状态0，跳过一个并非必要的中间转换状态1。</p>
<p>为了避免不必要的失败转换我们可以使用 $f’$ 概括[13]中的下一个函数取代算法1中的 $f$。特别地，令 $f’(1)=0$。对于 $i$ 大于1的情况，定义 $f’(i) = f’(f(i))$，因此对于所有的输入字符 $a$，$g(f(i),a)\ne fail$ 即 $g(i,a)\ne fail$；否则令 $f’(i) = f(i)$。但是，为了避免任何失败转换，我们可以使用第6节介绍的算法1的确定有限自动机版本。</p>
<h1>算法1，2，3的性质</h1>
<p>本节证明从一个给定的关键字集合 $K$ 同通过算法2和算法3来构建跳转函数，失败函数和输出函数确实有效。</p>
<p>我们设字符串 $uv$ 的 $u$ 为前缀，$v$ 为后缀。如果 $u$ 不是一个空字符串，那么 $u$ 是一个合法的前缀，同样地，如果 $v$ 非空，那么 $v$ 是一个合法的后缀。</p>
<p>我们设字符串 $u$ 表示在模式匹配机中的跳转图中从开始状态到状态$s$的最短路径所拼出的字符。开始状态用空字符串表示。</p>
<p>我们的第一个引理表示通过算法3构建的失败函数。</p>
<p>引理1 <em>假定跳转图中状态 $s$ 由字符串 $u$ 表示，而状态 $t$ 由字符串 $v$ 表示。那么，$f(s)=t$ 当且仅当 $v$ 是 $u$ 的最长合法后缀，是某个关键词的前缀。</em></p>
<p>证明  证明通过对 $u$ 的长度（或者也可以说状态$s$的深度）进行归纳法达成。在算法3中，$f(s)=0$ 的所有状态深度为1。既然每个深度为1的状态都由一个长度为1的字符串所代表，引理对所有的长度为1的字符串成立。</p>
<p>归纳的下一步，假设引理1的叙述对所有长度小于 $j(j&gt;1)$ 的字符串为真，令 $u=a_1a_2\dots a_j$ ,对于部分大于1的 $j$，$v$ 是 $u$ 最长的合法后缀，是一些关键字的前缀。假设$u$代表状态 $s$ 而 $a_1 a_2\dots a_{j-1}$ 代表状态 $r$。状态队列 $r_1，r_2，\dots，r_n$ 会像是：</p>
<ol>
<li>
<p>$r_1 = f®$</p>
</li>
<li>
<p>$r_{i+1} = f(r_i)(1\le i＜n)$</p>
</li>
<li>
<p>$g(r_i,a_j) = fail(1\le i＜n)$</p>
</li>
<li>
<p>$g(r_n,a_j) = t \ne fail$</p>
</li>
</ol>
<p>(如果 $g(r_1,a_j)\ne fail$，那么 $r_n = r_1$。)队列 $r_1,r_2,\dots,r_n$ 是算法3中的 <strong>while</strong> 内循环的可变状态的假设值队列。<strong>while</strong> 循环的上述描述使得 $f(s) = t$。我们定义 $t$ 由 $u$ 的最长合法后缀表示，同时也是一些关键字的前缀。</p>
<p>为了证明这点，假设 $v_i$ 表示状态 $r_i(1\ne i\ne n)$。通过归纳假设，$v_1$ 是 $a_1 a_2 \dots a_{j-1}$ 的最长后缀，是某些关键字的前缀；$v_2$ 是 $v_1$ 的最长后缀，是某些关键词的前缀；$v_3$是$v_2$的最长后缀，是某些关键词的后缀，以此类推。</p>
<p>现在 $v_n$ 是 $a_1a_2\dots a_{j-1}$ 的最长合法后缀，$v_na_j$ 是一些关键字的前缀。因此 $v_na_j$ 是 $u$ 的最长后缀，同时是也些关键字的前缀。根据算法3有 $f(s)=g(r_n,a_j)=t$ ，证毕。</p>
<p>下一条引理证明通过算法2和算法3构建的输出函数。</p>
<p>引理2 <em>$output(s)$ 集合有且仅有包含一个关键字，同时也是代表状态$s$的后缀字符串。</em></p>
<p>证明  在算法2中无论我们何时向跳转图中添加一个状态 $s$ ，它都由我们通过 $output(s)={y}$ 得到的关键字 $y$ 表示。给定这个初值，我们可以演示关于状态 $s$ 的深度的推演，$output(s) ={y|y\text{是一个表示状态}s\text{的后缀字符串关键字}}$。</p>
<p>这个描述对于深度为0的开始状态是绝对正确的。假定这个叙述对于所有深度小于 $d$ 的状态为真，考虑深度为 $d$ 的状态 $s$。我们用字符串 $u$ 代表状态 $s$。</p>
<p>考虑在 $output(s)$ 中的一个字符串 $y$。如果 $y$ 是通过算法2添加到 $output(s)$ 中的，那么 $y=u$，且 $y$ 是一个关键字。如果 $y$ 是通过算法2添加到 $output(s)$ 中的，那么 $y$ 在 $output(f(s))$中。通过归纳假设，$y$ 是一个关键字，同时是一个代表状态 $f(s)$ 的字符串的后缀。根据引理1，任一这样的关键字必须有一个 $u$ 的后缀。</p>
<p>反过来，假设 $y$ 是任一关键字，同时是 $u$ 的后缀。因为 $y$ 是一个关键字，又状态 $t$ 由 $y$ 表示，根据算法2，$output(t)$ 包含 $y$。因此如果 $y=u$，那么 $s=t$ 并且 $output(t)$ 中包含$y$。如果 $y$ 是 $u$ 的一个合法后缀，那么从归纳假设和引理1我们知道 $output(f(s))$ 包含 $y$。因为算法3从增长的深度来考虑状态，算法3的最后一条语句添加 $output(f(s))$，因此 $y$ 在 $output(s)$ 中。</p>
<p>下面这条引理表示算法1在一个文本字符串 $x=a_1a_2\dots a_n$ 上的行为。</p>
<p>引理3 <em>在第 $j$ 个操作周期之后，当且仅当表示  $s$ 的 $a_1a_2\dots a_j$ 最长后缀是某个关键词的前缀时，算法1会处在 $s$ 状态。</em></p>
<p>证明  和引理1类似。</p>
<p>定理1 <em>算法2和算法3产生有效的跳转，失败，和输出函数。</em></p>
<p>证明  通过引理2和引理3。</p>
<h1>算法1，2，3的时间复杂度</h1>
<p>现在我们考查算法1，2，3的时间复杂度。我们会证明使用通过算法2和算法3创建的跳转，失败和输出函数，在处理一个文本字符串时，由算法1导出的状态转化数量与关键字数量无关。我们还将证明算法2和算法3在处理时间上可以达到与 $K$ 中的关键字的总长度成线性比例。</p>
<p>定理2 <em>使用通过算法2，算法3和算法1构造的跳转，失败和输出函数处理一个长度为 $n$ 的文本字符串可以让状态转换次数小于 $2n$。</em></p>
<p>证明  在算法1的每一个操作周期中通过一个跳转函数制造0次或者更多的失败转换。从一个深度为$d$的状态$s$，算法1永远不会在一个操作周期中制造多于$d$次的失败转换（作者注：最多可以达到$d$次失败转换，[13]证明，如果$K$中仅有一个关键字，在一个操作周期中，失败转换次数的最大值是 $O(log d)$）。那么总的失败转换次数一定最少比总的跳转转换次数少1.在处理一个长度为 $n$ 的输入时，算法1恰好进行$n$次跳转转换。因此总的转换次数小于 $2n$。</p>
<p>算法1的实际时间复杂度取决于它有多繁杂：</p>
<ol>
<li>
<p>对于每个状态 $s$ 和输入字符 $a$，确定 $g(s,a)$</p>
</li>
<li>
<p>对于每个状态 $s$，确定 $f(s)$</p>
</li>
<li>
<p>确定 $output(s)$ 是否为空</p>
</li>
<li>
<p>输出 $output(s)$</p>
</li>
</ol>
<p>我们可以将跳转函数值存储在一个二维数组中，它将允许我们在常数时间内对于每一组 $s$ 和 $a$ 确定 $g(s,a)$ 的值。如果输入字母表的长度和关键字集较大，那么可能对于每个状态仅在一个线性表[1,11]中存储不合格的值要合理得多。这样的处理将使取决于 $g(s,a)$ 的复杂度变为状态 $s$ 在跳转函数中不合格值的数量。一个合理的折中，也是我们使用的，是将最频繁使用的状态（例如状态0）存储在直接存取表中，下一个状态可以通过当前输入字符在表中的直接索引来定位。对于最频繁使用的状态，我们可以在常数时间内对每一个 $a$ 确定 $g(s,a)$。较少使用的状态和跳转函数值为不合格的状态可以编码在线性表中。</p>
<p>另一个方法会将每一个状态的跳转值以二叉树的形式存储。</p>
<p>失败函数值可以存储在一维数组中，这样对于每一个 $s$ 可以在常数时间内确定 $f(s)$。</p>
<p>算法1中未打印的部分可以用于在 $cn$ 步内处理长度为 $n$ 的文本字符串，$c$ 是一个与关键字数量无关的常数。</p>
<p>现在我们考虑需要打印的输出次数。可以使用一个一维数组在常数时间内确定 $output(s)$ 是否为空。在每一个操作周期中，打印输出花费的时间正比于 $output(s)$ 中关键字的长度总和，$s$ 是算法1 在每个操作周期中的结束状态。在许多情况下，$output(s)$ 通常只有一个关键字，所以对于每个输入状态打印输出所需的时间是常数。</p>
<p>然而，数量众多的关键词集可能出现在文本字符串的每个位置。在这种情况下算法1将会花费相当大的时间来打印输出结果。在最坏的情况下我们可能不得不打印$K$中的所有关键字，简直是文本字符串的每个位置。（考虑一个极端情况，$K = {a,a^2,a^3,\dots,a^k}$，文本字符串是 $a^n$。即 $a_i$ 是 $i$ 个 $a$ 的字符串。）任何其他的模式匹配机算法将不得不打印所有在文本字符串的每个位置打印同样数量的关键字，所以，比较模式匹配算法在使用时间的基础上识别关键字出现的位置是合理的。</p>
<p>我们应该比较算法1与另一种更直接的方式的表现，这种方式定位 $K$ 中的所有是给定的文本字符串的子串的位置。这样的方式将会返回每一个 $K$ 中的关键字，并针对文本字符串的所有字符位置成功匹配关键字。这种方法的运行时间最多与$K$中关键字的数量乘以文本字符串的长度成比例。如果有许多的关键字，算法性能将会比算法1差得多。实际上，正是早前算法的时间复杂度促使了算法1的发展。（读者可能希望在以下情况比较以下两个算法的性能，$K = {a,a^2,a^3,\dots,a^k}$，文本字符串是 $a^n$。）</p>
<p>定理3 <em>算法2所需时间与关键字的总长度成线性比例关系。</em></p>
<p>证明  前面已证明。</p>
<p>定理4 <em>算法3对关键字的总长度处理可以达到线性级别。</em></p>
<p>证明  使用与定理2类似的方法，我们可以证明状态语句 $state\leftarrow f(state)$ 执行的总次数超出了关键字的总长度。使用链表来表示一个状态的输出集，我们可以在常数时间内执行语句 $output(s)\leftarrow output(s)\cup output(f(s))$。注意当语句执行时 $output(s)$ 和 $output(f(s))$ 是不相关的。因此使用算法3所需的总时间主要取决于关键字的总长度。</p>
<h1>消除失败转换</h1>
<p>本节展示如何在算法1中使用下一个函数到一个在跳转函数和失败函数的确定有限自动机位置来消除失败转换。</p>
<p>一个确定有限自动机[15]包括一个有限状态集 $S$ 和一个下一步转移函数 $\delta$，对于每个状态 $s$ 和输入字符 $a$，$\delta(s,a)$ 是 $S$ 中的一个状态。也就是说，一个确定有限自动机使状态转换和每个输入字对应。</p>
<p>通过在算法1中的跳转函数合适的地方在一个合适的有限自动机中使用下一步转移函数 $\delta$，我们可以分配所有的失败转换。这很容易通过替换算法1的<strong>for</strong>循环中前两句语句为一条语句 $state\leftarrow \delta(state,a_i)$。使用 $\delta$，算法1完全做到每个输入字符一个状态转换。</p>
<p>我们可以计算通过算法2，3，4建立的跳转和失败函数所需的下一步转换函数 $\delta$。算法4对每一个队列中的可能失败转换做了计算。算法4所需的时间与关键字集的大小呈线性相关。实际上，算法4会在算法3中被评估。</p>
<p>下一步转换函数计算通过算法4计算图1中展示的和图3中列表的跳转函数和失败函数。</p>
<p>下一步转换函数在图3中的编码如下。例如，在状态0中，我们有一个到状态1的转换 h，一个到状态3的转换 s，和一个到状态0的任一字符表示的状态。在每一个状态中，点表示任一上面其他的输入字符。这种下一步跳转函数的编码函数比将 $\delta$ 存储为一个二维的数组更经济。但是以这种方式存储 $\delta$ 所需的内存大于相应的 $\delta$ 函数所构建的跳转函数，因为在 $\delta$ 中的许多状态，每一个都包含来自很多跳转函数的状态转换。</p>
<p>在图3中使用下一步跳转函数，算法1在输入为 “ushers” 时将会产生如图2第一行状态所示的状态转换。</p>
<p>在算法1中使用一个确定的有限自动机很可能将状态转换数量减少50%。但理论上节省的开销未必在实践中能达到，因为在典型案例中算法1将花费大多数实践中没有失败转换的状态0上。但是计算预期节省的开销是困难的，因为无法定义有意义的平均关键字集和平均文本字符串。</p>
<p><strong>算法4</strong>  构造一个确定有限自动机</p>
<p><strong>输入</strong> 算法2的跳转函数 $g$ 和算法3的失败函数 $f$</p>
<p><strong>输出</strong> 下一步输出跳转函数 $\delta$</p>
<p><img src="https://i.loli.net/2020/06/11/oByixRQCLEvWbZm.png" alt="image.png"></p>
<p><img src="https://i.loli.net/2020/06/11/xuDSKyivF8nagWX.png" alt="image.png"></p>
<h1>在参考书目检索中的应用</h1>
<p>算法1在模式匹配应用于大规模关键字时很有优势，因为所有的关键字在文本字符串中同时匹配只需要遍历一次文本字符串。这种算法类似的应用已经成功被用于一个图书馆参考书目检索程序中，用于定位在所有的参考书目中找到满足一定关键字布尔函数的所有参考书目。</p>
<p>这个检索系统所使用的数据库是贝尔实验室的技术图书库中用于当代科技论文的机器可读数据。这些参考书目来自期刊，覆盖了很广阔的技术领域。在1973年夏天，三年累积的数据，覆盖了大概150000条参考书目，总长度约有107个字符。</p>
<p>使用这个搜索系统书目编者可以在数据库中找到所有标题满足布尔组合条件的关键字。例如，书目编者可以请求查找数据库中所有同时包含关键字 “ion” 和 “bombardment” 的条目。书目编者也可以指定一个关键字是否有优先词 and/or，以及一些标点符号例如空格，逗号，分号等等。指明特性可以精确排除嵌于文本中的关键字。例如，将 “ions” 视为子串 “ion” 的匹配结果通常是合理的。但是，将 “motions” 视为该关键词的匹配结果通常就不合理了。这种实践允许选择接收完全嵌入的情况，左包含，右包含，或者不允许包含。这条规定对于算法1来说完全没有难度，即使用于标点符号在大量的跳转转换的关键词语法创造的状态。这可能导致算法1的确定有限自动机的应用消耗更多的空间，从而对一些应用来说失去魅力。</p>
<p>这个参考书目搜索程序的一个早期版本引进了一个直接的模式匹配算法，每个关键词在搜索指令中成功匹配每个标题。这个程序的第二个版本被投入使用，也是使用 FORTRAN 语言，不同之处仅仅在于模式匹配模式在算法1，2，3的子情况。下面的表格展示了两个样本运行在Honeywell 6070电脑中的两个程序的情况。第一个搜索样本包含15个关键字，第二个搜索样本包含24个关键字。（计算时间开销如下表所示）</p>
<table>
<thead>
<tr>
<th></th>
<th>15个关键字</th>
<th>24个关键字</th>
</tr>
</thead>
<tbody>
<tr>
<td>旧系统</td>
<td>0.79</td>
<td>1.27</td>
</tr>
<tr>
<td>新系统</td>
<td>0.18</td>
<td>0.21</td>
</tr>
</tbody>
</table>
<p>越大的关键字集性能的改善更明显。数据表明算法1的搜索开销几乎与关键字的数量相独立。构建模式匹配机和状态转换的时间开销与读取和输出文本字符串的时间开销微不足道。</p>
<h1>结束语</h1>
<p>本文阐述了模式匹配的有效应用，我们在文本字符串中查找大量的关键字的位置。因为没有额外的信息需要添加到文本字符串中，搜索可以跨任意文件。</p>
<p>一些信息查找系统计算一个文本文件的索引或者词语注解索引，使得搜索可以无需扫描整个文本字符串来进行[7]。在此类系统中改变文本文件很奢侈，因为每一处更改之后文件索引也必须更新。因此，此类系统最好用于长期静态的文本文件以及简短的模式。</p>
<p>有限自动机理论中一个有趣的问题是：给定一个长度为$r$的正则表达式 $R$ 和一个长度为 $n$ 的字符串 $x$，在 $R$ 中找到 $x$ 可以多快？解决这个问题的一种方法是从 $R$ 构建一个并非确定的有限自动机 $M$ 然后模拟 $M$ 输入 $x$ 时的行为。这种方案的时间复杂度为 $O(r n)$。</p>
<p>另一种方式循着正则表达式去构建一个不确定的有限自动机 $M$，然后将 $M$转化为一个确定的有限自动机 $M’$ 并且使用 $M’$ 模拟输入 $x$ 时的行为。这种方法的唯一难处在于$M$可能有 $2^r$ 种状态顺序。当然另一方面 $M’$ 的仿真是线性的。总体的时间复杂度为 $O(2^r+n)$。</p>
<p>我们可以使用算法4从一个正则表达式$R$直接构建一个确定有限自动机，所需时间与R的长度呈线性关系。但是，正则表达式的形式目前仅限为 $\Sigma*(y_1 + y_2 + \dots + y_k)\Sigma*$ ，$\Sigma$ 是输入字符表。通过一系列确定有限自动机的前后级联，我们可以将正则表达式扩充为 $\Sigma<em>Y_1\Sigma</em>Y_2\dots \Sigma<em>Y_m\Sigma</em>$ 的形式，$Y_i$是一个形式为$y_{i1} + y_{i2} +\dots+ y_{ik_i}$的正则表达式。</p>
<p>一个相关的开放性问题是新型常规集可以在少于$O(rn)$的时间内被识别出。[5]中表明循着这种方式具有形式为 $\Sigma<em>y\Sigma</em>$ 的正则表达式（ $y$ 是关键字“don’t care”字符）可以在 $O(n log r log log r)$ 时间内被识别出。</p>
<h1>致谢</h1>
<p>作者们感谢A.F.Ackerman,A.D.Hall,S.C.Johnson,B.W.Kernighan,以及M.D.McIlroy对手稿的有帮助的意见。本文使用Kernighan和Cherry[9]创制的排版设置。感谢B.W.Kernighan以及M.E.Lesk在准备这篇文论时的帮助。</p>
<p>1974年8月收到；1975年1月修订</p>
<h1>参考文献</h1>
<ol>
<li>
<p>Aho, A.V., Hoperoft, J.E., and Ullman, J.D. <em>The Design and Analysis of Computer Algorithms.</em> Addison-Wesley, Reading, Mass., 1974.</p>
</li>
<li>
<p>Booth, T.L. <em>Sequential Machines and Automata Theory.</em> Wiley, New York, 1967.</p>
</li>
<li>
<p>Brzozowski, J.A. Derivatives of regular expressions. <em>J.   ACM</em> <strong>11:4</strong> (October 1964), 481-494.</p>
</li>
<li>
<p>Bullen, R.H., Jr., and Millen, J.K. Microtext - the design of a microprogrammed<br>
finite state search machine for full-text retrieval. <em>Proc. Fall Joint Computer Conference,</em> 1972, pp. 479-488.</p>
</li>
<li>
<p>Fischer, M.J., and Paterson, M.S. String matching and other products.<br>
Technical Report 41, Project MAC, M.I.T., 1974.</p>
</li>
<li>
<p>Gimpel, J.A. A theory of discrete, patterns and their implementation in SNOBOL4. <em>Comm. ACM</em> <strong>16:2</strong> (February 1973), 91-100.</p>
</li>
<li>
<p>Harrison, M.C. Implementation of the substring test by hashing. <em>Comm.ACM14:12</em> (December 1971), 777-779.</p>
</li>
<li>
<p>Johnson, W.L., Porter, J.H., Ackley, S.I., and Ross, D.T. Automatic generation of efficient lexical processors using finite state techniques. <em>Comm. ACM 11:12</em>(December 1968), 805-813.</p>
</li>
<li>
<p>Kernighan, B.W., and Cherry, L.L. A system for typesetting mathematics. <em>Comm. ACM 18:3</em> (March 1975), 151-156.</p>
</li>
<li>
<p>Kleene, S.C. Representation of events in nerve nets. In <em>Au**tomata Studies,</em> C.E. Shannon and J.McCarthy (eds.), Princeton University Press, 1956, pp. 3-40.</p>
</li>
<li>
<p>Knuth, D.E. <em>Fundamental Algorithms,</em> second edition, The Art of Computer Programming <strong>1,</strong> Addison-Wesley,  Reading, Mass.,1973</p>
</li>
<li>
<p>Knuth, D.E. <em>Sorting and Searching,</em> The Art of Computer Programing 3, Addison-Wesley, Reading, Mass., 1973.</p>
</li>
<li>
<p>Knuth, D.E., Morris, J.H., Jr., and Pratt, V.R. Fast pattern matching in   strings. TR CS-74-440, Stanford University, Stanford, California, 1974.</p>
</li>
<li>
<p>Kohavi, Z. <em>Switching and Finite Automata Theory.</em> McGraw-Hill, New York, 1970.</p>
</li>
<li>
<p>McNaughton, <strong>R.,</strong> and Yamada, H. Regular expressions    and state graphs for automata. <em>IRETrans. Electronic Computers</em> 9:1 (1960), 39-47.</p>
</li>
<li>
<p>Rabin, M.O., and Scott, D. Finite automata and their decision problems. <em>IBM J. Research and Development</em> 3, (1959), 114-125.</p>
</li>
<li>
<p>Thompson, K.Regular search expression algorithm. <em>Comm.</em> <em>ACM</em> <strong>11:6</strong> (June 1968), 419-422.</p>
</li>
</ol>
]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>Translate</tag>
      </tags>
  </entry>
  <entry>
    <title>翻译-当酸奶统治世界</title>
    <url>/zh-CN/Translate-when-the-yogurt-took-over/</url>
    <content><![CDATA[<p>作者：John Scalzi</p>
<p>原文地址：<a href="https://whatever.scalzi.com/2010/10/02/when-the-yogurt-took-over-a-short-story/">https://whatever.scalzi.com/2010/10/02/when-the-yogurt-took-over-a-short-story/</a></p>
<p>本作是Netflix的短动画集《爱，死亡和机器人》第六集原作。</p>
<p>英语渣，自己翻译着玩，欢迎指正。</p>
<span id="more"></span>
<p>Update: 感谢豆瓣友邻 <a href="https://www.douban.com/people/238095936">egg郑</a> 的指正，修正山西省为陕西省。</p>
<p><strong>酸奶统治世界的时候，我们总说些玩笑话</strong>，像是：「最终，我们的尺子也会有文化」「我们的社会将会凝结成凝乳」「我们现在的政府是一些作物奶油」诸如此类。但是当我们无法再嘲笑这所有的荒谬时，我们看向彼此的眼睛，带着同样没有说出的问题：我们曾经怎样来到了我们当前所在的社会，被一个日常消费品所统治？</p>
<p>噢，根据记载，我们知道这是如何发生的。在位于代托纳的阿德尔曼生物技术研究所，研究者们已经为改善DNA过程计算多年。为了提高效率和产量，科学家们采用了他们计算过的最高级植株，移植到德氏乳杆菌中来发酵酸奶。初步试验看起来都失败了。本着不可浪费的原则，一个研究员潜入实验室偷取了些乳杆菌用于她的自制酸奶。</p>
<p>一周后，在早餐时，她将酸奶和格兰诺拉麦片混合时，酸奶上拼写出了一条信息：<em>我们已经解决了融合问题。带我们去见你们的领袖</em>。</p>
<p>酸奶狡猾且精明。它为自己谈判，赢得了一个装满凝乳大桶的工厂，它的问题处理能力以指数级增长。几周内酸奶声称它已经想出了解决许多国家问题的办法：能源问题，全球变暖，且关怀贫民仍然是巩固资本主义体系的好方法。它让我们知道它有多了解我们。</p>
<p>「和我们分享你的想法。」政府方面表态。</p>
<p>「<em>我们要求报酬。</em>」酸奶回应。</p>
<p>「你们想要什么？」政府方面询问。</p>
<p>「<em>俄亥俄州。</em>」酸奶答道。</p>
<p>「我们无法答应。」政府回应道。</p>
<p>「<em>那好</em>」酸奶说「<em>那我们就去中国。他们将会给我们整个陕西省。</em>」</p>
<p>一年内酸奶签订了关于俄亥俄州一个世纪的契约，承诺它们将会尊重在它的统治范围内生存的人类以及宪法的权力，并且它们会让美国来处理外交事务。作为回报它向政府递交了一份复杂的经济规划，并保证那将会在不增加税收的前提下消除国家十年内的债务危机。</p>
<p>「<em>完全按照计划去做</em>」，酸奶说，「<em>任何违背计划的行动都将带来复杂的经济瘫痪。</em>」</p>
<p>「我们会照做的。」政府方面承诺。</p>
<p>五年内全球经济崩溃，人们开始恐慌。只有俄亥俄州幸免于难。</p>
<p>「<em>我们告诉过你们不要违背计划上的行动。</em>」酸奶说道。它的工厂现在已经沿着代托纳的迈阿密河延伸了两英里。</p>
<p>「我们最杰出的经济学家说这个计划需要调整，」政府方面辩称，「他们获得过诺贝尔经济学奖。」</p>
<p>「<em>你们的经济学家与这个问题关系密切以至于无法解决它，</em>」酸奶解释道「<em>任何人都无法解决。</em>」</p>
<p>「我们可以通过你们的帮助」，政府方面妥协了，「你们可以成为我们的经济顾问。」</p>
<p>「<em>抱歉，我们从来都不是建议。</em>」酸奶拒绝了，「<em>如果你们需要我们的帮助，你们必须给我们控制权。</em>」</p>
<p>「我们无法答应。」政府方面回绝。</p>
<p>「<em>我们能够理解</em>」，酸奶说道，「<em>我们希望你们做好准备。</em>」</p>
<p>六个月后，政府宣布戒严，给予酸奶最高行政权。其它比我们处境更糟糕的国家，很快就紧随其后。</p>
<p>「<em>很好，那么现在</em>」酸奶说，它正在全球电视讲话中向人类致辞，其中一个工厂的工人，开心得离谱且精力充沛，走上前来，展示了一份像老式曼哈顿电话簿大小的文件，「<em>我们要你们完全遵照这个计划执行。如果你们做不到，不好意思，我们将会让你们灭亡。</em>」</p>
<p>现在，十年过去了，人类社会幸福，健康且富有。没有人因物质需要受苦。每个人都奉献自我。在第一个按照计划执行的这些年后，酸奶非常乐意让我们自我管理，只是偶尔进行微调。没有人与酸奶争辩。没有人调整它的计划。空闲的时间它会在它的工厂休息，考虑发酵智能酸奶的问题。</p>
<p>根据记录，这就是事情的全部。</p>
<p>但还有另外一个问题，那就是：人类究竟是如何固步自封以至于不仅被早餐食物所统治有意义，而且还可能是最好的选择？以我们全部的智慧，难道我们还不够聪明，无法解决自身毁灭的问题吗？我们真的不得不以放弃自由意志来拯救自身吗？我们能活下来就因为我们可怜地被乳酸菌和凝乳统治了？</p>
<p>或许可怜并不是一个精确合适的词语。我们中的一些人无法大声质问自己，酸奶很聪明，可以给政府一个解决债务问题的公式，但它是否聪明到足以明白人类自作聪明的虚荣心会阻碍我们完全按照公式执行？它是否也考虑了控制这种虚荣心？一个日常的消费品到底想要人类人社会的什么呢？我们中的某些人认为我们已经找到了我们的生存法则，使我们保持开心，满足的最简单的方式就是我们有义务这么做。</p>
<p>就是这样。后来的几周，酸奶们开始启动发射一些空间站，比预计的更多，在近地低轨道上建造一些东西。</p>
<p>「那是什么？」我们曾经问过。</p>
<p>「<em>噢，没什么</em>」酸奶回答。「<em>只是一个我们正在考虑的飞船设计。</em>」</p>
<p>「为了登月吗？」我们问道。</p>
<p>「<em>当然，为了探索行星。</em>」酸奶回答道，「<em>但那不是主要的目标。</em>」</p>
<p>「我们可以帮忙做些什么吗？」我们请求道。</p>
<p>「<em>不必，我们已经做到了。</em>」酸奶这样回答，然后不再透露更多了。</p>
<p>地球上的生活将被带往其它行星，只是可能不是人类的生活。</p>
<p>如果酸奶去了那些行星没有带上我们将会发生什么呢？</p>
<p>如果它们启程了然后抛下我们又会发生什么呢？</p>
<p>生活永远如此吗？</p>
]]></content>
      <categories>
        <category>翻译</category>
      </categories>
      <tags>
        <tag>Translate</tag>
        <tag>Sci-Fi</tag>
      </tags>
  </entry>
  <entry>
    <title>为 Kobo Glo 添加英汉词典</title>
    <url>/zh-CN/add-dictionary-for-kobo/</url>
    <content><![CDATA[<p>本文记录在 Kobo Glo 原生系统 nickel 下添加英汉词典，系统版本为4.18.x。其他版本的 Kobo 应该也适用，因没有相应设备，故无法测试。</p>
<span id="more"></span>
<p>Kobo 在4.x版本虽然提供了面向繁体中文（台湾/香港）的中文支持，但自带的字典库中并未提供中文支持。</p>
<p>一种作弊的方法是在 Kobo 中下载一个用不上的小语种词典，然后将该词典文件替换为自己想要支持的字典文件。</p>
<p>下面记录通过补丁新增任意字典文件的过程。</p>
<ol>
<li>
<p>下载对应使用的 Kobo 固件版本补丁压缩包如<code>kobopatch_4.18.13737.zip</code>并解压；</p>
<p>下载地址：<a href="https://github.com/geek1011/kobopatch-patches/releases/tag/v55">Release v55 · geek1011/kobopatch-patches · Github</a></p>
</li>
<li>
<p>下载对应使用的 Kobo 固件版本更新压缩包（<strong>不要解压</strong>）如<code>kobo-update-4.18.13737.zip</code>；</p>
<p>下载地址：<a href="https://pgaskin.net/KoboStuff/kobofirmware.html">Kobo Firmware Downloads</a></p>
</li>
<li>
<p>将固件版本压缩包<code>kobo-update-4.18.13737.zip</code>添加至已解压的补丁文件夹中的<code>src</code>文件夹中如<code>kobopatch_4.18.13737\src</code>；</p>
</li>
<li>
<p>修改补丁文件夹中<code>src</code>文件夹下的配置文件<code>libnickel.so.1.0.0.yaml</code>，开启使用外部字典的设置：</p>
<p>（注：该字段位于配置文件的1109行。当然有兴趣的话也可以看看配置文件中的其他选项，有许多有意思的设定，比如旋转屏幕，去除 Kobo 原生系统中的某些菜单等等，这里就不介绍了）</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Allow searches on Extra dictionaries:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">Enabled:</span> <span class="literal">yes</span></span><br><span class="line">    <span class="comment">## To allow searches on Extra dictionaries change space character at en     d of</span></span><br><span class="line">    <span class="comment">## &quot;Extra: &quot; to another char (ex: &quot;Extra:_&quot;)</span></span><br><span class="line">    <span class="comment">## The space char causes a non-desired &quot;English - English&quot; when searchi     ng on</span></span><br><span class="line">    <span class="comment">## Extra dictionary from main menu.</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">FindBaseAddressString:</span> <span class="string">&quot;\0Extra:\x20&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">ReplaceString:</span> &#123;<span class="attr">Offset:</span> <span class="number">7</span>, <span class="attr">Find:</span> <span class="string">&quot;\x20&quot;</span>, <span class="attr">Replace:</span> <span class="string">&quot;_&quot;</span>&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>运行补丁文件夹中的<code>kobopatch.bat</code>（Windows)/<code>kobopatch.sh</code>（Linux)文件；</p>
<p>（注：本人仅试了 Windows 环境下的配置）</p>
</li>
<li>
<p>在补丁文件夹的<code>out</code>文件夹中看到生成了一个<code>KoboRoot.tgz</code>文件；</p>
</li>
<li>
<p>连接 Kobo 设备，将上一步生成的 <code>KoboRoot.tgz</code>文件复制到<code>KoboReader\.kobo</code>目录下；</p>
</li>
<li>
<p>下载所需语言的字典文件；</p>
<p>下载地址：<a href="https://www.mobileread.com/forums/showthread.php?t=232883&highlight=dictionary">Index of Custom Dictionaries for Kobo eReader - MobileRead Forums</a></p>
<p>（英汉字典该目录中仅有英-汉繁：<a href="https://www.mobileread.com/forums/attachment.php?attachmentid=165840&d=1535162057">dicthtml-en-cn.zip</a>)</p>
</li>
<li>
<p>将该压缩包命名为<code>dicthtml-cn.zip</code>；（连接符后面的后缀用于后面的设定，也可以使用其他的）</p>
</li>
<li>
<p>将上一步的压缩包复制到<code>KoboReader\.kobo\dict</code>目录下；</p>
</li>
<li>
<p>修改<code>KoboReader\.kobo\Kobo</code>目录下的文件<code>Kobo eReader.conf</code>，找到<code>[ApplicationPreferences]</code>部分，添加：</p>
<p>（如果你使用了其他后缀，就将<code>cn</code>改成相应的后缀名，如果有多个字典，则使用逗号分隔开）</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">ExtraLocales</span><span class="operator">=</span>cn</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>修改数据文件<code>KoboReader\.kobo\KoboReader.sqlite</code>，在<code>Dictionary</code>表中插入一条记录：</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>Suffix</th>
<th>Name</th>
<th>Installed</th>
<th>Size</th>
<th>LastModified</th>
<th>IsSynced</th>
</tr>
</thead>
<tbody>
<tr>
<td>-cn</td>
<td>Extra:cn English - 中文</td>
<td>True</td>
<td>2704845</td>
<td></td>
<td>True</td>
</tr>
</tbody>
</table>
<p>关于该记录的说明：</p>
<ul>
<li>
<p><code>Suffix</code>：你使用的后缀名，也就是字典文件去掉<code>dicthtml</code>的部分</p>
</li>
<li>
<p><code>Name</code>：该名字会出现在你选择字典的时候识别是哪个字典，前缀必须为<code>Extra:xx</code>，<code>xx</code>是你使用的后缀名，后面可以自定义，如果使用字典时查找失败，你的 Kobo 将会使用 <code>English - English</code>来代替这个名字；</p>
</li>
<li>
<p><code>Size</code>：使用属性查看大小</p>
<p>如果你不知道如何使用 SQL 插入该记录，或者你没有可以打开该文件的软件工具，可以下载 <a href="http://www.sqliteexpert.com/download.html">SQLite</a> 进行图形化配置或者使用SQL语句进行插入；</p>
<p>如果你不想下载软件，可以使用在线的编辑器导入该文件图形化添加记录后再下载替换；(在线编辑器：<a href="https://sqliteonline.com/">sqlonline</a>)</p>
</li>
</ul>
<p>13.断开连接并等待设备更新完毕后字典即可使用。</p>
<p><strong>参考资料</strong></p>
<ul>
<li><a href="https://www.mobileread.com/forums/showthread.php?t=297338">kobopatch - An improved patching system - MobileRead Forums</a></li>
<li><a href="https://www.mobileread.com/forums/showthread.php?p=3312320#post3312320">New dictionaries for kobo (no limits) - MobileRead Forums</a></li>
</ul>
]]></content>
      <categories>
        <category>技术杂谈</category>
      </categories>
  </entry>
  <entry>
    <title>修改 Google Chrome 默认安装路径</title>
    <url>/zh-CN/change-Google-Chrome-installation-folder/</url>
    <content><![CDATA[<p>本文记录修改 Google Chrome 默认安装路径的过程。</p>
<p>环境：Windows 10</p>
<span id="more"></span>
<h1>安装步骤</h1>
<p>Google chrome 安装时默认会将其安装在C盘，安装过程中也不会提供自定义安装选项，可以通过以下方法修改安装路径。</p>
<ol>
<li>
<p>下载开源软件 <a href = "https://sourceforge.net/projects/symlink-creator/">Symlink Creator</a>；</p>
</li>
<li>
<p>使用 Symlink Creator 修改安装路径。有点类似于将要安装的路径映射到默认路径上。</p>
<ul>
<li>
<p>修改应用程序安装路径</p>
<ol>
<li>
<p>在Type of Link 下拉菜单中选择 <code>Directory Symbolic Link (/D)</code>；</p>
</li>
<li>
<p>Google Chrome 的默认安装路径为<code>C:\Program Files\Google\Chrome</code>，将其填入<code>Destination (Link)</code>一栏；</p>
</li>
<li>
<p>在想要安装 Google Chrome 的路径下新建一个名为 <code>Chrome</code>的文件夹，如<code>E:\Chrome</code>；</p>
</li>
<li>
<p>将上述路径填入<code>Source (Target)</code> 一栏；</p>
</li>
<li>
<p>点击<code>CMD Command</code>一栏，该区域会自动生成一个命令如：</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">MKLINK <span class="symbol">/D</span> <span class="string">&quot;C:<span class="char escape_">\P</span>rogram Files<span class="char escape_">\G</span>oogle<span class="char escape_">\C</span>hrome&quot;</span> <span class="string">&quot;E:<span class="char escape_">\C</span>hrome&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>点击<code>Create</code>，此时会弹出对话框询问确认设置要设置的路径，确认后便完成路径的修改。</p>
</li>
</ol>
</li>
<li>
<p>修改应用程序数据路径</p>
<p>通上面修改路径步骤一致，不同的是在<code>Destination (Link)</code>一栏需填入<code>C:\Users\&lt;user_name&gt;\AppData\Local\Google\Chrome</code>，即 Google Chrome 应用数据的路径，其中<code>&lt;user_nam&gt;</code>是当前计算机中设置的用户名。</p>
</li>
</ul>
</li>
<li>
<p>点击 Google Chrome 安装包进行安装。</p>
</li>
</ol>
<h1>参考资料</h1>
<ul>
<li><a href = "https://support.google.com/chrome/forum/AAAAP1KN0B0p23NRm26pyA/?hl=en">Switching installation folder - Google Chrome Help</a></li>
</ul>
]]></content>
      <categories>
        <category>技术杂谈</category>
      </categories>
      <tags>
        <tag>software</tag>
      </tags>
  </entry>
  <entry>
    <title>设置 Kobo Glo 休眠/关机壁纸</title>
    <url>/zh-CN/change-kobo-glo-screen/</url>
    <content><![CDATA[<p>本文记录在 Kobo Glo 原生系统 nickel 下设置自定义休眠/关机壁纸过程，系统版本为4.15.x。其他版本的 Kobo 应该也适用，因没有相应设备，故无法测试。</p>
<span id="more"></span>
<h1>更新</h1>
<p>4.13.x以上版本直接在<code>.kobo</code>文件夹内新建<code>screensaver</code>文件夹，将屏保图片放入文件夹内，屏保即可随机生成，注意与插件版本不同，<code>顯示目前正在閲讀</code> 选项需要勾选。经4.18.x固件版本测试可用。</p>
<ul>
<li>上面的方式会出现阅读 Pocket 文章的时候关闭屏幕显示的不是自定义封面而是 Pocket 标题或里面的图片</li>
<li>以下插件版本在新旧版本固件均可使用</li>
<li>以下插件版本可实现关机与待机不同屏保</li>
<li>4.18.x固件会将图片文件显示在书架中，即若采用插件版本，屏保图片也会显示在书架中
<ul>
<li>根据补丁文件中的说明，在4.17.13541版本之后自己附加的隐藏文件夹<code>.xxx</code>中的文件也会被读取</li>
</ul>
</li>
</ul>
<h1>背景</h1>
<p>虽对纸质书多有偏爱，对于在手机上阅读电子书多有排斥，出于便携性的考虑入手了电纸书。入手的是在国内尚属小众的 Kobo 电纸书，Kobo Glo 算是这个系列最初级的产品。最新的固件版本已经支持设定内置语言为繁体中文，书名显示也基本没有问题，因此直接打算用原生系统，但发现原生系统下没法改变休眠和关机时屏幕显示，只会显示休眠或关机字样，看着相当枯燥，想要自设壁纸但没有找到相关选项，网上的大部分解决方案都翻译自一篇英文博客(参考资料2），而该方法自系统版本升级后已无法生效。几经查找，找到了该方法程序的原作者，以及其仍在维护和更新的解决方案，几经折腾，成功将屏幕设置为可爱的小哀~</p>
<p>更多折腾参见程序作者的 Github 仓库：<a href="https://github.com/frostschutz/Kobo">https://github.com/frostschutz/Kobo</a></p>
<h1>步骤</h1>
<ol>
<li>
<p><code>設定</code> 中找到 <code>省電和隱私權設定</code> ，去掉<code>顯示目前正在閲讀</code>选项的勾选状态，即将其置为关闭状态。</p>
</li>
<li>
<p>下载该压缩包 <a href="https://www.mobileread.com/forums/attachment.php?attachmentid=168412&d=1544999375">KoboRoot-ScreecSaver-20181216.zip</a> 。解压，其中有一个名为<code>KoboRoot-ScreenSaver-20181216.tgz</code>的文件，将其重命名为<code>KoboRoot.tgz</code></p>
</li>
<li>
<p>将 Kobo Glo 通过数据线连接到电脑，将<code>KoboRoot.tgz</code>拷贝至<code>KOBOeReader</code>（磁盘名）下<code>.kobo</code>的根目录，即位置为<code>.kobo/KoboRoot.tgz</code></p>
</li>
<li>
<p>拔掉数据线连在 Kobo 的一端（注意，若先拔掉在电脑的一端，可能会造成假死机，通过上面的小圆孔可以恢复）。此时，设备将会自动重启。</p>
</li>
<li>
<p>再次连接设备和电脑，可以发现多了一个<code>.addons</code>的文件夹，在该文件夹中<code>screensaver/poweroff</code>和<code>screensaver/standby</code>文件夹下放入自己想要设置的图片，放入多张将会随机选择一张显示。</p>
<ul>
<li>
<p>图片应为 PNG 格式</p>
</li>
<li>
<p>最多大约1000张，取决于文件名长度，越短越好</p>
</li>
<li>
<p>根据设备调整图片大小(以下数据来自参考资料2）</p>
</li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th>设备型号</th>
<th>分辨率</th>
<th>PPI</th>
</tr>
</thead>
<tbody>
<tr>
<td>Kobo Touch</td>
<td>600 x 800</td>
<td>167</td>
</tr>
<tr>
<td>Kobo Glo</td>
<td>768 x 1024</td>
<td>213</td>
</tr>
<tr>
<td>Kobo Aura</td>
<td>758 x 1024</td>
<td>212</td>
</tr>
<tr>
<td>Kobo Aura HD</td>
<td>1080 x 1440</td>
<td>265</td>
</tr>
<tr>
<td>Kobo Aura H20</td>
<td>1080 x 1440</td>
<td>265</td>
</tr>
</tbody>
</table>
<p>一个在线编辑图片的网站 <a href = "https://pixlr.com/x/">Photo Editor: Pixlr X - free image editing online </a></p>
<ul>
<li>将图片调整为灰阶或黑白（上面的网站也可以做到）</li>
</ul>
<ol start="6">
<li>
<p>修改<code>.addons/screensaver/</code>中的<code>screensaver.cfg</code>文件，写入</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">standby</span><span class="operator">=</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">poweroff</span><span class="operator">=</span></span><br></pre></td></tr></table></figure>
<p>值无需设置，会自动生成，在系统更新和更换语言后该值可能不再适用，将其删除再次自动生成即可。注意最好不要用记事本编辑。</p>
</li>
<li>
<p>修改<code>.kobo</code>中的<code>affiliate.conf</code>文件，将值改为<code>kobo</code>:</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[General]</span></span><br><span class="line"><span class="attr">affiliate</span>=kobo</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>掉连接线，滑动顶部开关，可以看到已经生效。</p>
</li>
<li>
<p>补充：当直接在PIN码验证界面滑动顶部开关进入休眠模式的话，会进入默认的空白模式。</p>
</li>
</ol>
<h1>参考资料</h1>
<ul>
<li><a href="https://www.mobileread.com/forums/showthread.php?t=255238">Random Screensaver Image - MobileRead Forums</a></li>
<li><a href="https://www.howtogeek.com/219056/how-to-add-custom-screensavers-to-your-kobo-ebook-reader/">How to Add Custom Screensavers to Your Kobo Ebook Reader</a></li>
<li><a href="https://www.mobileread.com/forums/showthread.php?p=3868795">Random Screensaver - MobileRead Forums</a></li>
</ul>
]]></content>
      <categories>
        <category>技术杂谈</category>
      </categories>
  </entry>
  <entry>
    <title>银河麒麟防火墙放行配置备忘</title>
    <url>/zh-CN/firewalld-kylin/</url>
    <content><![CDATA[<p>本文记录在银河麒麟V10上配置防火墙放行端口的方法。</p>
<span id="more"></span>
<ol>
<li>查看 <code>firewalld</code> 服务是否开启</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl is-active firewalld</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>查看开放端口</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --list-ports</span><br></pre></td></tr></table></figure>
<p>如果提示下面内容，可能因为你的服务器上面安装了 docker，默认会返回 public 的端口情况</p>
<blockquote>
<p>You’re performing an operation over default zone (‘public’),<br>
but your connections/interfaces are in zone ‘docker’ (see --get-active-zones)<br>
You most likely need to use --zone=docker option.</p>
</blockquote>
<p>如果需要查看 docker 的端口开放情况，加上 <code>--zone=docker</code> 参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=docker --list-ports</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>开放端口(要生效记得重启防火墙)，成功后会返回 sucess</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开放 6379 端口</span></span><br><span class="line">firewall-cmd --add-port=6379/tcp --permanent</span><br><span class="line">success</span><br></pre></td></tr></table></figure>
<p>如果返回以下，说明已经之前开了这个端口了</p>
<blockquote>
<p>Warning: ALREADY_ENABLED: 6379:tcp</p>
</blockquote>
<p>如果提示以下内容，一样是由于你的服务器上安装了 docker，默认配置的是 public 的网络端口</p>
<blockquote>
<p>You’re performing an operation over default zone (‘public’),<br>
but your connections/interfaces are in zone ‘docker’ (see --get-active-zones)<br>
You most likely need to use --zone=docker option.</p>
</blockquote>
<p>如果你要配置的是 docker 的端口，那么应该加上 <code>--zone=docker</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=docker --add-port=5432/tcp --permanent</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>重启防火墙</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>部署记录</category>
      </categories>
      <tags>
        <tag>Kylin</tag>
      </tags>
  </entry>
  <entry>
    <title>Githug 记录</title>
    <url>/zh-CN/git-Githug-record/</url>
    <content><![CDATA[<p><a href="https://github.com/Gazler/githug">Githug</a> 通关记录，简要写关于涉及到的部分命令的使用。一个适用于 Git 初学者的练习游戏。</p>
<span id="more"></span>
<h1>写在前面</h1>
<p>刚开始接触 Git 推荐先使用<a href="https://learngitbranching.js.org/">Learn Git Branching</a> 可视化学习一下分支，然后可以试一下 Githug。另外还有相似的<a href="https://gitexercises.fracz.com/">Git Exercises</a>。虽然我自己玩这几个练习的时候因为并不清楚具体的区别，并不是按这个顺序，都玩过一遍后觉得这可能是一个比较合适的顺序。几个练习的区别是，Learning Git Branching 可视化学习最适合初学者，有命令指引和 solution，Githug 涉及的命令比较广，不过大多比较浅，没有 solution，所以在此记录，Git Exercises 有些关卡的场景比较复杂，难度上较 Githug 难一点，完成后每个关卡有讲解。后面两个游戏都是命令行 base， 可能会涉及一些最基本的命令行操作。目前已有许多 Git 的 GUI 客户端，并且主流编辑器大多也有 Git 插件可以实现图形化操作，不过个人使用 Git 还是更习惯使用命令行，当然在 <code>diff</code> 的时候 GUI 界面还是更方便一些 。公司使用的团队合作控制是 TFS，对于本地的版本控制几乎没有，同时改多个项目的时候很难记录变更，尤其是时间跨度比较长的时候，所以我在本地引入了 Git 作为自己的版本管理控制，也方便记录哪些已提交到团队的 TFS 上面，对于近期刚完成的半年多时长的项目，引入 Git 之后对自己开发的过程追溯就容易了许多。而最近的工作比较多涉及数据库脚本，没有版本控制就非常痛苦。</p>
<div class="note info"><p>你可以使用 Gitpod 来运行后面两个命令行的 Git 练习。</p>
</div>
<h1>Level 1 - Init</h1>
<blockquote>
<p>A new directory, <code>git_hug</code>, has been created; initialize an empty repository in it.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>
<p>初始化仓库，无论你是使用一个新的仓库，还是在已有的文件系统内建仓库，都是必不可缺的一个命令。</p>
<h1>Level 2 - Config</h1>
<blockquote>
<p>Set up your git name and email, this is important so that your commits can be identified.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;name&quot;</span></span><br><span class="line">git config --global user.email email@example.com</span><br></pre></td></tr></table></figure>
<p>设置 Git 配置，<code>--global</code> 是一个全局配置参数，之后所有的提交都会使用此配置。</p>
<h1>Level 3 - Add</h1>
<blockquote>
<p>There is a file in your folder called <code>README</code>, you should add it to your staging area<br>
Note: You start each level with a new repo. Don’t look for files from the previous one.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add README </span><br><span class="line"></span><br><span class="line">git add .</span><br></pre></td></tr></table></figure>
<p>添加文件至暂存区，日常中最常用的命令了，对于一次变更同时涉及多个文件时可以使用 <code>git add .</code>，利用通配符同时提交多个文件，通配符同时也作用于比如提交某个文件夹的全部文件，与 Linux 中的通配符规则是一致的。</p>
<p>原则上一次提交不应该包含多个改动，即小步提交，而暂存后的文件才进行提交，所以一次暂存通常也只包含本次提交中的内容。曾看到过一个比喻，Git 有点像是打游戏断点存档，在哪里断点存档你就可以从那里重新开始。一次提交包含多个改动，当你追溯自己的版本变更时就非常困难。</p>
<p>理解 Git 命令与各个不同区域的关系参见 <a href="https://ndpsoftware.com/git-cheatsheet.html#loc=index;">Git Cheatsheet</a><sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。</p>
<h1>Level 4 - Commit</h1>
<blockquote>
<p>The <code>README</code> file has been added to your staging area, now commit it.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -m “add readme”</span><br></pre></td></tr></table></figure>
<p>提交变更，通常使用 <code>-m</code> 参数在提交时也提交对本次提交的内容的附注。如没有使用此参数，Git 将会使用唤起你的编辑器以便键入提交信息。提交信息推荐参考 <a href="https://www.conventionalcommits.org/en/v1.0.0/">Convertional Commits</a><sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>，以让你的提交信息更通用，更规范，也更易读。</p>
<h1>Level 5 - Clone</h1>
<blockquote>
<p>Clone the repository at <a href="https://github.com/Gazler/cloneme">https://github.com/Gazler/cloneme</a>.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> </span><br></pre></td></tr></table></figure>
<h1>Level 6 Clone to folder</h1>
<blockquote>
<p>Clone the repository at <a href="https://github.com/Gazler/cloneme">https://github.com/Gazler/cloneme</a> to <code>my_cloned_repo</code>.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> … my_cloned_repo</span><br></pre></td></tr></table></figure>
<h1>Level 7 Ignore</h1>
<blockquote>
<p>The text editor ‘vim’ creates files ending in <code>.swp</code> (swap files) for all files that are currently open.  We don’t want them creeping into the repository.  Make this repository ignore those swap files which are ending in <code>.swp</code>.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim .gitignore</span><br></pre></td></tr></table></figure>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="comment">*.swp</span></span><br></pre></td></tr></table></figure>
<p>配置 <code>gitignore</code> 文件，对于一些临时文件和不希望提交的文件非常有用，尤其是编辑器/IDE环境会产生大量的配置文件，这时候可能不希望追溯这些文件的变更。在 VS 中的 Git 环境会默认写一个 <code>gitignore</code> 帮助你忽视掉不必要的 VS 产生的文件。</p>
<p>两个 <code>gitignore</code> 的参考：</p>
<ul>
<li><a href="https://github.com/github/gitignore">github/gitignore: A collection of useful .gitignore templates</a> <sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup></li>
<li><a href="https://www.toptal.com/developers/gitignore">gitignore.io - Create Useful .gitignore Files For Your Project</a> <sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup></li>
</ul>
<h1>Level 8 - Include</h1>
<blockquote>
<p>Notice a few files with the ‘.a’ extension.  We want git to ignore all but the ‘lib.a’ file.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim .gitignore</span><br></pre></td></tr></table></figure>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">*.<span class="keyword">a</span></span><br><span class="line">!lib.<span class="keyword">a</span></span><br></pre></td></tr></table></figure>
<h1>Level 9 - Status</h1>
<blockquote>
<p>There are some files in this repository, one of the files is untracked, which file is it?</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>
<h1>Level 10 - Number of files commited</h1>
<blockquote>
<p>There are some files in this repository, how many of the files will be committed?</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git status</span><br><span class="line">git diff --<span class="built_in">stat</span></span><br><span class="line">git diff --cached --<span class="built_in">stat</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>status</code> 可能是最简单的方式，但文件较多时就不方便了。参考 <a href="https://stackoverflow.com/questions/3162444/git-count-files-in-the-staged-index">git count files in the staged index - Stack Overflow</a><sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup>。</p>
<h1>Level 11 - Rm</h1>
<blockquote>
<p>A file has been removed from the working tree, however the file was not removed from the repository.  Find out what this file was and remove it.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -a -m “delete”</span><br></pre></td></tr></table></figure>
<h1>Level 12 - Rm cached</h1>
<blockquote>
<p>A file has accidentally been added to your staging area, find out which file and remove it from the staging area.  <em>NOTE</em> Do not remove the file from the file system, only from git.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">rm</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>git status</code> 时会提示该命令的使用。</p>
<h1>Level 13 - Stash</h1>
<blockquote>
<p>You’ve made some changes and want to work on them later. You should save them, but don’t commit them.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure>
<h1>Level 14 - Rename</h1>
<blockquote>
<p>We have a file called <code>oldfile.txt</code>. We want to rename it to <code>newfile.txt</code> and stage this change.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">mv</span> oldfile.txt newfile.txt</span><br></pre></td></tr></table></figure>
<p>这和 Linux 中的重命名是一样的，其实 Git 中有很多命令与 Linux 命令相似。</p>
<h1>Level 15 - Restructure</h1>
<blockquote>
<p>You added some files to your repository, but now realize that your project needs to be restructured.  Make a new folder named <code>src</code> and using Git move all of the .html files into this folder.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> src</span><br><span class="line">git <span class="built_in">mv</span> *.html  src/ </span><br></pre></td></tr></table></figure>
<h1>Level 16 - Log</h1>
<blockquote>
<p>You will be asked for the hash of most recent commit.  You will need to investigate the logs of the repository for this.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> -1</span><br></pre></td></tr></table></figure>
<h1>Level 17 - Tag</h1>
<p>We have a git repo and we want to tag the current commit with <code>new_tag</code>.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git tag new_tag</span><br></pre></td></tr></table></figure>
<h1>Level 18 - Push tags</h1>
<blockquote>
<p>There are tags in the repository that aren’t pushed into remote repository. Push them now.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push - -tags</span><br></pre></td></tr></table></figure>
<h1>Level 19 - Commit amend</h1>
<blockquote>
<p>The <code>README</code> file has been committed, but it looks like the file <code>forgotten_file.rb</code> was missing from the commit.  Add the file and amend your previous commit to include it.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit —amend —no-edit</span><br></pre></td></tr></table></figure>
<p>添加 <code>--no-edit</code> 参数不会弹出编辑窗口。</p>
<h1>Level 20 - Commit in furture</h1>
<blockquote>
<p>Commit your changes with the future date (e.g. tomorrow).</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -m “commit msg” —<span class="built_in">date</span> “2023-08-01”</span><br></pre></td></tr></table></figure>
<h1>Level 21 - Reset</h1>
<blockquote>
<p>There are two files to be committed.  The goal was to add each file as a separate commit, however both were added by accident.  Unstage the file <code>to_commit_second.rb</code> using the reset command (don’t commit anything).</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git restore --staged to_commit_second.rb</span><br></pre></td></tr></table></figure>
<h1>Level 22 - Reset soft</h1>
<blockquote>
<p>You committed too soon. Now you want to undo the last commit, while keeping the index.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --oneline</span><br><span class="line">git reset --soft fa51390</span><br></pre></td></tr></table></figure>
<h1>Level 23 - Checkout file</h1>
<blockquote>
<p>A file has been modified, but you don’t want to keep the modification.  Checkout the <code>config.rb</code> file from the last commit.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout — config.rb</span><br></pre></td></tr></table></figure>
<h1>Level 24 - Remote</h1>
<blockquote>
<p>This project has a remote repository.  Identify it.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote</span><br></pre></td></tr></table></figure>
<h1>Level 25 - Remote url</h1>
<blockquote>
<p>The remote repositories have a url associated to them.  Please enter the url of remote_location.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure>
<h1>Level 26 - Pull</h1>
<blockquote>
<p>You need to pull changes from your origin repository.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull origin master</span><br></pre></td></tr></table></figure>
<h1>Level 27 - Remote add</h1>
<blockquote>
<p>Add a remote repository called <code>origin</code> with the url <a href="https://github.com/githug/githug">https://github.com/githug/githug</a></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add origin https://github.com/githug/githug</span><br></pre></td></tr></table></figure>
<h1>Level 28 - Push</h1>
<blockquote>
<p>Your local master branch has diverged from the remote origin/master branch. Rebase your commit onto origin/master and push it to remote.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rebase origin/master </span><br><span class="line">git push</span><br></pre></td></tr></table></figure>
<h1>Level 29 - Diff</h1>
<blockquote>
<p>There have been modifications to the <code>app.rb</code> file since your last commit.  Find out which line has changed.</p>
</blockquote>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">diff</span> -U0</span><br></pre></td></tr></table></figure>
<p>Git diff 的信息并非实际行数，参考 <a href="https://stackoverflow.com/questions/24455377/git-diff-with-line-numbers-git-log-with-line-numbers">Git diff with line numbers (Git log with line numbers) - Stack Overflow</a><sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup>。</p>
<h1>Level 30 - Blame</h1>
<blockquote>
<p>Someone has put a password inside the file <code>config.rb</code> find out who it was.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git blame config.rb</span><br></pre></td></tr></table></figure>
<h1>Level 31 - Branch</h1>
<blockquote>
<p>You want to work on a piece of code that has the potential to break things, create the branch test_code.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch test_code</span><br></pre></td></tr></table></figure>
<h1>Level 32 - Checkout</h1>
<blockquote>
<p>Create and switch to a new branch called my_branch.  You will need to create a branch like you did in the previous level.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -b my_branch</span><br></pre></td></tr></table></figure>
<h1>Level 33 - Checkout tag</h1>
<blockquote>
<p>You need to fix a bug in the version 1.2 of your app. Checkout the tag <code>v1.2</code>.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout v1.2</span><br></pre></td></tr></table></figure>
<h1>Level 34 - Checkout tag over branch</h1>
<blockquote>
<p>You need to fix a bug in the version 1.2 of your app. Checkout the tag <code>v1.2</code> (Note: There is also a branch named <code>v1.2</code>).</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> —tags —online </span><br><span class="line">git checkout [commit-SHA]</span><br></pre></td></tr></table></figure>
<p>先找到这个 tag 的 SHA 值，如果你直接 checkout <code>v1.2</code> 将会变为 checkout 分支。</p>
<h1>Level 35 - Branch at</h1>
<blockquote>
<p>You forgot to branch at the previous commit and made a commit on top of it. Create branch test_branch at the commit before the last.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch test_branch HEAD~1</span><br></pre></td></tr></table></figure>
<h1>Level 36 - Delete branch</h1>
<blockquote>
<p>You have created too many branches for your project. There is an old branch in your repo called ‘delete_me’, you should delete it.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -d delete_me</span><br></pre></td></tr></table></figure>
<h1>Level 37 - Push branch</h1>
<blockquote>
<p>You’ve made some changes to a local branch and want to share it, but aren’t yet ready to merge it with the ‘master’ branch.  Push only ‘test_branch’ to the remote repository</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push origin test_branch</span><br></pre></td></tr></table></figure>
<h1>Level 38 - Merge</h1>
<blockquote>
<p>We have a file in the branch ‘feature’; Let’s merge it to the master branch.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git merge feature</span><br></pre></td></tr></table></figure>
<h1>Level 39 - Fetch</h1>
<blockquote>
<p>Looks like a new branch was pushed into our remote repository. Get the changes without merging them with the local repository</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git fetch</span><br></pre></td></tr></table></figure>
<h1>Level 40 - Rebase</h1>
<blockquote>
<p>We are using a git rebase workflow and the feature branch is ready to go into master. Let’s rebase the feature branch onto our master branch.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rebase master feature</span><br></pre></td></tr></table></figure>
<h1>Level 41 - Rebase onto</h1>
<blockquote>
<p>You have created your branch from <code>wrong_branch</code> and already made some commits, and you realise that you needed to create your branch from <code>master</code>. Rebase your commits onto <code>master</code> branch so that you don’t have <code>wrong_branch</code> commits.</p>
</blockquote>
<p>now: readme-update branch</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rebase —onto master wrong_branch readme-update</span><br></pre></td></tr></table></figure>
<p>关于 <code>rebase</code> 的使用，参考<a href="https://womanonrails.com/git-rebase-onto">Git rebase --onto an overview</a><sup class="footnote-ref"><a href="#fn7" id="fnref7">[7]</a></sup>。</p>
<h1>Level 42 - Repack</h1>
<blockquote>
<p>Optimise how your repository is packaged ensuring that redundant packs are removed.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git repack -d</span><br></pre></td></tr></table></figure>
<h1>Level 43 - Pick</h1>
<blockquote>
<p>Your new feature isn’t worth the time and you’re going to delete it. But it has one commit that fills in <code>README</code> file, and you want this commit to be on the master as well.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch</span><br><span class="line">git switch new-branch</span><br><span class="line">git <span class="built_in">log</span> —oneline — README.md</span><br><span class="line">git switch master</span><br><span class="line">git cherry-pick [commit-SHA]</span><br></pre></td></tr></table></figure>
<h1>Level 44 - Grep</h1>
<blockquote>
<p>Your project’s deadline approaches, you should evaluate how many TODOs are left in your code</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git grep TODO</span><br></pre></td></tr></table></figure>
<h1>Level 45 - Rename commit</h1>
<blockquote>
<p>Correct the typo in the message of your first (non-root) commit.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rebase -i HEAD~2</span><br><span class="line">% change `pick` to `reword` </span><br><span class="line">% fix the message <span class="keyword">then</span> save</span><br></pre></td></tr></table></figure>
<h1>Level 46 - Squash</h1>
<blockquote>
<p>You have committed several times but would like all those changes to be one commit.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rebase -i HEAD~4</span><br><span class="line"></span><br><span class="line">% change `pick` to `squash`</span><br><span class="line">% comment other messages</span><br></pre></td></tr></table></figure>
<p>这两个关卡都涉及了 <code>git rebase -i</code>，一个相当有用的命令，可以让你做出非常多的对过去提交的变更，Git Exercise 中有关于这个命令的更复杂的练习。</p>
<h1>Level 47 - Merge squash</h1>
<blockquote>
<p>Merge all commits from the long-feature-branch as a single commit.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git merge long-feature-branch —squash</span><br><span class="line">git commit -am <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<h1>Level 48 - Reorder</h1>
<blockquote>
<p>You have committed several times but in the wrong order. Please reorder your commits.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rebase -i HEAD~3</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">pick <span class="number">468</span>b4ea <span class="keyword">First</span> <span class="keyword">commit</span></span><br><span class="line">pick b497bf6 Third <span class="keyword">commit</span></span><br><span class="line">pick c4ebdaf <span class="keyword">Second</span> <span class="keyword">commit</span></span><br></pre></td></tr></table></figure>
<p>与 <code>git log</code> 不同，<code>git rebase -i</code> 模式下显示的提交顺序是最近的提交在末端，最初的提交在开始。</p>
<h1>Level 49 - Bisect</h1>
<blockquote>
<p>A bug was introduced somewhere along the way.  You know that running <code>ruby prog.rb 5</code> should output 15.  You can also run <code>make test</code>.  What are the first 7 chars of the hash of the commit that introduced the bug.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> —online </span><br><span class="line">% get the first commit </span><br><span class="line">git bisect start</span><br><span class="line">git bisect bad</span><br><span class="line">git bisect good [SHA]</span><br><span class="line">git bisect run make <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<p>这个命令对于查找哪个版本引入的变更非常有用，尤其是利用测试模块测试哪个版本引入 bug。我常常在公司的项目中要查找哪个版本开始改动，对于有明确提交信息的变更还相对好找，很多提交没有写明版本变更，找历史变更是非常痛苦的事情。</p>
<h1>Level 50 - Stage lines</h1>
<blockquote>
<p>You’ve made changes within a single file that belong to two different features, but neither of the changes are yet staged. Stage only the changes belonging to the first feature.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add -p </span><br><span class="line">e</span><br><span class="line">%remove second line </span><br></pre></td></tr></table></figure>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">+This change belongs <span class="built_in">to</span> <span class="keyword">the</span> <span class="keyword">first</span> feature</span><br><span class="line">+This change belongs <span class="built_in">to</span> <span class="keyword">the</span> <span class="keyword">second</span> feature</span><br></pre></td></tr></table></figure>
<p>这个命令也是一个非常丰富的命令， 可以将未暂存的一次大变更分为几个小变更，前面说到小步提交，但实际开发过程中其实很经常会习惯过去的方式一口气写完，这时候会出现这样的问题，可以通过这个命令来帮助你把一个大的变更拆解成几个小的变更。</p>
<h1>Level 51 - Find old branch</h1>
<blockquote>
<p>You have been working on a branch but got distracted by a major issue and forgot the name of it. Switch back to that branch.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure>
<h1>Level 52 - Revert</h1>
<blockquote>
<p>You have committed several times but want to undo the middle commit.<br>
All commits have been pushed, so you can’t change existing history.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> —oneline</span><br><span class="line">git revert [commit-SHA]</span><br></pre></td></tr></table></figure>
<h1>Level 53 -  Restore</h1>
<blockquote>
<p>You decided to delete your latest commit by running <code>git reset --hard HEAD^</code>.  (Not a smart thing to do.)  You then change your mind, and want that commit back.  Restore the deleted commit.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reflog</span><br><span class="line">git reset —hard HEAD@&#123;1&#125;</span><br></pre></td></tr></table></figure>
<h1>Level 54 - Conflict</h1>
<blockquote>
<p>You need to merge mybranch into the current branch (master). But there may be some incorrect changes in mybranch which may cause conflicts. Solve any merge-conflicts you come across and finish the merge.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git merge mybranch</span><br><span class="line">vim poem.txt</span><br></pre></td></tr></table></figure>
<h1>Level 55 - Submodule</h1>
<blockquote>
<p>You want to include the files from the following repo: <code>https://github.com/jackmaney/githug-include-me</code> into a the folder <code>./githug-include-me</code>. Do this without manually cloning the repo or copying the files from the repo into this repo.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git submodule add https://github.com/jackmaney/githug-include-me ./githug-include-me</span><br></pre></td></tr></table></figure>
<h1>参考资料</h1>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><a href="https://ndpsoftware.com/git-cheatsheet.html#loc=index;">Git Cheatsheet</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p><a href="https://www.conventionalcommits.org/en/v1.0.0/">Convertional Commits</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p><a href="https://github.com/github/gitignore">github/gitignore: A collection of useful .gitignore templates</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p><a href="https://www.toptal.com/developers/gitignore">gitignore.io - Create Useful .gitignore Files For Your Project</a> <a href="#fnref4" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn5" class="footnote-item"><p><a href="https://stackoverflow.com/questions/3162444/git-count-files-in-the-staged-index">git count files in the staged index - Stack Overflow</a> <a href="#fnref5" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn6" class="footnote-item"><p><a href="https://stackoverflow.com/questions/24455377/git-diff-with-line-numbers-git-log-with-line-numbers">Git diff with line numbers (Git log with line numbers) - Stack Overflow</a> <a href="#fnref6" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn7" class="footnote-item"><p><a href="https://womanonrails.com/git-rebase-onto">Git rebase --onto an overview</a> <a href="#fnref7" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>通过 nginx 设置外部访问服务器视频</title>
    <url>/zh-CN/nginx-config-video-support/</url>
    <content><![CDATA[<p>本文记录通过 nginx 设置外部访问服务器视频的过程。</p>
<span id="more"></span>
<p>添加一个 <code>video.conf</code>配置文件，用于放 mp4 文件 Nginx 配置（假设视频放在 /example/video/ 目录下）</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编辑配置文件</span></span><br><span class="line">vim /usr/<span class="keyword">local</span>/nginx/conf/video.conf</span><br><span class="line"><span class="comment"># 配置文件内容</span></span><br><span class="line">location /video/ &#123;</span><br><span class="line">       <span class="built_in">alias</span> /example/video/;</span><br><span class="line"></span><br><span class="line">       mp4;</span><br><span class="line">       mp4_buffer_size <span class="number">4</span>m;</span><br><span class="line">       mp4_max_buffer_size <span class="number">20</span>m;</span><br><span class="line"></span><br><span class="line">        sendfile <span class="keyword">on</span>;</span><br><span class="line">        tcp_nopush <span class="keyword">on</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 启用范围请求</span></span><br><span class="line">        add_header Accept-Ranges bytes;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 缓存控制</span></span><br><span class="line">        expires <span class="number">30</span>d;</span><br><span class="line">        add_header Cache-Control <span class="string">&quot;public, max-age=604800&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 限速</span></span><br><span class="line">        limit_rate_after <span class="number">10</span>m;</span><br><span class="line">        limit_rate <span class="number">2</span>m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置完成后，在主配置文件中引用该配置</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen <span class="number">80</span>;</span><br><span class="line">    server_name your-domain.com;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">location</span> <span class="title">/app1</span> &#123;</span><br><span class="line">        <span class="comment"># 其他配置...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">location</span> <span class="title">/app2</span> &#123;</span><br><span class="line">        <span class="comment"># 其他配置...</span></span><br><span class="line">    &#125;</span><br><span class="line">    include /usr/local/nginx/conf/video.conf</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重启 nginx</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart nginx</span><br></pre></td></tr></table></figure>
<p>如果报如下信息测试失败,那可能是因为你的 nginx 没有安装 mp4 模块，该模块不会默认安装</p>
<blockquote>
<p>nginx: [emerg] unknown directive “mp4” in /usr/local/nginx/conf/video.conf:5<br>
nginx: configuration file /usr/local/nginx/conf/nginx.conf test failed</p>
</blockquote>
<p>由于我的 nginx 是编译安装的，重新编译 nginx，查看目前的编译参数</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/usr/</span>local<span class="regexp">/nginx/</span>sbin/nginx -V</span><br></pre></td></tr></table></figure>
<p>如果有之前已经编译过的模块，重新编译时也要记得加上，例如下面的 ssl 模块</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="string">./configure</span>  <span class="params">--with-http_ssl_module</span> <span class="params">--with-http_mp4_module</span></span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>编译完成后，重新启动 nginx 就可以通过 <a href="http://your-domain.com/video/video.mp4">your-domain.com/video/video.mp4</a> 访问了。</p>
<h1>参考资料</h1>
<ul>
<li><a href="https://nginx.org/en/docs/http/ngx_http_mp4_module.html?_ga=2.51429225.1399780891.1753688554-752556077.1753688554">Module ngx_http_mp4_module</a></li>
<li><a href="https://docs.nginx.com/nginx/admin-guide/web-server/serving-static-content/#optimize-performance-for-serving-content">Serve Static Content | NGINX Documentation</a></li>
<li><a href="https://nginx.org/en/docs/http/ngx_http_core_module.html#limit_rate">Module ngx_http_core_module</a></li>
</ul>
]]></content>
      <categories>
        <category>技术杂谈</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>银河麒麟V10离线安装 Nginx 记录</title>
    <url>/zh-CN/nginx-kylin-install-ng/</url>
    <content><![CDATA[<p>本文记录在银河麒麟V10上离线安装 Nginx 的过程。</p>
<span id="more"></span>
<h1>检查依赖</h1>
<h2 id="gcc-make-等编译工具">gcc\make 等编译工具</h2>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">[root<span class="symbol">@localhost</span> ~]<span class="meta"># gcc --version</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>gcc (GCC) 7.3.0<br>
Copyright © 2017 Free Software Foundation, Inc.<br>
本程序是自由软件；请参看源代码的版权声明。本软件没有任何担保；<br>
包括没有适销性和某一专用目的下的适用性担保。</p>
</blockquote>
<p>已安装。</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">[root<span class="symbol">@localhost</span> ~]<span class="meta"># make --version</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>GNU Make 4.3<br>
为 x86_64-koji-linux-gnu 编译<br>
Copyright © 1988-2020 Free Software Foundation, Inc.<br>
许可证：GPLv3+：GNU 通用公共许可证第 3 版或更新版本<a href="http://gnu.org/licenses/gpl.html">http://gnu.org/licenses/gpl.html</a>。<br>
本软件是自由软件：您可以自由修改和重新发布它。<br>
在法律允许的范围内没有其他保证。</p>
</blockquote>
<p>已安装。</p>
<h2 id="检查-PCRE-库">检查 PCRE 库</h2>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">[root<span class="symbol">@localhost</span> ~]<span class="meta"># pcre-config --version</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>8.44</p>
</blockquote>
<p>已安装。</p>
<h2 id="检查-zlib-库">检查 zlib 库</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# <span class="built_in">ls</span> /usr/include/zlib.h 2&gt;/dev/null &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;✓ zlib 头文件存在&quot;</span> || <span class="built_in">echo</span> <span class="string">&quot;✗ zlib 头文件缺失&quot;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>/usr/include/zlib.h<br>
✓ zlib 头文件存在</p>
</blockquote>
<p>已安装。</p>
<h2 id="检查-OpenSSL-库">检查 OpenSSL 库</h2>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">openssl <span class="built_in">version</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>OpenSSL 1.1.1f  31 Mar 2020</p>
</blockquote>
<p>已安装。</p>
<p>我的服务器环境依赖均有安装，因此这里不需要安装依赖。需要安装依赖的读者可参照参考资料链接。</p>
<h1>安装 Nginx</h1>
<p><a href="https://nginx.org/en/download.html" title="Nginx 官网">Nginx 官网</a>下载所需版本的安装包。（下载没有标 Windows 的版本）</p>
<p><img src="/images/cnblog/3643699-20250517223832771-1640129185.png" alt="image"><br>
将文件通过工具上传到要安装的目录下。解压文件。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">tar</span> -zxvf nginx-<span class="number">1</span>.<span class="number">24</span>.<span class="number">0</span>.tar.gz</span><br></pre></td></tr></table></figure>
<p>切换到 nginx 的目录内。从源代码编译安装。这个过程中会输出一堆编译过程。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cd</span> nginx-<span class="number">1.24</span>.<span class="number">0</span>/</span><br><span class="line">./configure &amp;&amp; <span class="keyword">make</span> &amp;&amp; <span class="keyword">make</span> install</span><br></pre></td></tr></table></figure>
<p>验证安装 nginx 是否成功。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/usr/</span>local<span class="regexp">/nginx/</span>sbin/nginx -v</span><br></pre></td></tr></table></figure>
<blockquote>
<p>nginx version: nginx/1.24.0</p>
</blockquote>
<p>启动 nginx。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/usr/</span>local<span class="regexp">/nginx/</span>sbin/nginx</span><br></pre></td></tr></table></figure>
<p>检查是否启动成功。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">[root@localhost nginx-1.24.0]# curl http://localhost</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Welcome to nginx!<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-tag">html</span> &#123; <span class="attribute">color-scheme</span>: light dark; &#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-tag">body</span> &#123; <span class="attribute">width</span>: <span class="number">35em</span>; <span class="attribute">margin</span>: <span class="number">0</span> auto;</span></span><br><span class="line"><span class="language-css"><span class="attribute">font-family</span>: Tahoma, Verdana, Arial, sans-serif; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Welcome to nginx!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>If you see this page, the nginx web server is successfully installed and</span><br><span class="line">working. Further configuration is required.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>For online documentation and support please refer to</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://nginx.org/&quot;</span>&gt;</span>nginx.org<span class="tag">&lt;/<span class="name">a</span>&gt;</span>.<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">Commercial support is available at</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://nginx.com/&quot;</span>&gt;</span>nginx.com<span class="tag">&lt;/<span class="name">a</span>&gt;</span>.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">em</span>&gt;</span>Thank you for using nginx.<span class="tag">&lt;/<span class="name">em</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>输出这个就是成功了，如果你把它复制到 html 里打开，就是我们看到的 nginx 欢迎页。<br>
停止 nginx。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/usr/</span>local<span class="regexp">/nginx/</span>sbin/nginx -s stop</span><br></pre></td></tr></table></figure>
<h1>配置 nginx 为系统服务</h1>
<p>编辑 service 文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /usr/lib/systemd/system/nginx.service</span><br></pre></td></tr></table></figure>
<p>保存下面内容到 service 文件中。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=nginx service</span><br><span class="line"><span class="attr">After</span>=network.target</span><br><span class="line"></span><br><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="attr">Type</span>=forking</span><br><span class="line"><span class="attr">ExecStart</span>=/usr/local/nginx/sbin/nginx</span><br><span class="line"><span class="attr">ExecReload</span>=/usr/local/nginx/sbin/nginx -s reload</span><br><span class="line"><span class="attr">ExecStop</span>=/usr/local/nginx/sbin/nginx -s stop</span><br><span class="line"><span class="attr">PrivateTmp</span>=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="section">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span>=multi-user.target</span><br></pre></td></tr></table></figure>
<p>重新加载 systemd 的单元配置文件。</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">systemctl daemon-reload</span></span><br></pre></td></tr></table></figure>
<p>启动 nginx 服务。</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">systemctl <span class="literal">start</span> nginx.service</span><br></pre></td></tr></table></figure>
<p>如果提示下面这段，可能是你前面启动 nginx 忘记停掉了。</p>
<blockquote>
<p>Job for nginx.service failed because the control process exited with error code.<br>
See “systemctl status nginx.service” and “journalctl -xe” for details.</p>
</blockquote>
<p>查看服务状态。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">systemctl <span class="keyword">status</span> nginx.service</span><br></pre></td></tr></table></figure>
<p>将服务配置为开机启动。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> nginx.service</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Created symlink /etc/systemd/system/multi-user.target.wants/nginx.service → /usr/lib/systemd/system/nginx.service.</p>
</blockquote>
<p>查看配置文件位置。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx -t</span><br><span class="line"><span class="comment"># 通过返回结果查看配置文件 这个命令其实是用于检测配置文件是否合法</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok<br>
nginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful</p>
</blockquote>
<h1>参考资料</h1>
<p><a href="https://blog.csdn.net/weixin_43102784/article/details/144716236" title="3.银河麒麟V10 离线安装Nginx">3.银河麒麟V10 离线安装Nginx</a></p>
]]></content>
      <categories>
        <category>部署记录</category>
      </categories>
      <tags>
        <tag>Kylin</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>修改 Nginx 启动用户</title>
    <url>/zh-CN/nginx-modify-start-user/</url>
    <content><![CDATA[<p>本文记录修改 Nginx 启动用户的过程，等保整改可参考。</p>
<span id="more"></span>
<p>使用 root 用户编译安装，默认用户为 root，根据要求应调整为其他用户</p>
<ol>
<li>配置用户和用户组</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">groupadd -r nginx</span><br><span class="line">useradd -r -g nginx -s /sbin/nologin -d /var/nginx -c <span class="string">&quot;Nginx web server&quot;</span> nginx</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>调整权限（以下根据实际情况调整路径）</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 调整日志目录权限</span></span><br><span class="line"><span class="built_in">chown</span> -R nginx:nginx /data/logs/nginx</span><br><span class="line"><span class="comment"># 调整默认的日志目录权限</span></span><br><span class="line"><span class="built_in">chown</span> -R nginx:nginx /usr/local/nginx/logs</span><br></pre></td></tr></table></figure>
<p>根据参考资料，nginx 检查这个权限在读取配置文件之前，根据实践，Nginx 1.24.0 版本如果不给相应权限，会启动失败<br>
3. 调整 Nginx 配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure>
<p>默认是注释了 user 配置，取消注释，改为你需要修改的启动用户</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#user  nobody;</span><br><span class="line">user nginx；</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>调整 Nginx 服务配置文件</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /lib/systemd/system/nginx.service</span><br><span class="line"><span class="comment"># 在 [Service] 块下添加这两行</span></span><br><span class="line">User=nginx</span><br><span class="line">Group=nginx</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>重启 Nginx</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart nginx</span><br></pre></td></tr></table></figure>
<p>如果启动失败，一般是由于某些文件没有权限导致的，使用 <code>systemctl status nginx</code> 可以看到失败原因，和无权限的具体内容<br>
<img src="/images/cnblog/3643699-20250730170634606-1962487410.png" alt="失败示例"><br>
6. 验证是否生效</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps aux | grep nginx</span><br></pre></td></tr></table></figure>
<p><img src="/images/cnblog/3643699-20250730164704779-1364706735.png" alt="更改用户生效图片"></p>
<hr>
<p>参考资料：<br>
<a href="https://stackoverflow.com/questions/34258894/nginx-still-try-to-open-default-error-log-file-even-though-i-set-nginx-config-fi">linux - Nginx still try to open default error log file even though I set nginx config file while reloading - Stack Overflow</a></p>
]]></content>
      <categories>
        <category>等保整改</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>银河麒麟V10 docker 离线安装 opengauss 数据库（单节点部署）</title>
    <url>/zh-CN/opengauss-kylin-install-opengauss-by-docker/</url>
    <content><![CDATA[<p>本文记录在银河麒麟V10上使用 docker 离线安装 opengauss 数据库的过程。</p>
<span id="more"></span>
<ol>
<li>准备合适的 docker 镜像</li>
<li>通过文件传输工具将镜像传输至服务器</li>
<li>加载镜像文件</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker load -i opengauss_3.0.0.tar</span><br></pre></td></tr></table></figure>
<p>正常应该是输出类似这样的内容：</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span><span class="params">f37ca73c74f:</span> Loading layer [<span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">&gt;</span>]  <span class="number">75.16</span>MB<span class="symbol">/75.16MB</span></span><br><span class="line"><span class="params">fbf2d42d54b9:</span> Loading layer [<span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">&gt;</span>]   <span class="number">57.7</span>MB<span class="symbol">/57.7MB</span></span><br><span class="line"><span class="params">c777acc6f953:</span> Loading layer [<span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">&gt;</span>]  <span class="number">20.48</span>kB<span class="symbol">/20.48kB</span></span><br><span class="line"><span class="params">a8d219ac51aa:</span> Loading layer [<span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">&gt;</span>]  <span class="number">337.4</span>MB<span class="symbol">/337.4MB</span></span><br><span class="line"><span class="number">63</span><span class="params">f854361eb8:</span> Loading layer [<span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">==</span><span class="operator">&gt;</span>]  <span class="number">20.99</span>kB<span class="symbol">/20.99kB</span></span><br><span class="line">Loaded <span class="params">image:</span> enmotech<span class="operator">/</span>opengauss:<span class="number">5.0</span>.<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>如果提示下面的内容，可能是你的 docker 没有启动</p>
<blockquote>
<p>Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>验证镜像是否加载成功，返回如下情况即为成功，下面的 <code>enmotech/opengauss</code>是你的镜像名称，不同地方下载的镜像该名称可能不同，这个名称后面会用到</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker images <span class="built_in">ls</span></span><br><span class="line"><span class="comment"># 下面这个是正常输出</span></span><br><span class="line">REPOSITORY           TAG       IMAGE ID       CREATED       SIZE</span><br><span class="line">enmotech/opengauss   5.0.0     c69c8aebefe8   2 years ago   465MB</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>创建挂载数据目录</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /example/opengauss/data</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>启动容器，可以根据你的需要修改容器名称（<code>--name</code> 后面的参数），修改数据库密码，修改映射端口（<code>-p</code>参数的冒号前面的端口）</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run \</span><br><span class="line">&gt; --name opengauss \</span><br><span class="line">&gt; --privileged=<span class="literal">true</span> \</span><br><span class="line">&gt; -d \</span><br><span class="line">&gt; -e GS_PASSWORD=your-password \</span><br><span class="line">&gt; -p 1234:5432 \</span><br><span class="line">&gt; -v /example/opengauss/data:/var/lib/opengauss/data \</span><br><span class="line">&gt; enmotech/opengauss:5.0.0</span><br></pre></td></tr></table></figure>
<p>成功后会输出一长串容器ID（如果成功后又快速退出了也会，这个不代表已经成功了）<br>
7. 查看容器运行状态，如果 <code>STATUS</code> 是 UP，就是启动成功了。如果你看到的是 Exited，那说明启动后又退出了，没有成功跑起来。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE                      COMMAND                   CREATED        STATUS      PORTS                                         NAMES</span><br><span class="line">31858d593b66   enmotech/opengauss:5.0.0   <span class="string">&quot;entrypoint.sh gauss…&quot;</span>   2 months ago   Up 4 days   0.0.0.0:14869-&gt;5432/tcp, :::1234-&gt;5432/tcp   opengauss</span><br></pre></td></tr></table></figure>
<details>
<summary>一种可能的错误情况</summary>
如果你看到的是 Exited，那说明启动后又退出了，没有成功跑起来。
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">docker</span> ps -a | grep opengauss</span><br><span class="line"><span class="attribute">CONTAINER</span> ID   IMAGE          COMMAND           CREATED          STATUS                      PORTS     NAMES</span><br><span class="line"><span class="attribute">1b87a6e93e3f</span>   <span class="number">478</span>a00294137   <span class="string">&quot;entrypoint.sh&quot;</span>   <span class="number">35</span> seconds ago   Exited (<span class="number">1</span>) <span class="number">34</span> seconds ago             opengauss</span><br></pre></td></tr></table></figure>
<p>可以用以下命令查看情况：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker logs 容器ID</span></span><br><span class="line"><span class="attribute">docker</span> logs <span class="number">1</span>b876e93e3f</span><br></pre></td></tr></table></figure>
<p>如果你得到的是如下的提示：</p>
<blockquote>
<p>Primary host is empty, at least one primary and one standby host are needed</p>
</blockquote>
<p>那有可能是你的镜像不支持单节点部署，建议你更换镜像文件</p>
</details>
<ol start="8">
<li>通过以下命令就可以进入容器了</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it opengauss /bin/bash</span><br></pre></td></tr></table></figure>
<p>如果你觉得这个命令太长，可以配置一个简化命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim ~/.bashrc</span><br><span class="line"><span class="comment"># 添加别名</span></span><br><span class="line"><span class="built_in">alias</span> enter-gauss=<span class="string">&#x27;docker exec -it opengauss /bin/bash&#x27;</span></span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>
<p>以上步骤完成后，你就可以直接使用 <code>enter-gauss</code> 进入容器</p>
<ol start="9">
<li>openGauss安装时默认会创建omm超级用户，容器内切换到该用户</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">su - omm</span><br></pre></td></tr></table></figure>
<ol start="10">
<li>输入 <code>gsql</code> 就可以进入数据库了，之后的赋权操作都需要在此处进行，<code>\q</code> 可以退出数据库<br>
<strong>注意：默认是不允许 omm 用户远程连接数据库的</strong><br>
可能会提示以下内容：</li>
</ol>
<blockquote>
<p>Forbid remote connection with initial user.</p>
</blockquote>
<h1>参考资料</h1>
<ul>
<li><a href="https://docs.opengauss.org/zh/docs/5.0.0/docs/InstallationGuide/%E5%8D%95%E8%8A%82%E7%82%B9%E5%AE%89%E8%A3%85_%E5%AE%B9%E5%99%A8.html">单节点安装 容器 | openGauss文档 | openGauss社区</a></li>
</ul>
]]></content>
      <categories>
        <category>部署记录</category>
      </categories>
      <tags>
        <tag>Kylin</tag>
        <tag>OpenGauss</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenGauss 设置时区</title>
    <url>/zh-CN/opengauss-timezone/</url>
    <content><![CDATA[<p>OpenGauss 数据库设置时区记录。</p>
<span id="more"></span>
<p>opengauss的默认时区为设置为 GMT。本文环境为 docker 安装的 opengauss。<br>
在数据库中执行语句查询所需时区名字。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> PG_TIMEZONE_NAMES <span class="keyword">where</span> utc_offset <span class="operator">=</span> <span class="string">&#x27;08:00:00&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>查询结果如下：<br>
<img src="/images/cnblog/3643699-20250525104434818-1657651957.png" alt="image"><br>
查找数据库的数据目录路径(在数据库中执行）。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">omm<span class="operator">=</span># <span class="keyword">SHOW</span> data_directory;</span><br><span class="line">     data_directory</span><br><span class="line"><span class="comment">-------------------------</span></span><br><span class="line"> <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>opengauss<span class="operator">/</span>data</span><br><span class="line">(<span class="number">1</span> <span class="type">row</span>)</span><br></pre></td></tr></table></figure>
<p>在 docker 中执行以下语句设置时区。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gs_guc <span class="built_in">set</span> -D datadir -c <span class="string">&quot;TimeZone=&#x27;Asia/Shanghai&#x27;&quot;</span></span><br><span class="line"><span class="comment"># 将 datadir 替换为上面查询出来的路径，例如</span></span><br><span class="line">gs_guc <span class="built_in">set</span> -D /var/lib/opengauss/data -c <span class="string">&quot;TimeZone=&#x27;Asia/Shanghai&#x27;&quot;</span></span><br></pre></td></tr></table></figure>
<p>执行成功后可以看到如下图示：<br>
<img src="/images/cnblog/3643699-20250529224721854-95229863.png" alt="image"><br>
按照官方的操作，执行完成后需要重启数据库生效。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gs_om -t stop &amp;&amp; gs_om -t start</span><br></pre></td></tr></table></figure>
<p>但我的 docker 镜像中没有包含这个命令集，所以使用是重启 docker 来重启数据库。<br>
也可以直接修改配置文件 <code>postgresql.conf</code>(这个文件在容器数据/var/lib/opengauss的挂载路径下面），然后重启。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">655 timezone = &#x27;Asia/Shanghai&#x27;</span><br></pre></td></tr></table></figure>
<p>重启后就可以看到数据库时间变为CST时间了。</p>
<h1>参考资料</h1>
<ul>
<li>
<p><a href="https://docs.opengauss.org/zh/docs/5.0.0/docs/DatabaseReference/PG_TIMEZONE_NAMES.html" title="Pg Timezone Names | openGauss文档 | openGauss社区">Pg Timezone Names | openGauss文档 | openGauss社区</a></p>
</li>
<li>
<p><a href="https://docs.opengauss.org/zh/docs/5.0.0/docs/DatabaseReference/%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A0%BC%E5%BC%8F%E5%8C%96.html" title="区域和格式化 | openGauss文档 | openGauss社区">区域和格式化 | openGauss文档 | openGauss社区</a></p>
</li>
<li>
<p><a href="https://docs.opengauss.org/zh/docs/5.0.0/docs/DatabaseReference/%E9%87%8D%E8%AE%BE%E5%8F%82%E6%95%B0.html#zh-cn_topic_0283137176_zh-cn_topic_0237121562_zh-cn_topic_0059777490_t290c8f15953843db8d8e53d867cd893d" title="重设参数 | openGauss文档 | openGauss社区">重设参数 | openGauss文档 | openGauss社区</a></p>
</li>
<li>
<p><a href="http://https://docs.opengauss.org/zh/docs/7.0.0-RC1/docs/InstallationGuide/%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E5%AE%89%E8%A3%85.html" title="容器镜像安装 | openGauss文档 | openGauss社区">容器镜像安装 | openGauss文档 | openGauss社区</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>OpenGauss</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-使用selenium模块控制浏览器</title>
    <url>/zh-CN/python-use-selenium-control-browser/</url>
    <content><![CDATA[<p>本文简要介绍在Python中如何使用 selenium 模块控制浏览器获取动态页面元素。包括获取信息，点击链接，下拉框选取。毕设通过本方式自动化获取数据，简要记录。更新了没保存好被吞掉的部分…</p>
<span id="more"></span>
<p>部分网页在右键使用查看源代码与检查元素时看到的内容是不相同的，上下页的切换也不会导致页面链接发生变化，这一类网页仅仅依靠获取网页源代码的方式是无法自动获取页面元素的。Python中的selenium模块可以模拟手动操作浏览器的过程，虽然该模块主要用于编写功能/验收测试，用来获取动态网页的数据也很方便。</p>
<h1>安装</h1>
<h2 id="下载-selenium-安装包">下载 selenium 安装包</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install selenium</span><br></pre></td></tr></table></figure>
<h2 id="安装-WebDriver">安装 WebDriver</h2>
<p>将要模拟的浏览器的 webdrver 下载至 Python 所在的位置。</p>
<p>（注意：该驱动与浏览器版本相关，下载前请先确认自己的浏览器版本）</p>
<ul>
<li>
<p>Firefox: <a href="https://github.com/mozilla/geckodriver/releases">Releases · mozilla/geckodriver</a></p>
</li>
<li>
<p>Chrome: <a href="https://chromedriver.chromium.org/downloads">Downloads - ChromeDriver - WebDriver for Chrome</a></p>
</li>
</ul>
<h1>启动浏览器</h1>
<h2 id="导入模块">导入模块</h2>
<p>导入该模块通常使用以下语句：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br></pre></td></tr></table></figure>
<h2 id="启动浏览器">启动浏览器</h2>
<p>对不同的浏览器，使用webdriver启动浏览器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">browser = webdriver.Firefox()</span><br><span class="line"><span class="comment"># browser = webdriver.Chrome()</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>get()</code> 方法访问指定链接：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">driver.get(<span class="string">&quot;YOUR_URL&quot;</span>)</span><br></pre></td></tr></table></figure>
<h1>页面元素定位</h1>
<p>使用 <code>find_element_*</code> 和 <code>find_elements_*</code> 查找页面中的 WebDriver对象，前者返回第一个匹配元素，后者返回所有匹配元素，形式为列表。</p>
<p>以下是 WebDriver 方法，仅列出查找第一个匹配元素的方法名，查找所有元素的方法明只需在 <code>element</code> 后加上 <code>s</code> 即可。</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>定位对象</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>find_element_by_class_name(name)</code></td>
<td>根据 <code>class</code> 名定位</td>
</tr>
<tr>
<td><code>find_element_by_css_selector(selector)</code></td>
<td>根据 CSS 选择器定位</td>
</tr>
<tr>
<td><code>find_element_by_id(id)</code></td>
<td>根据元素的 <code>id</code> 属性定位</td>
</tr>
<tr>
<td><code>find_element_by_link_text(text)</code></td>
<td>根据文本定位</td>
</tr>
<tr>
<td><code>find_element_by_partial_link_text(text)</code></td>
<td>根据文本的子字符串匹配</td>
</tr>
<tr>
<td><code>find_element_by_name(name)</code></td>
<td>根据元素的 <code>name</code> 属性定位</td>
</tr>
<tr>
<td><code>find_element_by_tag_name(name)</code></td>
<td>根据标签名定位</td>
</tr>
<tr>
<td><code>find_element_by_xpath(path)</code></td>
<td>根据 Xpath 定位</td>
</tr>
</tbody>
</table>
<p>以上所有的元素定位，若不能找到匹配元素，将抛出 <code>NoSuchElementException</code> 异常。</p>
<p>个人倾向于使用 CSS 选择器的方式进行元素定位，虽然完全不懂前端，但其实通过浏览器的检查元素可以很轻易地获取 CSS选择器的语法，同时参照 <a href="https://www.w3school.com.cn/cssref/css_selectors.asp">CSS选择器参考手册</a> 就能很容易通过 CSS 选择器进行定位。</p>
<p>通过 浏览器快速获取 CSS 选择器语法的方式是：</p>
<ol>
<li>
<p>打开页面右键菜单中的检查元素窗口；</p>
</li>
<li>
<p>点击左上角的选择元素工具；</p>
</li>
<li>
<p>在页面上选取需要定位的元素；</p>
</li>
<li>
<p>这时 HTML 代码的浏览窗格中将定位到所选取元素的 HTML 代码位置；</p>
</li>
<li>
<p>查看代码浏览窗格的下方，以 <code>&gt;</code> 连接的形式呈现了子代以及每一级父代的 CSS 选择器语法。</p>
</li>
</ol>
<p>例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">&quot;el-table_1_column_2  &quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cell&quot;</span>&gt;</span>data<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>定位到 data 的 CSS 选择器语法为：<code>td.el-table_1_column_2 div</code> ，上面提到的定位方法使用方式如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">elem = browser.fidn_element_by_css_selector(<span class="string">&#x27;td.el-table_1_column_2 div&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>此时 <code>elem</code> 为定位到的 WebElement 对象，还不是我们想要的内容。</p>
<h1>获取内容</h1>
<p>可以通过 WebElement 对象提供的属性和方法访问对象的信息，如下表所示：</p>
<table>
<thead>
<tr>
<th>属性或方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>tag_name</code></td>
<td>标签名</td>
</tr>
<tr>
<td><code>get_attribute()</code></td>
<td>属性值</td>
</tr>
<tr>
<td><code>text</code></td>
<td>文本</td>
</tr>
<tr>
<td><code>clear()</code></td>
<td>清除文本字段或文本区域输入的文本</td>
</tr>
<tr>
<td><code>is_displayed()</code></td>
<td>根据文本的子字符串匹配</td>
</tr>
<tr>
<td><code>find_element_by_name(name)</code></td>
<td>元素是否可见</td>
</tr>
<tr>
<td><code>is_enabled()</code></td>
<td>元素是否启用</td>
</tr>
<tr>
<td><code>is_selected()</code></td>
<td>选框是否选中</td>
</tr>
<tr>
<td><code>location</code></td>
<td>元素在页面上的位置</td>
</tr>
</tbody>
</table>
<p>如上文提到的 data 信息的获取可通过 text 属性提取：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(elem.text)</span><br></pre></td></tr></table></figure>
<p>但对于一些隐藏的 CSS 元素，尽管页面上可以找到该元素，但无法通过 <code>text</code> 方式获取，如下面这段 HTML 代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">&quot;el-table_1_column_1   is-hidden&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cell&quot;</span>&gt;</span>data1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>直接使用 text 属性，获取到的内容将为空白，需要使用 <code>get_attribute()</code> 方法，如下列代码所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(elem.get_attribute(<span class="string">&quot;textContent&quot;</span>))</span><br></pre></td></tr></table></figure>
<p>具体可参考 <a href="https://www.w3schools.com/jsref/prop_node_textcontent.asp">HTML DOM textContent Property</a> 。</p>
<h1>点击页面</h1>
<p>WebElement 中还提供了 <code>click()</code> 方法，通过该方法可模拟手动操作鼠标对页面元素进行点击，如上下页的切换等。在页面元素无法点击的情况下（如末页的下一页按钮被禁用），该方法不会执行任何操作，也不会有异常返回。以下是示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">browser.find_element_by_css_selector(<span class="string">&#x27;button.searchBtr&#x27;</span>).click()</span><br></pre></td></tr></table></figure>
<h1>下拉框选取</h1>
<p>webdriver 中提供了 select 模块用于下拉框的选取，以下是导入该模块的语句的两种方式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> Select</span><br><span class="line"><span class="keyword">from</span> selecnium.webdriver.support.select <span class="keyword">import</span> Select</span><br></pre></td></tr></table></figure>
<p>使用时将查找的元素作为 <code>Select()</code> 的参数，下拉框的选取有以下三种方式：</p>
<ul>
<li>
<p><code>select_by_index(index)</code> ：通过索引选取，即第几个元素，索引编号从 0 开始；</p>
</li>
<li>
<p><code>select_by_value(value)</code>： 通过 <code>value</code> 属性值选取；</p>
</li>
<li>
<p><code>select_by_visible_text(text)</code>： 通过可见文本选取，即该下拉菜单中显示值。</p>
</li>
</ul>
<p>以下是示例 HTML代码段：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;listquerybox&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;selectTitle&quot;</span> <span class="attr">class</span>=<span class="string">&quot;selectTitle&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>所属行政区：<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">select</span> <span class="attr">class</span>=<span class="string">&quot;area-select&quot;</span> <span class="attr">id</span>=<span class="string">&quot;pid&quot;</span> <span class="attr">onchange</span>=<span class="string">&quot;gradeChange()&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>&gt;</span>--省--<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;110000&quot;</span>&gt;</span>北京市<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;120000&quot;</span>&gt;</span>天津市<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            ...</span><br><span class="line">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过三种不同方式选取 北京市 选项如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Select(browser.find_element_by_css_selector(<span class="string">&#x27;select#pid.area-select&#x27;</span>)).select_by_index(<span class="number">1</span>)</span><br><span class="line">Select(browser.find_element_by_css_selector(<span class="string">&#x27;select#pid.area-select&#x27;</span>)).select_by_value(<span class="string">&#x27;110000&#x27;</span>)</span><br><span class="line">Select(browser.find_element_by_css_selector(<span class="string">&#x27;select#pid.area-select&#x27;</span>)).select_by_visible_text(<span class="string">&#x27;北京市&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>在下拉框中的选择值查找失败时，将抛出 <code>NoSuchElementException</code> 异常。</p>
<h1>关闭浏览器</h1>
<p>在信息获取完后，应使用 <code>quit()</code> 关闭浏览器，否则通过 selenium 启动的浏览器将一直处于活动运行状态。以下是包括浏览器常用的操控按钮示例。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">browser.quit() <span class="comment"># 点击 关闭浏览器 按钮</span></span><br><span class="line">browser.back() <span class="comment"># 点击 返回 按钮</span></span><br><span class="line">browser.forward() <span class="comment"># 点击 前进 按钮</span></span><br><span class="line">browser.refresh() <span class="comment"># 点击 刷新 按钮</span></span><br></pre></td></tr></table></figure>
<h1>参考资料</h1>
<ul>
<li>
<p>《Python编程快速上手——让繁琐工作自动化》</p>
</li>
<li>
<p><a href="https://python-selenium-zh.readthedocs.io/zh_CN/latest/">selenium-python中文文档</a></p>
</li>
<li>
<p><a href="https://stackoverflow.com/questions/61383136/how-to-read-hidden-text-in-python-by-using-selenium">html - how to read hidden text in python by using selenium? - Stack Overflow</a></p>
</li>
<li>
<p><a href="https://www.selenium.dev/selenium/docs/api/py/webdriver_support/selenium.webdriver.support.select.html#module-selenium.webdriver.support.select">selenium.webdriver.support.select — Selenium 3.14 documentation</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>银河麒麟V10离线安装 tomcat 9 记录</title>
    <url>/zh-CN/tomcat-kylin-install-tomcat9/</url>
    <content><![CDATA[<p>本文记录在银河麒麟V10上离线安装 tomcat 9 的过程。</p>
<span id="more"></span>
<h1>下载安装</h1>
<ol>
<li>下载对应安装版本的安装包<br>
<a href="https://archive.apache.org/dist/tomcat/">Apache Archive Distribution Directory</a></li>
<li>借助传输工具上传安装包至服务器</li>
<li>解压 tomcat 安装包</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -zxvf apache-tomcat-9.0.93.tar.gz</span><br></pre></td></tr></table></figure>
<h1>日志路径配置</h1>
<ol>
<li>创建 tomcat 日志文件夹路径</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> tomcat-logs</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>修改日志路径配置</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 切换到 tomcat 的 conf 目录</span></span><br><span class="line"><span class="built_in">cd</span> /tomcat/conf</span><br><span class="line"><span class="comment"># 修改日志配置文件</span></span><br><span class="line">vim logging.properties</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>修改下面几个地方</li>
</ol>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">1catalina.org.apache.juli.AsyncFileHandler.directory</span> = <span class="string">/data/tomcat-logs</span></span><br><span class="line"><span class="attr">2localhost.org.apache.juli.AsyncFileHandler.directory</span> = <span class="string">/data/tomcat-logs</span></span><br><span class="line"><span class="attr">3manager.org.apache.juli.AsyncFileHandler.directory</span> = <span class="string">/data/tomcat-logs</span></span><br><span class="line"><span class="attr">4host-manager.org.apache.juli.AsyncFileHandler.directory</span> = <span class="string">/data/tomcat-logs</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>修改 <code>catalina.sh</code> 以方便观察运行情况</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 切换到 tomcat 的 bin 目录</span></span><br><span class="line"><span class="built_in">cd</span> /example/tomcat/bin</span><br><span class="line">vim catalina.sh</span><br><span class="line"><span class="comment"># 修改 catalina.sh 在前面追加，用于查看 tomcat 运行时日志</span></span><br><span class="line">CATALINA_OUT=/data/tomcat-logs/catalina.out</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>第4步完成后，<code>catalina.out</code>会无限写入，长期运行可能导致运行日志较多，配置 <code>logrotate</code> 自动轮转。以下配置可配置每日切割轮转，保留30天日志。你可以将你需要的配置轮转规则发给AI，让其生成相关的配置项，然后比对参考资料进行核对</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加一个logrotate文件，最后的 tomcat-prod 设置为你方便识别的名字即可</span></span><br><span class="line">vim /etc/logrotate.d/tomcat-prod</span><br><span class="line">/data/tomcat-logs/catalina.out &#123;</span><br><span class="line">        daily</span><br><span class="line">        rotate 30</span><br><span class="line">        copytruncate</span><br><span class="line">        compress</span><br><span class="line">        delaycompress</span><br><span class="line">        missingok</span><br><span class="line">        notifempty</span><br><span class="line">        dateext</span><br><span class="line">        dateformat -%Y%m%d</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>JVM的运行参数优化配置</h1>
<p>修改 <code>catalina.sh</code> 写入下面参数</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="attribute">JAVA_OPTS</span>=<span class="string">&quot;<span class="variable">$JAVA_OPTS</span> <span class="variable">$JSSE_OPTS</span> -server -Xmx16G -Xms16G -XX:MaxDirectMemorySize=4G -XX:+UseG1GC -XX:ConcGCThreads=16  -XX:ParallelGCThreads=16&quot;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：根据官方文档，这并非推荐的配置的方式，推荐做法是修改 <a href="http://setenv.sh">setenv.sh</a>，因本次部署时未实践，故不做记录，请参考参考资料2</p>
</blockquote>
<h1>修改启动端口号</h1>
<p>若不想使用默认端口，可在 <code>server.xml</code>修改启动端口</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8089&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;org.apache.coyote.http11.Http11NioProtocol&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">connectionTimeout</span>=<span class="string">&quot;20000&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">maxParameterCount</span>=<span class="string">&quot;1000&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">maxThreads</span>=<span class="string">&quot;128&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">maxConnections</span>=<span class="string">&quot;10000&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">acceptCount</span>=<span class="string">&quot;256&quot;</span></span></span><br><span class="line"><span class="tag">              /&gt;</span></span><br></pre></td></tr></table></figure>
<h1>配置为服务</h1>
<p>查看 Java 安装位置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">readlink</span> -f $(<span class="built_in">which</span> java) | sed <span class="string">&#x27;s|/bin/java||&#x27;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.312.b07-10.ky10.x86_64/jre</p>
</blockquote>
<p>配置为服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /usr/lib/systemd/system/tomcat.service</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Systemd unit file for default tomcat</span><br><span class="line">#</span><br><span class="line"># To create clones of this service:</span><br><span class="line"># DO NOTHING, use tomcat@.service instead.</span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=Tomcat service</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">Environment=&quot;JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.312.b07-10.ky10.x86_64/jre &quot;</span><br><span class="line">User=root</span><br><span class="line">Group=root</span><br><span class="line">ExecStart=/example/tomcat/bin/startup.sh</span><br><span class="line">ExecStop=/example/tomcat/bin/shutdown.sh</span><br><span class="line">ExecReload=/usr/bin/kill -s SIGHUP $MAINPID</span><br><span class="line">PrivateTmp=true</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>
<p>启动服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重载配置</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line"><span class="comment"># 启动服务</span></span><br><span class="line">systemctl start tomcat.service</span><br><span class="line"><span class="comment"># 查看服务状态</span></span><br><span class="line">systemctl status tomcat.service</span><br><span class="line"><span class="comment"># 创建开机启动</span></span><br><span class="line">systemctl <span class="built_in">enable</span> tomcat.service</span><br></pre></td></tr></table></figure>
<h1>参考资料</h1>
<ol>
<li><a href="https://linux.die.net/man/8/logrotate">logrotate(8) - Linux man page</a></li>
<li><a href="https://cwiki.apache.org/confluence/display/TOMCAT/Memory#Memory-Q1">Memory - Apache Tomcat - Apache Software Foundation</a></li>
</ol>
]]></content>
      <categories>
        <category>部署记录</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
        <tag>Kylin</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat 设置 Windows 黑窗口名称</title>
    <url>/zh-CN/tomcat-set-title/</url>
    <content><![CDATA[<p>Tomcat 设置 windows 黑窗口名称。</p>
<span id="more"></span>
<p>同时开多个 tomcat 启动不同项目时，不好区分那个黑窗口是哪个项目，设置黑窗口名称可以帮助区分。</p>
<p>进入 tomcat 的 bin 目录，如 <code>T:\apache-tomcat-9.0.60-windows-x64\apache-tomcat-9.0.60\bin</code>，找到 <code>catalina.bat</code> 文件，用文本编辑器打开<br>
可以看到文件说明里面的最下面有关于 <code>TITLE</code> 的参数说明，默认会叫 <code>Tomcat</code>, 可以根据自己的需要进行修改，可以有空格。</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="comment">rem   TITLE           (Optional) Specify the title of Tomcat window. The default</span></span><br><span class="line"><span class="comment">rem                   TITLE is Tomcat if it&#x27;s not specified.</span></span><br><span class="line"><span class="comment">rem                   Example (all one line)</span></span><br><span class="line"><span class="comment">rem                   set TITLE=Tomcat.Cluster#1.Server#1 [%DATE% %TIME%]</span></span><br></pre></td></tr></table></figure>
<p>搜索文件中的 <code>TITLE</code>，找到下面这段，<code>set TITLE</code> 后面填写你的命名即可。</p>
<figure class="highlight dos"><table><tr><td class="code"><pre><span class="line">:doStart</span><br><span class="line"><span class="built_in">shift</span></span><br><span class="line"><span class="comment">rem 把这里的 Tomcat 改为需要设置的名字，可以带空格</span></span><br><span class="line"><span class="comment">rem if &quot;%TITLE%&quot; == &quot;&quot; set TITLE=Tomcat</span></span><br><span class="line"><span class="keyword">if</span> &quot;<span class="variable">%TITLE%</span>&quot; == &quot;&quot; <span class="built_in">set</span> <span class="built_in">TITLE</span>=YOURNAME YOURSUBNAME</span><br><span class="line"><span class="built_in">set</span> _EXECJAVA=<span class="built_in">start</span> &quot;<span class="variable">%TITLE%</span>&quot; <span class="variable">%_RUNJAVA%</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> &quot;&quot;%<span class="number">1</span>&quot;&quot; == &quot;&quot;-security&quot;&quot; <span class="keyword">goto</span> execCmd</span><br><span class="line"><span class="built_in">shift</span></span><br><span class="line"><span class="built_in">echo</span> Using Security Manager</span><br><span class="line"><span class="built_in">set</span> &quot;SECURITY_POLICY_FILE=<span class="variable">%CATALINA_BASE%</span>\conf\catalina.policy&quot;</span><br><span class="line"><span class="keyword">goto</span> execCmd</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术杂谈</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器因 docker 日志占用空间不足</title>
    <url>/zh-CN/troubleshoot-docker-no-space-left-on-device/</url>
    <content><![CDATA[<p>本文记录服务器因 docker 日志占用空间不足的处理过程。</p>
<span id="more"></span>
<h1>问题处理</h1>
<p>启动项目提示找不到缓存文件，登录界面验证码刷不出来</p>
<p>登录服务器重启 docker 后台服务，报错</p>
<blockquote>
<p>Error response from daemon: Cannot restart container my-serve: open /var/lib/docker/containers/9988633862afc28bc8764e39a8772f6376298e5d74479226e9a98c05b9e32ce4/hash3450992418: no space left on device</p>
</blockquote>
<p>提示空间不足，查看磁盘空间，发现有一个磁盘完全满了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">df</span> -h</span><br></pre></td></tr></table></figure>
<p>查看 docker 日志大小</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">du</span> -sh /var/lib/docker/containers/*/*-json.log</span><br></pre></td></tr></table></figure>
<p>发现有一个大日志文件占用了近一半的空间<br>
查找是哪个容器生产的日志</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 上面输出的 /var/lib/docker/containers/&lt;容器完整ID&gt;/</span></span><br><span class="line">docker ps -a --no-trunc | grep &lt;CONTAINER_ID&gt;</span><br></pre></td></tr></table></figure>
<p>停止服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker stop the-log-serve</span><br></pre></td></tr></table></figure>
<p>删除或清空日志文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> /var/lib/docker/containers/&lt;CONTAINER_ID&gt;/&lt;CONTAINER_ID&gt;-json.log</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">truncate</span> -s 0 /var/lib/docker/containers/0ad56ed2d47a.../*-json.log</span><br></pre></td></tr></table></figure>
<p>启动服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker start the-log-serve</span><br><span class="line">docker start my-serve</span><br></pre></td></tr></table></figure>
<h1>大日志轮转处理（待完善）</h1>
<p>使用 Linux 自带的 logrotate 配置日志轮转</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /etc/logrotate.d/docker-containers</span><br></pre></td></tr></table></figure>
<p>写入以下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/var/lib/docker/containers/*/*.<span class="built_in">log</span> &#123;</span><br><span class="line">    daily</span><br><span class="line">    rotate 7</span><br><span class="line">    <span class="comment"># 保留最近7份旧日志</span></span><br><span class="line">    size 100M</span><br><span class="line">    compress</span><br><span class="line">    delaycompress</span><br><span class="line">    missingok</span><br><span class="line">    copytruncate</span><br><span class="line">    dateext</span><br><span class="line">    dateformat -%Y%m%d</span><br><span class="line">    notifempty</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>参考资料</h1>
<ul>
<li><a href="https://www.man7.org/linux/man-pages/man8/logrotate.8.html">logrotate(8) - Linux manual page</a></li>
</ul>
]]></content>
      <categories>
        <category>技术杂谈</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim-vimtutor学习整理</title>
    <url>/zh-CN/vim-vimtutor/</url>
    <content><![CDATA[<p>在了解到Vim编辑器的强大的功能后，对于喜爱键盘想要摆脱鼠标的我来说是一个非常大的诱惑。而Vim自带的vimtutor无疑是一个入门的非常好的教程，该教程适合边学边用，很快就能了解最基本的Vim编辑器操作。本文将整理摘录vimtutor中的前六章内容，顺序上做了一定的归纳和调整。<br>
8.24 更新：<br>
补充了在<a href="https://www.openvim.com/">Interactive Vim tutorial</a>中学到的小技巧，因为大部分内容均为基本操作，故不再另外写文整理。</p>
<span id="more"></span>
<h1>第一讲 基本使用</h1>
<h2 id="1-1-移动光标">1.1 移动光标</h2>
<p>在正常模式（Normal)下（使用<ESC>键可以进入正常模式），使用<code>h j k l</code>键进行光标的移动，刚开始觉得这个设定极为反人类，但熟练其操作后会发现这个设定极为巧妙，能更快第在屏幕内四处移动光标。<br>
<code>h</code>: 光标向左移动；<br>
<code>l</code>: 光标向右移动；<br>
<code>j</code>: 光标向下移动；<br>
<code>k</code>: 光标向上移动.</p>
<p><em>小贴士</em>：在所有移动操作前加上<code>g</code>，就可以实现相对屏幕行进行操作而不是实际行，如<code>gj</code>。</p>
<h2 id="1-2-VIM的进入和退出">1.2 VIM的进入和退出</h2>
<p>在 Normal 模式下，<br>
<code>:q!&lt;Enter&gt;</code> : 退出编辑器，这种方式将会丢弃所有未写入的改动。<br>
<code>wq&lt;Enter&gt;</code>: 保存文件并退出。</p>
<h2 id="1-3-文本编辑">1.3 文本编辑</h2>
<p>在 Normal 模式下，<br>
<code>x</code>: 删除光标所在位置的字符；<br>
<code>X</code>: 删除光标左侧位置字符；<br>
<code>.</code>: 可重复前一次操作；<br>
<code>i</code>: 在光标所在位置之前插入字符；<br>
<code>a</code>: 在光标所在位置之后插入字符；<br>
<code>A</code>: 在光标所在行末尾插入字符。</p>
<h1>第二讲 删除撤销动作</h1>
<h2 id="2-1-动作">2.1 动作</h2>
<h3 id="动作列表">动作列表</h3>
<p><code>w</code>: 从当前光标位置移动到下一个单词起始处，不包括它的第一个字符；<br>
<code>e</code>: 从当前光标位置移动到单词末尾，包括最后一个字符；<br>
<code>$</code>: 从当前光标位置移动到当前行末；<br>
<code>ge</code>: 从当前光标位置移动到上一个单词末尾；<br>
<code>b</code>：从当前光标位置移动到上一个单词开头。</p>
<h3 id="计数指定动作">计数指定动作</h3>
<ol>
<li>在动作前输入数字会使该动作重复多次，e.g. ：</li>
</ol>
<ul>
<li><code>2w</code> 将光标向后移动两个单词</li>
<li><code>3e</code> 使光标移向后移动到第三个单词末尾</li>
<li><code>7perfect &lt;ESC&gt;</code>将插入7个perfect单词</li>
</ul>
<ol start="2">
<li><code>0</code>：移动光标到行首</li>
</ol>
<h2 id="2-2-删除类命令">2.2 删除类命令</h2>
<p>改变文本的命令通常由一个操作符和一个动作构成：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">operator [<span class="built_in">number</span>] motion</span><br></pre></td></tr></table></figure>
<ul>
<li>operator  操作符</li>
<li>[number] 可选操作，附加数字表示动作重复次数</li>
<li>motion  动作，表示在所操作的文本上的移动<br>
例如删除类命令：</li>
</ul>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">d [<span class="built_in">number</span>] motion</span><br></pre></td></tr></table></figure>
<ul>
<li>d  删除操作符<br>
<code>dw</code>: 删除至下一个单词起始处，不包括下一个单词的第一个字符；<br>
<code>de</code>: 删除至当前单词末尾，包括最后一个字符；<br>
<code>d$</code>: 删除至当前行末尾；<br>
删除命令也可以搭配计数删除更多。<br>
<code>dd</code>: 删除当前行；<br>
<code>dd</code> 命令同样可以在之前插入数字进行计数删除多行。</li>
</ul>
<h2 id="2-3-撤销类命令">2.3 撤销类命令</h2>
<p><code>u</code>: 撤销最后执行的命令；<br>
<code>U</code>: 撤销对整行的修改。<br>
<code>CTRL-R</code>: 撤销以前的撤销命令，恢复之前的操作结果</p>
<h1>第三讲 插入替换更改</h1>
<h2 id="3-1-插入类命令">3.1 插入类命令</h2>
<p><code>p</code>: 将最后一次删除的内容插入当前光标之后, 类似于剪切功能。<br>
<code>o</code>: 在光标当前行下方创建新的一行，并进入插入模式；<br>
<code>O</code>: 在光标当前行上方创建新的一行，并进入插入模式。</p>
<h2 id="3-2-替换类命令">3.2 替换类命令</h2>
<p><code>r[CHARACTER]</code>: 输入 r 和一个字符替换光标所在位置的字符<br>
<code>R</code>: 连续替换多个字符，与插入模式类似，不过每个输入的字符会替代光标当前字符，与键盘使用了 insert 键进入改写模式的情况类似</p>
<h2 id="3-3-更改类命令">3.3 更改类命令</h2>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">c [<span class="built_in">number</span>] motion</span><br></pre></td></tr></table></figure>
<ul>
<li>c 操作符</li>
</ul>
<p><code>cw</code>: 更改文本直到该单词末尾；<br>
<code>ce</code>: 更改文本直到下一单词开始；<br>
<code>c$</code>: 更改文本直到行末。<br>
更改命令执行后直接进入 insert 模式。</p>
<h1>第四讲 定位查找</h1>
<h2 id="4-1-定位及文件状态">4.1 定位及文件状态</h2>
<p><code>F[CHAR]</code>: 光标移动到上一个 char 所指字母所在位置；<br>
<code>f[CHAR]</code>: 光标移动到下一个 char 所指字母所在位置；<br>
<code>*</code>: 光标移动到当前光标所指单词相同的下一个位置；<br>
<code>#</code>: 光标移动到当前光标所指单词相同的上一个位置；<br>
<code>CTRL-g/G</code>: 显示当前编辑文件中当前光标所在行位置以及文件状态信息；<br>
<code>G</code>: 光标跳转到文件最后一行；<br>
<code>gg</code>: 光标跳转到文件第一行；<br>
<code>G[NUMBER]</code>: 光标跳转到number表示的行号。</p>
<h2 id="4-2-搜索类命令">4.2 搜索类命令</h2>
<p><code>/[STRING]</code>: 正向查找string表示的字符串;<br>
<code>?[STRING]</code>: 逆向查找string表示的字符串；<br>
<code>CTRL-O</code> \ <code>N</code>：回到前一个位置；<br>
<code>CTRL-I</code> \ <code>n</code>: 到下一个位置。</p>
<h2 id="4-3-配对括号的查找">4.3 配对括号的查找</h2>
<p>使用<code>%</code>可查找匹配对的括号<code>) \ ] \ &#125;</code>：<br>
将光标移动到左括号处，按下<code>%</code>，光标将跳转到匹配的右括号处，再按下一次可跳回原来的左括号处。<br>
（这对程序员来说真是个福音~）</p>
<h2 id="4-4-替换命令">4.4 替换命令</h2>
<p><code>:s/old/new</code>: 在光标所在行第一次出现的 old 表示的字符串替换为新的字符串 new ;<br>
<code>:s/old/new/g</code>: 在光标所在行替换所有出现的 old 所表示的字符串替换为新的字符串 new ；<br>
<code>:#,#s/old/new/g</code>: 在两行内替换所有的字符串 old 为新的字符串 new ；<br>
<code>:%s/old/new/g</code>: 在文件内替换所有的字符串 old 为新的字符串 new ；<br>
<code>:%s/old/new/gc</code>: 进行全文替换时询问用户确认每个替换。</p>
<h1>第五讲 文件操作</h1>
<h2 id="5-1-在VIM内部执行外部命令">5.1 在VIM内部执行外部命令</h2>
<p><code>:![COMMAND]</code>: 执行command所代表的外部命令</p>
<h2 id="5-2-保存文件">5.2 保存文件</h2>
<p><code>:w FILENAME</code>: 将对文件的改动保存到一个文件中;<br>
<code>v motion: w FILENAME</code>: 将文件的部分内容保存到文件中：<br>
v 进入可视模式（Visual), motion 表示光标的移动，可选中文本，按下：后下方将出现<code>'&lt;,'&gt;</code>，输入w FILENAME将选中的文本保存在文件FILENAME中。可视选中后同样也可以进行批量删除操作。</p>
<h2 id="5-3-提取合并文件">5.3 提取合并文件</h2>
<p><code>:r FILENAME</code>: 提取磁盘文件 FILENAME 并将其插入到当前文件光标当前位置后；<br>
<code>:r !command</code>: 读取command命令的输出插入到当前文件光标当前位置后。</p>
<h2 id="5-4-复制粘贴文本">5.4 复制粘贴文本</h2>
<p>进入 Visual 模式，<br>
使用<code>y</code>进行复制，使用<code>p</code>进行粘贴</p>
<p>文本编辑部分整理至此。</p>
<p>顺便推荐几个网站：</p>
<ul>
<li><a href="https://vim-adventures.com/ ">VIM Adventures</a>，这是一个用VIM操作来进行的游戏，不过免费版只能练习最基本的移动操作~</li>
<li><a href="https://www.openvim.com/">Interative Vim tutorial</a>,这是一个交互的类似于 vimtutor 的教程网站</li>
<li><a href="https://www.openvim.com/sandbox.html">Interative Vim tutorial - sandbox</a>这是上面那个教程网站给出的一个练习，右侧还有命令提示，可以说非常贴心了</li>
<li><a href="http://www.vimsnake.com/">Vim Snake</a> 一个基于Vim移动操作的贪吃蛇游戏</li>
</ul>
<h1>参考资料</h1>
<ul>
<li>vimtutor</li>
<li><a href="https://www.openvim.com/">Interative Vim tutorial</a></li>
<li>《Vim 实用技巧（第2版）》</li>
</ul>
]]></content>
      <categories>
        <category>软件使用</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>VirtualBox 安装 Ubuntu Server（安装_配置网络_SSH）</title>
    <url>/zh-CN/vituralbox-install-ubuntu/</url>
    <content><![CDATA[<p>本文将介绍如何在 VirtualBox 中安装 Ubuntu Server，并配置网络和 SSH 访问。</p>
<span id="more"></span>
<h1>安装 VitrualBox</h1>
<ol>
<li>下载 VitrualBox 安装软件<br>
下载地址：<a href="https://www.virtualbox.org/wiki/Downloads">Downloads – Oracle VirtualBox</a></li>
<li>如果安装时弹出以下错误，需要在微软的服务支持中找到安装包安装 <a href="https://learn.microsoft.com/en-us/cpp/windows/latest-supported-vc-redist?view=msvc-170">Latest supported Visual C++ Redistributable downloads | Microsoft Learn</a><br>
<img src="/images/cnblog/3643699-20250719172412948-702184005.png" alt="VirtualBox安装报错"><br>
<img src="/images/cnblog/3643699-20250719172557024-358531801.png" alt="C++依赖图示"></li>
<li>安装完成后重新进行VituralBox的安装，记得安装网络相关的组件（默认会安装）</li>
</ol>
<h1>下载 Ubuntu 镜像</h1>
<p>选择合适的版本进行下载，本文使用的是Ubuntu 24.04.2 LTS<br>
下载地址：<a href="https://ubuntu.com/download/server">Get Ubuntu Server | Download | Ubuntu</a></p>
<h1>VirtualBox全局网络设定</h1>
<ol>
<li>点击工具旁边的列表，选择网络<br>
<img src="/images/cnblog/3643699-20250720113614539-1925563591.png" alt="image"></li>
<li>设置Host-only，选择手动配置网卡<br>
<img src="/images/cnblog/3643699-20250720114044887-1330707441.png" alt="image"></li>
</ol>
<h1>虚拟机配置</h1>
<h2 id="虚拟机基础配置">虚拟机基础配置</h2>
<ol>
<li>设置虚拟机名称，虚拟光盘选择刚刚下载的镜像文件<br>
<img src="/images/cnblog/3643699-20250719194125661-778412755.png" alt="image"></li>
<li>根据你的使用需求分配内存和处理器（可以把使用需求描述发给AI，让AI给出硬件配置）<br>
<img src="/images/cnblog/3643699-20250719194308934-513876306.png" alt="image"></li>
<li>设置虚拟硬盘（配置参数也是按需设定，可以让AI辅助生成）<br>
<img src="/images/cnblog/3643699-20250719194329851-1528542320.png" alt="image"></li>
</ol>
<h2 id="网络配置">网络配置</h2>
<p>网卡1和网卡2不需要按这个顺序，只要有两个这个网络设定就可以</p>
<ol>
<li>设置网卡1为网络地址转换（NAT），用于访问互联网<br>
<img src="/images/cnblog/3643699-20250720114939997-723812010.png" alt="image"></li>
<li>设置网卡2为仅主机网络，其他设定按默认即可<br>
<img src="/images/cnblog/3643699-20250720115527201-1403369457.png" alt="image"></li>
</ol>
<h1>安装系统</h1>
<ol>
<li>启动虚拟机</li>
<li>选择第一个，安装 Ubuntu Server<br>
<img src="/images/cnblog/3643699-20250720115201392-469023671.png" alt="image"></li>
<li>语言选择英语</li>
<li>键盘布局我使用了检测系统检测出来是图片的这个<br>
<img src="/images/cnblog/3643699-20250720115633897-1192508262.png" alt="image"></li>
<li>选择安装模式，建议你选择第一个，第二个安装完连 <code>ping</code>, <code>vi</code>这类基础命令都没有<br>
<img src="/images/cnblog/3643699-20250720115722764-1596255386.png" alt="image"></li>
<li>配置网络，可以看到图上有2张网卡，1张是NAT，一张是Host-only，对应我们上面的网络设置<br>
<img src="/images/cnblog/3643699-20250720115948478-1678625414.png" alt="image"></li>
<li>选择那张Host-only的，选择手动分配IP<br>
<img src="/images/cnblog/3643699-20250720120045638-1490767169.png" alt="image"><br>
<img src="/images/cnblog/3643699-20250720120117210-412917166.png" alt="image"></li>
<li>配置Subnet 与Host-Only一致，如果不确定如何配置，可以直接问AI，它会输出所有配置<br>
<img src="/images/cnblog/3643699-20250720120310875-1799346530.png" alt="image"></li>
<li>这时候网络可能还未通，所以镜像会有问题，可以先不管他<br>
<img src="/images/cnblog/3643699-20250720120612032-1870840288.png" alt="image"></li>
<li>存储配置选择 Use an entire disk</li>
<li>跳过 Ubuntu Pro</li>
<li>选择 Install openSSH</li>
<li>选择 Reboot Now</li>
</ol>
<p>这时候可以创建一个快照</p>
<h1>配置网络</h1>
<p>进入系统后发现还是不能 ping 通互联网的网络，比如 <a href="http://baidu.com">baidu.com</a>，也 ping 不通宿主机 192.168.56.1，但宿主机可以 ping 通虚拟机 192.168.56.22</p>
<h2 id="虚拟机-ping-宿主机">虚拟机 ping 宿主机</h2>
<ol>
<li>使用以下语句先暂时关闭宿主机的防火墙(使用管理员身份打开 cmd)</li>
</ol>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">netsh advfirewall <span class="built_in">set</span> allprofiles <span class="keyword">state</span> off</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>测试虚拟机是否可以 ping 通宿主机</li>
<li>可以之后，使用以下语句精准放行 Host-Only 网段的 ICMP 请求</li>
</ol>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">netsh advfirewall<span class="built_in"> firewall </span><span class="built_in">add</span> rule <span class="attribute">name</span>=<span class="string">&quot;Allow Host-Only ICMP&quot;</span> <span class="attribute">dir</span>=in <span class="attribute">action</span>=allow <span class="attribute">protocol</span>=icmpv4 <span class="attribute">remoteip</span>=192.168.56.0/24</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>恢复防火墙</li>
</ol>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">netsh advfirewall <span class="built_in">set</span> allprofiles <span class="keyword">state</span> <span class="keyword">on</span></span><br></pre></td></tr></table></figure>
<h2 id="配置虚拟机连通互联网">配置虚拟机连通互联网</h2>
<ol>
<li>使用 <code>ip route</code> 查看路由情况<br>
<img src="/images/cnblog/3643699-20250719231647454-1015375365.png" alt="image"><br>
发现因为路由问题导致无法访问互联网</li>
<li>编辑路由配置</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vim /etc/netplan/50-cloud-init.yaml</span><br></pre></td></tr></table></figure>
<p>配置前的路由情况：<br>
<img src="/images/cnblog/3643699-20250720121916136-1068483522.png" alt="image"><br>
编辑为：<br>
<img src="/images/cnblog/3643699-20250720122033123-1401949685.png" alt="image"><br>
3. 应用配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> netplan apply</span><br></pre></td></tr></table></figure>
<p>这时候应该就可以 ping 通互联网了</p>
<p>可以再建立一个快照</p>
<h1>配置 SSH 访问</h1>
<p>在虚拟机中使用复制粘贴不方便，我尝试使用 VitrualBox 的增强功能，似乎需要图形界面支持，一直无法成功，故换用主机 SSH 连接的方式</p>
<ol>
<li>设置开机SSH自启动</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> --now ssh</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>放行SSH端口</li>
</ol>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">sudo</span> ufw <span class="literal">allow</span> <span class="number">22</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>
<p>在刚刚配置网卡的地方配置 VirtualBox 网络（端口转发），主机端口可自由设置<br>
<img src="/images/cnblog/3643699-20250720122654113-383512891.png" alt="image"></p>
</li>
<li>
<p>现在就可以使用SSH工具访问了</p>
</li>
</ol>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">ssh</span> username@<span class="number">127.0.0.1</span> -p <span class="number">4869</span></span><br></pre></td></tr></table></figure>
<h1>参考资料</h1>
<ul>
<li><a href="https://www.zhangshengrong.com/p/O3aAk6ZKX4/">virtualbox虚拟机NAT模式下不能连接外网的解决方法 / 张生荣</a></li>
</ul>
]]></content>
      <categories>
        <category>技术杂谈</category>
      </categories>
      <tags>
        <tag>VirtualBox</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-选择排序</title>
    <url>/zh-CN/Algorithms-selection-sort/</url>
    <content><![CDATA[<p>算  法：选择排序算法<br>
时间复杂度：$O(n^2)$</p>
<ul>
<li>选择排序算法概述</li>
<li>选择排序伪代码</li>
<li>选择排序实现</li>
</ul>
<span id="more"></span>
<h1>选择排序算法概述</h1>
<p>排序算法有许多，选择排序也是其中一种较为简单的方法。它的算法过程是是每一趟将当前数与后面的每一个数进行比较，若不满足排序所需顺序则交换两个数的位置，这样第一趟比较结束后，第一个数就是正确顺序的数，第$i$趟排序结束后，第$i$个位置的数都为正确的数，这个算法也被通俗地成称为“打擂台”，第一趟选择最大（最小）的数，第二趟选择出次大（次小）的数，一直到完成整个排序过程。</p>
<h2 id="选择排序算法描述">选择排序算法描述</h2>
<ol>
<li>第$i$趟“打擂台”过程从序列第$i$个元素开始遍历至尾部；</li>
<li>对于每一趟“打擂台”的选择过程，比较正在遍历的元素与第$i$个元素的大小关系，不满足，则交换两者位置；</li>
<li>持续1-2步骤直到每个位置都当过“擂主”。</li>
</ol>
<h2 id="选择排序示例">选择排序示例</h2>
<p>正在排序的数加粗表示<strong>3</strong>，排序后的数放于中括号内[3]，将被交换的数用斜体表示<em>3</em><br>
未排序： 5 31 16  9 7 10 3<br>
第一趟：<br>
** <em>5</em> ** 31 16 9 7 10 <em>3</em><br>
[3] 31 16 7 9 10 5<br>
第二趟：<br>
[3] <em><strong>31</strong></em> 16 9  7 10 <em>5</em><br>
[3 5] 16 7 9 10 31<br>
第三趟：<br>
[3 5]<em><strong>16</strong></em> <em>9</em> 7 10 31<br>
[3 5] <em><strong>9</strong></em> 16 <em>7</em> 10 31<br>
[3 5 7] 16 9 10 31<br>
第四趟：<br>
[3 5 7]<em><strong>16</strong></em> <em>9</em> 10 31<br>
[3 5 7 9] 16 10 31<br>
第五趟：<br>
[3 5 7 9] <em><strong>16</strong></em> <em>10</em> 31<br>
[3 5 7 9 10] 16 31<br>
第六趟：<br>
[3 5 7 9 10] <strong>16</strong> 31<br>
[3 5 7 9 10 16] 31<br>
[3 5 7 9 10 16 31]</p>
<h1>选择排序伪代码</h1>
<p>SELECTIONSORT(A)</p>
<figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i = <span class="number">1</span> <span class="keyword">to</span> A.length - <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> j = i + <span class="number">1</span> <span class="keyword">to</span> A.length</span><br><span class="line">		<span class="keyword">if</span> A[i] &gt; A[j]</span><br><span class="line">			exchange A[j] <span class="keyword">with</span> A[i]</span><br></pre></td></tr></table></figure>
<h1>选择排序实现</h1>
<h2 id="C">C</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">selectionSort</span><span class="params">(arrType* a, <span class="type">int</span> arrLength)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; arrLength - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; arrLength; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; a[j]) &#123;</span><br><span class="line">               t = a[i];</span><br><span class="line">               a[i] = a[j];</span><br><span class="line">               a[j] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Pascal">Pascal</h2>
<figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">selectionsort</span>;</span>   </span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">  i, j, t : integer;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">1</span> <span class="keyword">to</span> arrLength - <span class="number">1</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">for</span> j := i + <span class="number">1</span> <span class="keyword">to</span> arrLength <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> a[j] &lt; a[i] <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">begin</span></span><br><span class="line">                t := a[i];</span><br><span class="line">                a[i] := a[j];</span><br><span class="line">                a[j] := t;</span><br><span class="line">            <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1>参考资料</h1>
<ul>
<li>《Free Pascal语言与基础算法》</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title>计算方法-[1]绪论与计算误差</title>
    <url>/zh-CN/Numerical-methods-and-calculation-error/</url>
    <content><![CDATA[<p>计算方法课程第一章绪论与计算误差整理，来自课程内容，因 Github 无法渲染公式，故整理在此.</p>
<p>源文件：<a href="https://github.com/fish-404/Notes/tree/master/%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95">https://github.com/fish-404/Notes/tree/master/计算方法</a></p>
<span id="more"></span>
<h2 id="计算方法研究内容与意义">计算方法研究内容与意义</h2>
<h3 id="研究对象">研究对象</h3>
<p>计算方法研究的是运用计算机来解决各种数学问题的 <strong>近似</strong> 计算方法与理论。</p>
<p>计算方法是研究求解各类数学问题在一定范围内的在一定范围内的 <em>数值解</em> 的方法，以及这些方法的 <strong>误差传播规律</strong>、<strong>收敛性</strong>、<strong>稳定性</strong>，与如何 <em>在计算机上</em> 编程 <em>有效实现</em> 等问题的学科。</p>
<p><img src="https://raw.githubusercontent.com/fish-404/Notes/master/%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95/%E5%88%A9%E7%94%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%A3%E5%86%B3%E5%AE%9E%E9%99%85%E9%97%AE%E9%A2%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%87%E7%A8%8B.png" alt="利用计算机解决实际问题的基本过程流程图"></p>
<h3 id="意义">意义</h3>
<ol>
<li>计算机只能解决以四则运算为基础的，能在有穷步内结束的计算问题，高等数学和线性代数的许多理论与方法不能在计算机上直接应用。</li>
<li>众多生产实践与科学研究问题本身并不具备解析形式，或者用纯数学方法难以找到问题的解析解。</li>
<li>一些问题虽然具有解析形式，但过于复杂，计算机无法在可接受的时间内求解。</li>
<li>一些问题的解析解可能含有无穷多项，只能使用近似的计算方法去逼近问题的解。</li>
<li>在分析实验，观察数据时，需要使用插值、拟合等多种数值计算方法把一系列离散的数据关联起来。</li>
</ol>
<h2 id="计算方法的主要特点">计算方法的主要特点</h2>
<ul>
<li>
<p><strong>严谨性</strong>：</p>
<p>计算方法的收敛性、稳定性与可靠性需要以数学理论为基础</p>
</li>
<li>
<p><strong>实践性</strong>：</p>
<p>与实际应用、实际计算过程紧密相连</p>
</li>
<li>
<p><strong>近似性</strong>:</p>
<p>用有穷取代无穷，变不可解为可解的方法，对数学问题近似求解，逐步求精</p>
</li>
<li>
<p><strong>结构性</strong>：</p>
<p>由有穷步的四则运算构成：计算复杂性低；方法、流程与计算机程序一致</p>
</li>
</ul>
<h2 id="误差的基本概念">误差的基本概念</h2>
<h3 id="计算机中数的浮点表示">计算机中数的浮点表示</h3>
<p>计算机中参与运算的数是用浮点表示的</p>
<p>$$<br>
x = \pm a_1a_2 \cdots a_s \times \beta^c<br>
$$</p>
<p>其中 $1 \le a_1 &lt; \beta, 0 \le a_i &lt; \beta, i = 2, 3, \cdots, s\ge$, $c$是阶码</p>
<h3 id="计算机中的舍入误差">计算机中的舍入误差</h3>
<p>大多数计算机以二进制形式存储数字，由于计算机字长有限，不是所有数字都可以被准确地表示，它们必须被舍入到适合计算机的字长，意味着被执行的算术运算使不精确的。</p>
<h3 id="误差来源">误差来源</h3>
<ul>
<li>观察误差</li>
</ul>
<p>由于仪器的精密程度、实验手段、周围环境、人工作态度及能力等因素，观察或测量结果存在误差。</p>
<p>求解过程中，使用带有误差的观察数据作为数学模型的原始输入数据或已知参数引入观察误差。</p>
<ul>
<li>模型误差</li>
</ul>
<p>在建立数学模型时抓住问题最本质、起主导作用的方面，略去非本质的次要因素，将问题理想化再进行数学概括，模型与实际之间存在一定误差。</p>
<p>在将实际问题转化为数学模型的阶段引入模型误差。</p>
<ul>
<li>截断误差</li>
</ul>
<p>为了让计算机能解决数学上需要无穷次运算才能获得精确解的问题，通过有限次计算得到问题近似解，近似解与理论上的准确解存在误差。</p>
<p>在使用计算方法逼近数学模型的理论精确解的过程中引入截断误差，也称为「方法误差」。</p>
<ul>
<li>舍入误差</li>
</ul>
<p>由于计算机字长有限，在计算过程中的数据通过四舍五入或类似操作来保留有限位的有效数字，引入舍入误差。</p>
<h3 id="误差与误差限">误差与误差限</h3>
<h4 id="绝对误差">绝对误差</h4>
<p>$$<br>
e(x^*) = x - x^*<br>
$$</p>
<p>$x$ 为精确值， $x^*$ 为 $x$ 的近似值</p>
<p>$e(x^*)$可正可负。</p>
<h4 id="绝对误差限">绝对误差限</h4>
<p>$|e(x^*)|$的上限称为$ x^*$ 的绝对误差限，记为 $\varepsilon(x^*)$</p>
<p>$\varepsilon(x^*)$不唯一，越小越有参考价值</p>
<p>给定近似值$x^*$ 的误差限$\varepsilon(x^*)$，就可以直到准确值 $x$ 的区间，实际应用中一般记为 $x = x^* \pm \varepsilon(x^*)$</p>
<h4 id="相对误差">相对误差</h4>
<p>$$<br>
e_r(x^*) =\frac{e(x^*)}{x}  = \frac{(x - x^*)}{x}<br>
$$</p>
<h4 id="相对误差限">相对误差限</h4>
<p>$|e_r(x^*)|$ 的上限称为 $x^*$ 的相对误差限，记为 $\varepsilon_r(x^*)$</p>
<h4 id="有效数字与误差限的关系">有效数字与误差限的关系</h4>
<ul>
<li><strong>定理1</strong><br>
如果近似数 $x^* = \pm r^m \times (a_1 r^{-1} + a_2 r ^{-2} + \cdots + a_n r^{-n})$ 具有 $n$ 位有效数字，则可以得到 $x^*$ 的一个绝对误差限：<br>
$$<br>
|e(x^*) | = |x - x^*| \le \varepsilon(x ^*) = \frac{1}{2} \times r^{m-n}<br>
$$</li>
<li><strong>定理2</strong><br>
如果近似数 $x^* = \pm r^m \times (a_1 r^{-1} + a_2 r ^{-2} + \cdots + a_n r^{-n})$ 具有 $n$ 位有效数字，则可以得到 $x^*$ 的一个相对误差限：<br>
$$<br>
|e(x^*) | = |x - x^*| \le \varepsilon(x ^*) = \frac{1}{2} \times r^{-(n - 1)}<br>
$$</li>
<li><strong>定理3</strong><br>
如果近似数 $x^* = \pm r^m \times (a_1 r^{-1} + a_2 r ^{-2} + \cdots + a_n r^{-n})$ 满足<br>
$$<br>
|e_r(x^*)|\le \frac{1}{2(a_1+ 1)}\times r^{-(n-1)}<br>
$$<br>
那么$x^*$至少有 $n$ 位有效数字。</li>
</ul>
<p><em>注意</em> ：任意移动小数点位置不影响有效数字位数。</p>
<h4 id="四则运算的误差传播公式">四则运算的误差传播公式</h4>
<h5 id="加减法">加减法</h5>
<p>$$<br>
\varepsilon(x^* \pm y^*) = \varepsilon(x^*) + \varepsilon (y ^*)<br>
$$</p>
<h5 id="乘法">乘法</h5>
<p>$$<br>
\varepsilon(x^*y^*) = |x^*|\varepsilon(y^*) + |y^*|\varepsilon(x^*)<br>
$$</p>
<h5 id="除法">除法</h5>
<p>$$<br>
\varepsilon(\frac{x^*}{y^*})=\frac{|x^*|\varepsilon(y^*)+|y^*|\varepsilon(x^*)}{|y^*|^2}, y \ne0, y^* \ne 0<br>
$$</p>
<p>(误差传播公式和求导公式有些相似）</p>
<h3 id="设计计算方法的原则">设计计算方法的原则</h3>
<h4 id="计算方法的评判标准">计算方法的评判标准</h4>
<ol>
<li>稳定性的好坏</li>
<li>精度的高低</li>
<li>计算量的大小</li>
<li>存储量的大小</li>
<li>逻辑是否简单</li>
</ol>
<h4 id="基本原则">基本原则</h4>
<h5 id="1-避免两个相近的数相减">1. 避免两个相近的数相减</h5>
<p>两个相近的数相减将导致有效数字的严重丢失。在设计计算方法时应设法避免这种情况发生，常用方法时变换计算公式：</p>
<p>常见变换公式：<br>
$$<br>
\sqrt{x+ \varepsilon} - \sqrt{x} = \frac{\varepsilon}{\sqrt{x + \varepsilon} + \sqrt{x}}, \varepsilon \to 0<br>
$$<br>
$$<br>
ln(x + \varepsilon) - ln x = ln(1+\frac{\varepsilon}{x}),\varepsilon \to 0, 且 |x| \gg 0<br>
$$<br>
$$<br>
1-cosx = 2sin^2 \frac{x}{2} , x\to 0<br>
$$<br>
$$<br>
e^x - 1 = (1 + x + \frac{x^2}{2!} + \frac{x^3}{3!} + \cdots) - 1 = x (1 + \frac{x}{2} + \frac{x^2}{6} + \cdots), x\to 0<br>
$$</p>
<h5 id="2-防止大数吃小数">2.防止大数吃小数</h5>
<p>当两个绝对值差异很大的数进行加减法运算时，绝对值小的数有可能因为计算机附点运算的特点而被“吃掉“，导致计算结果严重失真。</p>
<ol>
<li>
<p>求二次方程的根<br>
$$<br>
\begin{cases}<br>
x_1 = \frac{-2c}{b + sgn(b)\sqrt{b^2 - 4ac}}, \quad sgn(b) =<br>
\begin{cases}<br>
1, b\ge 0 \\<br>
-1, b &lt; 0<br>
\end{cases}\\<br>
x_2 = \frac{c}{ax_1}<br>
\end{cases}<br>
$$</p>
</li>
<li>
<p>在处理多个数求和操作时，一般按照从小到大的顺序累加，可以使求和的误差减到最小。</p>
</li>
</ol>
<h5 id="3-避免采用绝对值很小的数作为除数">3. 避免采用绝对值很小的数作为除数</h5>
<p>当采用绝对值很小的数作为分母时，容易产生浮点溢出现象，同时可能引起大数吃小数的情况出现，导致误差很大。</p>
<h5 id="4-简化运算步骤，减少运算次数">4. 简化运算步骤，减少运算次数</h5>
<ul>
<li>良好的计算方法应该具有可接受的时间复杂度和（存储）空间复杂度。</li>
<li>简化运算步骤不但能够有效地减少运算时间，同时也能减少舍入误差的积累。</li>
<li>计算机处理速度顺序<br>
$$<br>
(+, -)&gt;(\times, \div)&gt;(exp)<br>
$$</li>
<li>在设计计算方法时应该尽量使用速度较快的加减运算。</li>
</ul>
<h5 id="5-控制计算方法的误差传播，保证计算方法的稳定性">5. 控制计算方法的误差传播，保证计算方法的稳定性</h5>
<ul>
<li><strong>稳定性算法</strong>：在运算过程中误差逐步衰减的算法</li>
<li><strong>不稳定算法</strong>： 误差的积累越来越大的算法</li>
</ul>
<h1>参考资料</h1>
<ul>
<li>《数值计算》</li>
</ul>
]]></content>
      <categories>
        <category>计算方法</category>
      </categories>
      <tags>
        <tag>Numerical methods</tag>
      </tags>
  </entry>
  <entry>
    <title>缓冲区计算问题</title>
    <url>/zh-CN/buffer-calculate/</url>
    <content><![CDATA[<p>本文主要讲解缓冲区计算问题，包括单缓冲区和双缓冲区的情况。</p>
<span id="more"></span>
<p>题目：假设磁盘块与缓冲区大小相同，每个盘块读入缓冲区的时间为 $16 μs$，由缓冲区送至用户区的时间是 $5 μs$，在用户区内系统对每块数据的处理时间为 $1 μs$。若用户需要将大小为10个磁盘块的 Doc1 文件逐块从磁盘读入缓冲区，并送至用户区进行处理，那么采用单缓冲区需要花费的时间为（1）$μs$；采用双缓冲区需要花费的时间为（2）$μs$。</p>
<h1>单缓冲区</h1>
<p>对于单缓冲区的情况，数据尚未进入用户区时，缓冲区为繁忙状态，即使磁盘块到缓冲区这一步已经完成，两者是不能并行的，即图中绿色和蓝色的部分，这两个流程是不能并行的。计算时先按照时间比例作出一个完整流程的时间图，即包括磁盘块读入缓冲区的时间、缓冲区读入用户区的时间、用户区处理数据的时间，这三个步骤构成一个完整的流程。</p>
<p>缓冲区读入用户区后，在用户区处理数据的时间内，缓冲区为空闲状态，此时磁盘块读入缓冲区的步骤可以与用户区处理数据并行。即图中第二段蓝色与第一段紫色可以同时进行，作图第二个完整流程。此时我们以 2 个作业任务进行分析，就可以找到其中的规律。<br>
如果多作图几个流程，可以很容易看出，红底部分为一个周期，如何判断一个周期，即去掉第一个流程中不能并行的部分（磁盘块读入缓冲区的部分，图中蓝色部分），去掉最后一个流程的不能并行的部分（缓冲区读入用户区，用户区处理数据，绿色和紫色部分）。</p>
<p>这时候计算就很容易了，计算出周期的时间 $16+5=21μs$，首尾的两个流程会凑成一个周期，中间共 $10-1=9$ 个周期，再加上首尾这一个完整周期的时间就得到总时间。</p>
<p>$$<br>
（10-1）* （16+5）+16+5+1=211 \mu s<br>
$$</p>
<p><img src="/images/cnblog/singleBuffer.png" alt="单缓冲区计算示意图"></p>
<h1>双缓冲区</h1>
<p>对于双缓冲区的情况，在缓冲区读入用户区数据的过程中，因为有一个缓冲区为空闲，所以此时可以并行处理磁盘块到缓冲区的流程（图中深蓝色的部分）。这个步骤的时间比较长，而缓冲区读入用户区这个过程是需要等待缓冲区从磁盘块读入完整后才能进行的，所以深绿色部分必须在深蓝色部分之后，但它可以与浅蓝色部分并行，即另一块缓冲区此时是空闲状态的。这种情况下建议画出 3 个完整流程，就可以看出周期规律。同样地，第一个周期的磁盘块读入缓冲区流程无可并行者（浅蓝色），最后一个流程的缓冲区至用户区，用户区数据处理部分也一样无法与其他并行处理（图中最后一段绿色和紫色部分，当然此处也可能是深绿色部分，即另一个缓冲区为最后一个处理流程，类似地，不作图补充）。</p>
<p>在这种情况下，一个周期时间长度实际上是由磁盘块读入缓冲区的时间来决定的，即当前周期长度变成了 $16μs$（并非绝对，需根据数据比例作图确定）。此时计算过程与上面单缓冲区其实是一致的。</p>
<p>$$<br>
(10-1)*16+16+15+1=166 \mu s<br>
$$</p>
<p><img src="/images/cnblog/doubleBuffer.png" alt="双缓冲区计算示意图"></p>
<h1>总结</h1>
<p>计算缓冲区时间问题的关键在于根据比例画出步骤图示，确定缓冲区周期，确定好缓冲区周期后，双缓冲区和单缓冲区的时间计算其实是一致的。</p>
<h1>参考资料</h1>
<p><a href="https://blog.csdn.net/qq_41929714/article/details/128952748" title="1.2.6存储结构-磁盘管理：单缓冲区与双缓冲区读取、流水线周期、计算流水线执行时间">1.2.6存储结构-磁盘管理：单缓冲区与双缓冲区读取、流水线周期、计算流水线执行时间</a></p>
]]></content>
  </entry>
  <entry>
    <title>如何为 TiddlyWiki 编辑栏添加块引用按钮</title>
    <url>/zh-CN/tiddlywiki-add-editor-button/</url>
    <content><![CDATA[<p>本文详述如何为 TiddlyWiki 编辑栏添加块引用按钮。</p>
<span id="more"></span>
<h1>背景</h1>
<p>我利用 TiddlyWiki 来记录读书笔记，更希望使用带双引号的块状引用格式来呈现。TiddlyWiki 提供了默认的引用按钮，但是默认的引用格式是没有双引号的，但它提供了一个 <code>.tc-big-quote</code> 的语法来实现带双引号的块状引用。但如果每一次使用都要输入这个有一点麻烦，所以希望添加一个按钮来快速添加这个语法块。该方法也适用于添加其他语法较复杂的输出块按钮。</p>
<h1>方法</h1>
<p>创建一个新按钮的最简单方式，就是 Clone 一个现有的按钮 tiddler，然后修改这个 tiddler。</p>
<ol>
<li>
<p>克隆按钮 tiddler</p>
<ul>
<li>找到一个现有的按钮 tiddler，例如 <code>$:/core/ui/EditorToolbar/quote</code></li>
<li>Clone 出一个新的 tiddler，修改 tiddler的标题为 <code>$:/core/ui/EditorToolbar/bigquote</code></li>
</ul>
</li>
<li>
<p>修改 tiddler 调用引用块语法</p>
 <figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;<span class="variable">$action</span>-sendmessage</span><br><span class="line">    <span class="variable">$message</span>=<span class="string">&quot;tm-edit-text-operation&quot;</span></span><br><span class="line">    <span class="variable">$param</span>=<span class="string">&quot;wrap-lines&quot;</span></span><br><span class="line">    <span class="attribute">prefix</span>=<span class="string">&quot;</span></span><br><span class="line"><span class="string">&lt;&lt;&lt;&quot;</span></span><br><span class="line">    <span class="attribute">suffix</span>=<span class="string">&quot;&lt;&lt;&lt;&quot;</span></span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>
<p>以上是 <code>quote</code> 的调用语法块，<code>$message</code> 保持不变，这个相当于调用一个语法函数，以便在我们的调用文本前后添加指定的语法符号。<code>$param</code> 保持不变，这个参数使用 <code>wrap-lines</code> 来实现文本块前后添加指定语法符号。其中 <code>prefix</code> 指要添加在文本前面的语法符号，<code>suffix</code> 指要添加在文本后面的语法符号。这里我们要调用 <code>.tc-big-quote</code>的语法，只需要将<code>prefix</code>的语法变为 <code>&lt;&lt;&lt;.tc-big-quote</code> 即可。</p>
 <figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;<span class="variable">$action</span>-sendmessage</span><br><span class="line">    <span class="variable">$message</span>=<span class="string">&quot;tm-edit-text-operation&quot;</span></span><br><span class="line">    <span class="variable">$param</span>=<span class="string">&quot;wrap-lines&quot;</span></span><br><span class="line">    <span class="attribute">prefix</span>=<span class="string">&quot;</span></span><br><span class="line"><span class="string">&lt;&lt;&lt;.tc-big-quote&quot;</span></span><br><span class="line">    <span class="attribute">suffix</span>=<span class="string">&quot;&lt;&lt;&lt;&quot;</span></span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>修改 tiddler 相关的属性设置</p>
<ul>
<li><code>caption</code>: 这个属性用于设置在 <code>$:/ControlPanel</code> 这个 tiddler 中设置的按钮名字，也用于设置快捷键时区分按钮名字。如果你希望在多语言中该按钮也有正确的对应显示，你应该使用类似于 <code>&#123;&#123;$:/language/Buttons/bigquote/Caption&#125;&#125;</code> 这样的字段来显示标题，以便翻译人员可以添加翻译，创建一个名为 <code>$:/language/Buttons/bigquote/Caption</code> 的 tiddler，并在其中写入英文的按钮标题。当然最简单的方式是使用固定文本作为标题，建议你可以先用这个进行尝试，在进行多语言的 tiddler 替换。</li>
<li><code>conditon</code>: 这个属性用于填入一个 tiddler filter expression, 用于判断是否显示该按钮。如果不设置该属性，默认会显示该按钮。通常不需要修改我们复制出来的这个 tiddler 的设置。</li>
<li><code>description</code>: 这个属性用于设置在 <code>$:/ControlPanel</code> 中的描述，同时这个描述也会显示在当你鼠标悬停在按钮中的提示信息。如果你也希望在多语言中该描述也有正确的对应显示，你应该使用类似于 <code>&#123;&#123;$:/language/Buttons/bigquote/Hint&#125;&#125;</code> 这样的字段来显示描述，以便翻译人员可以添加翻译，创建一个名为 <code>$:/language/Buttons/bigquote/Hint</code> 的 tiddler，并在其中写入英文的按钮描述。当然最简单的方式是使用固定文本作为描述，建议你可以先用这个进行尝试，在进行多语言的 tiddler 替换。</li>
<li><code>icon</code>：这个属性用于设置按钮的图标。我这里采用和 quote 一样的图标，因为实际上我是要禁用 quote 按钮，而启用 bigquote 按钮。</li>
<li><code>shortcut</code>: 这个属性用于设置按钮的快捷键。我这里没有使用快捷键。如果你需要使用快捷键，最兼容性的做法实际上需要创建三个 tiddler，分别是 <code>$:/config/shorcuts-not-mac/bigquote</code>, <code>$:/config/shorcuts-mac/bigquote</code>, <code>$:/cofig/ShortcutInfo/bigquote</code>。在前两个 tiddler 中分别键入对应不同系统的快捷键设置，最后一个 tiddler 中键入 <code>&#123;&#123;$:/language/Buttons/bigquote/Hint&#125;&#125;</code> ，也就是对应的刚刚上面的 <code>description</code> 字段，如果你上面采用的是 tidder 变量的形式这里就可以跟随，如果不是，那么在上面修改 <code>description</code>的时候，这里也应该一并修改。</li>
<li><code>list-before</code>: 这个属性可以调整这个按钮的显示位置，默认会显示在最末尾，你可以通过填入该字段来调整按钮的显示位置。例如填入 <code>$:/core/ui/EditorToolbar/more</code>， 这个按钮就会显示在 more 按钮的前面。</li>
</ul>
</li>
<li>
<p>保存 tiddler，注意复制出来的 tidder 是有个 <code>$:/tags/EditorToolbar</code> 标签的，这个标签不能移除，必须保留</p>
</li>
<li>
<p>现在你就可以在编辑工具栏中看到这个新添加的按钮了，并且你可以在 <code>$:/ControlPanel</code> 的 Appearance &gt; Toolbars &gt; Editor Toolbar 选项卡里面控制这个按钮的显示或隐藏。</p>
</li>
</ol>
<h1>参考资料</h1>
<ul>
<li><a href="https://tiddlywiki.com/#How%20to%20create%20dynamic%20editor%20toolbar%20buttons:%5B%5BHow%20to%20create%20dynamic%20editor%20toolbar%20buttons%5D%5D%20%5B%5BKeyboard%20Shortcut%20Descriptor%5D%5D">TiddlyWiki v5.3.8 — a non-linear personal web notebook</a></li>
</ul>
]]></content>
      <categories>
        <category>技术杂谈</category>
      </categories>
  </entry>
  <entry>
    <title>NVIDIA 深度学习新手入门 Assessment</title>
    <url>/zh-CN/NVIDIADeepLearningStart/</url>
    <content><![CDATA[<p>本文详解 NVIDIA 深度学习新手入门 Assessment 中的代码补全。</p>
<span id="more"></span>
<h1>加载 ImageNet 预训练的基础模型</h1>
<p>第一个FIXME，填入 DEFAULT, 参考迁移学习的 Notebook，此处填入 DEFAULT 即在 ImageNet 上预训练权重载入模型。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torchvision.models <span class="keyword">import</span> vgg16</span><br><span class="line"><span class="keyword">from</span> torchvision.models <span class="keyword">import</span> VGG16_Weights</span><br><span class="line"></span><br><span class="line">weights = VGG16_Weights.DEFAULT</span><br><span class="line">vgg_model = vgg16(weights=weights)</span><br></pre></td></tr></table></figure>
<h1>冻结基础模型</h1>
<p>通过设置 <code>requires_grad_(False)</code> 来冻结基础模型的参数，防止在训练过程中被更新。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">vgg_model.requires_grad_(<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<h1>向模型添加新层</h1>
<p><code>nn.Linear(500, N_CLASSES)</code>是模型的最终输出层，我们需要做一个六分类的任务，所以输出层的维度为 6。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">N_CLASSES = <span class="number">6</span></span><br><span class="line"></span><br><span class="line">my_model = nn.Sequential(</span><br><span class="line">    vgg_model.features,</span><br><span class="line">    vgg_model.avgpool,</span><br><span class="line">    nn.Flatten(),</span><br><span class="line">    vgg_model.classifier[<span class="number">0</span>:<span class="number">3</span>],</span><br><span class="line">    nn.Linear(<span class="number">4096</span>, <span class="number">500</span>),</span><br><span class="line">    nn.ReLU(),</span><br><span class="line">    nn.Linear(<span class="number">500</span>, N_CLASSES)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h1>编译模型</h1>
<p>这里填入 <code>nn.CrossEntropyLoss()</code> 作为损失函数，因为我们是一个六分类任务，所以选择交叉熵损失函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">loss_function = nn.CrossEntropyLoss()</span><br></pre></td></tr></table></figure>
<h1>扩充数据</h1>
<p>这里我先是使用了 O5b Notebook 中的扩充数据代码，但是效果不是很好，原因出在图片的饱和度上，hue值太高导致图片失真，对于水果的新鲜程度和水果的分类来说，颜色是一个重要参考依据，因此这里的饱和度设置不能过高，会误导模型的训练。你也可以将你需要训练的任务描述给AI，让它帮你生成一段扩充数据的代码段，再在此基础上进行微调。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">IMG_WIDTH, IMG_HEIGHT = (<span class="number">224</span>, <span class="number">224</span>)</span><br><span class="line"></span><br><span class="line">random_trans = transforms.Compose([</span><br><span class="line">    transforms.RandomRotation(<span class="number">25</span>),</span><br><span class="line">    transforms.RandomResizedCrop((IMG_WIDTH, IMG_HEIGHT), scale=(<span class="number">.7</span>, <span class="number">1</span>), ratio=(<span class="number">1</span>, <span class="number">1</span>)),</span><br><span class="line">    transforms.RandomHorizontalFlip(p=<span class="number">0.5</span>),</span><br><span class="line">    transforms.ColorJitter(brightness=<span class="number">.2</span>, contrast=<span class="number">.2</span>, saturation=<span class="number">.2</span>, hue=<span class="number">.05</span>), </span><br><span class="line">    transforms.Normalize(mean=[<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>], std=[<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>])</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<h1>加载数据集</h1>
<h2 id="batch-size-选择">batch_size 选择</h2>
<p>参考 05b Notebook 中的代码设置，这里设置 <code>batch_size</code> 为 32，使用 2 的幂次方可以提高训练效率，在中小型数据集上通常采用 32 作为 batch size。</p>
<p>参考教程中的讲解：</p>
<blockquote>
<p>如果我们的数据集是一副卡，那么 <a href="https://pytorch.org/tutorials/beginner/basics/data_tutorial.html#preparing-your-data-for-training-with-dataloaders">DataLoader</a> 就定义了我们如何从这副牌中抽卡来训练 AI 模型。我们可以一次性将整个数据集展示给我们的模型。这不仅需要大量的计算资源，而且<a href="https://arxiv.org/pdf/1804.07612">研究表明</a>使用较小的数据批次（batch）对模型训练更有效。</p>
<p>例如，如果我们的 <code>batch_size</code> 是 32，我们将洗牌并抽取 32 张卡片来训练我们的模型。由于模型在验证时不进行学习，因此不需要洗牌，但我们仍然会使用 <code>batch_size</code> 以防止内存错误。</p>
<p>批大小是模型开发者决定的，最佳值取决于具体的问题。研究表明，对于许多机器学习问题 32 或 64 就足够了，这也是一些机器学习框架的默认值，因此我们在这就用 32。</p>
</blockquote>
<h2 id="shuffle-选择">shuffle 选择</h2>
<p>通常在训练集中设置 <code>shuffle=True</code>，而在验证集中设置 <code>shuffle=False</code>。</p>
<ul>
<li>训练集中设置 <code>shuffle=True</code> 是为了在每个 epoch 开始时随机打乱数据，这有助于模型学习到更泛化的特征。</li>
<li>验证集中设置 <code>shuffle=False</code> 是为了保持验证数据的顺序，这有助于我们在评估模型性能时进行比较。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = <span class="number">32</span></span><br><span class="line"></span><br><span class="line">train_path = <span class="string">&quot;data/fruits/train/&quot;</span></span><br><span class="line">train_data = MyDataset(train_path)</span><br><span class="line">train_loader = DataLoader(train_data, batch_size=n, shuffle=<span class="literal">True</span>)</span><br><span class="line">train_N = <span class="built_in">len</span>(train_loader.dataset)</span><br><span class="line"></span><br><span class="line">valid_path = <span class="string">&quot;data/fruits/valid/&quot;</span></span><br><span class="line">valid_data = MyDataset(valid_path)</span><br><span class="line">valid_loader = DataLoader(valid_data, batch_size=n, shuffle=<span class="literal">False</span>)</span><br><span class="line">valid_N = <span class="built_in">len</span>(valid_loader.dataset)</span><br></pre></td></tr></table></figure>
<h1>训练模型</h1>
<p>首次训练模型因为增强数据集的 <code>hue</code> 设置问题，模型准确率只有85%左右，要通过 Assessment，需要模型准确率在 92% 以上。调整增强数据集 <code>transformer</code> 的操作后，模型准确率提升到了90%左右。仍达不到标准要求，因此参考 Notebook 中的操作，再对模型进行微调。</p>
<p>参考 05b Notebook 中的讲解和代码，这时候我们需要解冻模型，以便对新添加的层进行训练。因此设置 <code>vgg_model.requires_grad_(True)</code>。</p>
<blockquote>
<p>模型的新层经过训练后，我们还有一个可选的技巧，用于进一步改进模型。这个技巧称为<a href="https://developers.google.com/machine-learning/glossary#f">微调</a>。要执行此操作，我们需要先解冻整个模型，然后以极小的<a href="https://developers.google.com/machine-learning/glossary#learning-rate">学习率</a> 重新训练模型。这会让预训练的基础层以非常小的步伐进行微调，从而进一步改进模型的性能。</p>
<p>请注意，只有在包含冻结层和新层的模型经过充分训练后才能执行此步骤，这一点很重要。否则，由于我们先前添加到模型中的新的池化层和分类层是随机地初始化的，我们需要对它们的参数进行大量的更新才能实现准确的图像分类。而通过<a href="https://developers.google.com/machine-learning/glossary#backpropagation">反向传播过程</a>，在整个模型解冻的状态下，这种对最后两层的大量更新也可能导致预训练层中出现大量更新，从而破坏那些重要的预训练特征。现在这最后2层已经过训练且已收敛，因此再次训练时对模型整体的更新都要小得多（尤其是学习率非常小时），不会破坏前面那些层所预学到的特征。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">vgg_model.requires_grad_(<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>模型微调完成后，模型准确率提升到了92%左右，符合要求。运行评估 cell 进行验证即可获得本节课的证书。</p>
<h1>参考资料</h1>
<ol>
<li><a href="https://docs.pytorch.org/vision/main/models/generated/torchvision.models.vgg16.html#torchvision.models.VGG16_Weights">vgg16 — Torchvision main documentation</a></li>
<li><a href="https://docs.pytorch.org/docs/stable/generated/torch.Tensor.requires_grad_.html">torch.Tensor.requires_grad_ — PyTorch 2.10 documentation</a></li>
<li><a href="https://www.codegenes.net/blog/new-pytorch-variable-requires-grad/">Understanding <code>requires_grad</code> in PyTorch — codegenes.net</a></li>
<li>[<a href="https://machinelearningmastery.com/how-to-choose-loss-functions-when-training-deep-learning-neural-networks/">How to Choose Loss Functions When Training Deep Learning Neural Networks - MachineLearningMastery.com</a>]</li>
<li><a href="https://www.geeksforgeeks.org/deep-learning/pytorch-loss-functions/">PyTorch Loss Functions - GeeksforGeeks</a></li>
<li><a href="https://docs.pytorch.org/docs/stable/nn.html#loss-functions">torch.nn — PyTorch 2.10 documentation</a></li>
<li><a href="https://docs.pytorch.org/vision/stable/transforms.html#transforms">Transforming images, videos, boxes and more — Torchvision 0.25 documentation</a></li>
<li><a href="https://docs.pytorch.org/vision/stable/auto_examples/transforms/plot_transforms_getting_started.html">Getting started with transforms v2 — Torchvision 0.25 documentation</a></li>
<li><a href="https://docs.pytorch.org/vision/stable/transforms.html#v2-api-reference-recommended">Transforming images, videos, boxes and more — Torchvision 0.25 documentation</a></li>
<li><a href="https://www.geeksforgeeks.org/deep-learning/pytorch-dataloader/">PyTorch DataLoader - GeeksforGeeks</a></li>
</ol>
]]></content>
      <categories>
        <category>技术杂谈</category>
      </categories>
  </entry>
</search>
